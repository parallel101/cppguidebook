<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="小彭老师">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>让虚函数再次伟大！ - ✝️小彭大典✝️</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/print-site.css" rel="stylesheet">
        <link href="../css/print-site-mkdocs.css" rel="stylesheet">
        <link href="../extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/diff.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/java.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/llvm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/nasm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/txt.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">✝️小彭大典✝️</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">章节列表</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href=".." class="dropdown-item">前言</a>
</li>
                                    
<li>
    <a href="../hello_world/" class="dropdown-item">你好，世界</a>
</li>
                                    
<li>
    <a href="../platform/" class="dropdown-item">开发环境与平台选择</a>
</li>
                                    
<li>
    <a href="../variable_types/" class="dropdown-item">变量与类型 (未完工)</a>
</li>
                                    
<li>
    <a href="../functions/" class="dropdown-item">认识函数 (未完工)</a>
</li>
                                    
<li>
    <a href="../auto/" class="dropdown-item">auto 神教</a>
</li>
                                    
<li>
    <a href="../symbols/" class="dropdown-item">重新认识声明与定义（未完工）</a>
</li>
                                    
<li>
    <a href="../struct_layout/" class="dropdown-item">结构体布局</a>
</li>
                                    
<li>
    <a href="../cpp_tricks/" class="dropdown-item">应知应会 C++ 小技巧</a>
</li>
                                    
<li>
    <a href="../lambda/" class="dropdown-item">小彭老师带你学函数式编程</a>
</li>
                                    
<li>
    <a href="../type_rich_api/" class="dropdown-item">现代化的 API 设计指南</a>
</li>
                                    
<li>
    <a href="../no_more_new/" class="dropdown-item">现代 C++ 从拒绝 new 开始</a>
</li>
                                    
<li>
    <a href="../stl_map/" class="dropdown-item">STL 精讲：std::map 和他的朋友们</a>
</li>
                                    
<li>
    <a href="../design_overview/" class="dropdown-item">设计模式总览 (未完工)</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">让虚函数再次伟大！</a>
</li>
                                    
<li>
    <a href="../design_gamedev/" class="dropdown-item">游戏开发中常用的设计模式</a>
</li>
                                    
<li>
    <a href="../design_functor/" class="dropdown-item">函数式设计模式</a>
</li>
                                    
<li>
    <a href="../design_variant/" class="dropdown-item">静态多态与面向数据编程 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_erasure/" class="dropdown-item">类型擦除神教及其实现 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_concept/" class="dropdown-item">鸭子类型与 C++20 concept (未完工)</a>
</li>
                                    
<li>
    <a href="../error_code/" class="dropdown-item">现代 C++ 错误处理知多少（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_lifetime/" class="dropdown-item">深入理解析构函数与生命周期</a>
</li>
                                    
<li>
    <a href="../cpp_memory/" class="dropdown-item">真正的 C++ 内存模型！ (未完工)</a>
</li>
                                    
<li>
    <a href="../unicode/" class="dropdown-item">字符编码那些事</a>
</li>
                                    
<li>
    <a href="../threading/" class="dropdown-item">C++ 多线程编程（未完工）</a>
</li>
                                    
<li>
    <a href="../test_and_safe/" class="dropdown-item">测试与安全话题（未完工）</a>
</li>
                                    
<li>
    <a href="../undef/" class="dropdown-item">未定义行为完整列表</a>
</li>
                                    
<li>
    <a href="../llvm_intro/" class="dropdown-item">小彭老师带你学 LLVM</a>
</li>
                                    
<li>
    <a href="../cuda_intro/" class="dropdown-item">现代 C++ 的 CUDA 编程</a>
</li>
                                    
<li>
    <a href="../cmake_tutor/" class="dropdown-item">学现代 C++ 从现代 CMake 学起（未完工）</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">关于</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about/" class="dropdown-item">关于小彭老师</a>
</li>
                                    
<li>
    <a href="../donate/" class="dropdown-item">赞助名单</a>
</li>
                                    
<li>
    <a href="../interview/" class="dropdown-item">小彭老师面试经验</a>
</li>
                                    
<li>
    <a href="../recommend/" class="dropdown-item">参考资料与项目推荐</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook" class="nav-link">GitHub</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://space.bilibili.com/263032155" class="nav-link">Bilibili</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../design_overview/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../design_gamedev/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook/edit/master/docs/design_virtual.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">让虚函数再次伟大！</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">虚函数实战案例</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">多重策略</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">不要什么东西都塞一块</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_5" class="nav-link">适配器模式</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_6" class="nav-link">跨接口的适配器</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_7" class="nav-link">工厂模式</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_8" class="nav-link">超级工厂模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#raii" class="nav-link">RAII 自动管理内存</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_9" class="nav-link">工厂模式实战</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_10" class="nav-link">享元模式</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_11" class="nav-link">代理模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_12" class="nav-link">组件模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_13" class="nav-link">虚函数常见问题辨析</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#bool" class="nav-link">返回 bool 的虚函数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_14" class="nav-link">课后作业</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">让虚函数再次伟大！</h1>
<p>许多设计模式都与虚函数息息相关，今天我们来学习一些常用的。</p>
<ul>
<li>策略模式</li>
<li>迭代器模式</li>
<li>适配器模式</li>
<li>工厂模式</li>
<li>超级工厂模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<p>很多教材中都会举出这种看起来好像很有说服力的例子：</p>
<pre><code class="language-cpp">struct Pet {
    virtual void speak() = 0;
};

struct CatPet ：Pet {
    void speak() override {
        puts(&quot;喵&quot;);
    }
};

struct DogPet ：Pet {
    void speak() override {
        puts(&quot;汪&quot;);
    }
};

int main() {
    Pet *cat = new CatPet();
    Pet *dog = new DogPet();
    cat-&gt;speak();
    dog-&gt;speak();
}
</code></pre>
<p>然而，在这个案例中，虚函数可有可无，并没有发挥任何价值，因为普通成员函数也可以实现同样效果。</p>
<p>虚函数真正的价值在于，作为一个参数传入其他函数时！可以复用那个函数里的代码。</p>
<pre><code class="language-cpp">void feed(Pet *pet) {
    puts(&quot;喂食&quot;);
    pet-&gt;speak();
    puts(&quot;喂食完毕&quot;);
}

int main() {
    Pet *cat = new CatPet();
    Pet *dog = new DogPet();
    feed(cat);
    feed(dog);
}
</code></pre>
<p>优点在于，feed 函数只用实现一遍了。如果没有虚函数：</p>
<pre><code class="language-cpp">void feed(DogPet *pet) {
    puts(&quot;喂食&quot;);      // 重复的代码
    puts(&quot;汪&quot;);
    puts(&quot;喂食完毕&quot;);  // 重复的代码
}

void feed(CatPet *pet) {
    puts(&quot;喂食&quot;);      // 重复的代码
    puts(&quot;喵&quot;);
    puts(&quot;喂食完毕&quot;);  // 重复的代码
}
</code></pre>
<p><code>喂食</code> 和 <code>喂食完毕</code> 重复两遍！如果我们又要引入一种新动物 <code>PigPet</code> 呢？你又要手忙脚乱复制粘贴一份新的 feed 函数！</p>
<pre><code class="language-cpp">void feed(PigPet *pet) {
    puts(&quot;喂食&quot;);      // 重复的代码
    puts(&quot;拱&quot;);
    puts(&quot;喂食完毕&quot;);  // 重复的代码
}
</code></pre>
<p>现在，老板突然改了需求，他说动物现在要叫两次。
采用了虚函数的你，只需要在 feed 函数内增加一次 speak 即可，轻松！</p>
<pre><code class="language-cpp">void feed(Pet *pet) {
    puts(&quot;喂食&quot;);
    pet-&gt;speak();
    pet-&gt;speak();  // 加这里
    puts(&quot;喂食完毕&quot;);
}
</code></pre>
<p>而如果一开始没用虚函数，就得连改 3 个地方！</p>
<pre><code class="language-cpp">void feed(DogPet *pet) {
    puts(&quot;喂食&quot;);
    puts(&quot;汪&quot;);  // 改这里
    puts(&quot;汪&quot;);  // 改这里
    puts(&quot;喂食完毕&quot;);
}

void feed(CatPet *pet) {
    puts(&quot;喂食&quot;);
    puts(&quot;喵&quot;);  // 改这里
    puts(&quot;喵&quot;);  // 改这里
    puts(&quot;喂食完毕&quot;);
}

void feed(PigPet *pet) {
    puts(&quot;喂食&quot;);
    puts(&quot;拱&quot;);  // 改这里
    puts(&quot;拱&quot;);  // 改这里
    puts(&quot;喂食完毕&quot;);
}
</code></pre>
<p>而且万一复制粘贴的时候有个地方写错了，非常隐蔽，很容易发现不了：</p>
<pre><code class="language-cpp">void feed(PigPet *pet) {
    puts(&quot;喂食&quot;);
    puts(&quot;拱&quot;);
    puts(&quot;喵&quot;);  // 把猫的代码复制过来的时候漏改了 🤯
    puts(&quot;喂食完毕&quot;);
}
</code></pre>
<h2 id="_2">虚函数实战案例</h2>
<p>小彭老师，你说的这些我都会，这有什么稀奇的。那我们来举个实际开发中会遇到的例子。</p>
<p>这里有一个求和函数，可以计算一个数组中所有数字的和。
还有一个求积函数，可以计算一个数组中所有数字的积。</p>
<pre><code class="language-cpp">int sum(vector&lt;int&gt; v) {
    int res = 0;
    for (int i = 0; i &lt; v.size(); i++) {
        res = res + v[i];
    }
    return res;
}

int product(vector&lt;int&gt; v) {
    int res = 1;
    for (int i = 0; i &lt; v.size(); i++) {
        res = res * v[i];
    }
    return res;
}
</code></pre>
<p>注意到这里面有很多代码重复！</p>
<p>我们观察一下 sum 和 product 之间有哪些相似的部分，把两者产生不同的部分用 ??? 代替。</p>
<pre><code class="language-cpp">int reduce(vector&lt;int&gt; v) {
    int res = ???;            // sum 时这里是 0，product 时这里是 1
    for (int i = 0; i &lt; v.size(); i++) {
        res = res ??? v[i];   // sum 时这里是 +，product 时这里是 *
    }
    return res;
}
</code></pre>
<p>把 ??? 部分用一个虚函数顶替：</p>
<pre><code class="language-cpp">struct Reducer {
    virtual int init() = 0;
    virtual int add(int a, int b) = 0;
};

int reduce(vector&lt;int&gt; v, Reducer *reducer) {
    int res = reducer-&gt;init();
    for (int i = 0; i &lt; v.size(); i++) {
        res = reducer-&gt;add(res, v[i]);
    }
    return res;
}
</code></pre>
<p>这样不论我们想要求和，还是求积，只需要实现其中不同的部分就可以了，公共部分已经在 reduce 里实现好，就实现了代码复用。</p>
<pre><code class="language-cpp">struct SumReducer : Reducer {
    int init() override {
        return 0;
    }

    int add(int a, int b) override {
        return a + b;
    }
};

struct ProductReducer : Reducer {
    int init() override {
        return 1;
    }

    int add(int a, int b) override {
        return a * b;
    }
};
</code></pre>
<pre><code class="language-cpp">reduce(v, new SumReducer());     // 等价于之前的 sum(v)
reduce(v, new ProductReducer()); // 等价于之前的 product(v)
</code></pre>
<p>这就是所谓的<strong>策略模式</strong>。</p>
<p>很容易添加新的策略进来：</p>
<pre><code class="language-cpp">struct MinReducer : Reducer {
    int init() override {
        return numeric_limits&lt;int&gt;::max();
    }

    int add(int a, int b) override {
        return min(a, b);
    }
};

struct MaxReducer : Reducer {
    int init() override {
        return numeric_limits&lt;int&gt;::min();
    }

    int add(int a, int b) override {
        return max(a, b);
    }
};
</code></pre>
<h2 id="_3">多重策略</h2>
<p>现在，老板需求改变，他想要 sum 和 product 函数从输入数据直接计算（而不用先读取到一个 vector）！</p>
<p>还好你早已提前抽出公共部分，现在只需要修改 reduce 函数本身就可以了。</p>
<p>SumReducer 和 ProductReducer 无需任何修改，体现了<strong>开闭原则</strong>。</p>
<pre><code class="language-cpp">int reduce(Reducer *reducer) {
    int res = reducer-&gt;init();
    while (true) {
        int tmp;
        cin &gt;&gt; tmp;
        if (tmp == -1) break;
        res = reducer-&gt;add(res, tmp);
    }
    return res;
}
</code></pre>
<p>现在，老板需求又改回来，他突然又想要从 vector 里读取数据了。</p>
<p>在破口大骂老板出尔反尔的同时，你开始思考，这两个函数似乎还是有一些重复可以抽取出来？</p>
<pre><code class="language-cpp">int cin_reduce(Reducer *reducer) {
    int res = reducer-&gt;init();
    while (true) {
        int tmp;
        cin &gt;&gt; tmp;
        if (tmp == -1) break;
        res = reducer-&gt;add(res, tmp);
    }
    return res;
}

int vector_reduce(vector&lt;int&gt; v, Reducer *reducer) {
    int res = reducer-&gt;init();
    for (int i = 0; i &lt; v.size(); i++) {
        res = reducer-&gt;add(res, v[i]);
    }
    return res;
}
</code></pre>
<p>现在我们只有表示如何计算的类 Reducer 做参数。</p>
<p>你决定，再定义一个表示如何读取的虚类 Inputer。</p>
<pre><code class="language-cpp">struct Inputer {
    virtual optional&lt;int&gt; fetch() = 0;
};

int reduce(Inputer *inputer, Reducer *reducer) {
    int res = reducer-&gt;init();
    while (auto tmp = inputer-&gt;fetch()) {
        res = reducer-&gt;add(res, tmp.value());
    }
    return res;
}
</code></pre>
<p>这样，我们满足了<strong>单一职责原则</strong>：每个类只负责一件事。</p>
<p>这里的 Inputer 实际上运用了<strong>迭代器模式</strong>：提供一个抽象接口来<strong>顺序访问</strong>一个集合中各个元素，而又无须暴露该集合的内部表示。</p>
<blockquote>
<p>底层是 cin 还是 vector？我不在乎！我只知道他可以依次顺序取出数据。</p>
</blockquote>
<pre><code class="language-cpp">struct CinInputer : Inputer {
    optional&lt;int&gt; fetch() override {
        int tmp;
        cin &gt;&gt; tmp;
        if (tmp == -1)
            return nullopt;
        return tmp;
    }
};

struct VectorInputer : Inputer {
    vector&lt;int&gt; v;
    int pos = 0;

    VectorInputer(vector&lt;int&gt; v) : v(v) {}

    optional&lt;int&gt; fetch() override {
        if (pos == v.size())
            return nullopt;
        return v[pos++];
    }
};
</code></pre>
<pre><code class="language-cpp">reduce(new CinInputer(), new SumReducer());
reduce(new VectorInputer(v), new SumReducer());
reduce(new CinInputer(), new ProductReducer());
reduce(new VectorInputer(v), new ProductReducer());
</code></pre>
<p>Inputer 负责告诉 reduce 函数如何读取数据，Reducer 负责告诉 reduce 函数如何计算数据。</p>
<p>这就是<strong>依赖倒置原则</strong>：高层模块（reduce 函数）不要直接依赖于低层模块，二者都依赖于抽象（Inputer 和 Reducer 类）来沟通。</p>
<h2 id="_4">不要什么东西都塞一块</h2>
<p>有些糟糕的实现会把分明不属于同一层次的东西强行放在一起，比如没能分清 Inputer 和 Reducer 类，错误地把他们设计成了一个类！</p>
<pre><code class="language-cpp">int reduce(Reducer *reducer) {
    int res = reducer-&gt;init();
    while (auto tmp = reducer-&gt;fetch()) {  // fetch 凭什么和 init、add 放在一起？
        res = reducer-&gt;add(res, tmp.value());
    }
    return res;
}
</code></pre>
<p>fetch 明明属于 IO 操作！但他被错误地放在了本应只负责计算的 Reducer 里！</p>
<p>这导致你必须实现四个类，罗列所有的排列组合：</p>
<pre><code class="language-cpp">struct CinSumReducer : Reducer { ... };
struct VectorSumReducer : Reducer { ... };
struct CinProductReducer : Reducer { ... };
struct VectorProductReducer : Reducer { ... };
</code></pre>
<p>这显然是不符合<strong>单一责任原则</strong>的。</p>
<p>满足<strong>单一责任原则</strong>、<strong>开闭原则</strong>、<strong>依赖倒置原则</strong>的代码更加灵活、易于扩展、易于维护。请务必记住并落实起来！
否则即你装模作样地用了虚函数，也一样会导致代码重复、难以维护！</p>
<blockquote>
<p>老板克扣工资时就不用遵守这些原则</p>
</blockquote>
<h1 id="_5">适配器模式</h1>
<p>刚才的例子中我们用到了 Inputer 虚接口类。</p>
<pre><code class="language-cpp">struct CinInputer : Inputer {
    optional&lt;int&gt; fetch() override {
        int tmp;
        cin &gt;&gt; tmp;
        if (tmp == -1)
            return nullopt;
        return tmp;
    }
};

struct VectorInputer : Inputer {
    vector&lt;int&gt; v;
    int pos = 0;

    VectorInputer(vector&lt;int&gt; v) : v(v) {}

    optional&lt;int&gt; fetch() override {
        if (pos == v.size())
            return nullopt;
        return v[pos++];
    }
};
</code></pre>
<p>如果我们想要实现：读取到 0 截止，而不是 -1 呢？难道还得给 CinInputer 加个参数？
但是 vector 有时候也可能有读到 -1 就提前截断的需求呀？</p>
<p>这明显违背了<strong>单一责任原则</strong>。</p>
<p>更好的设计是，让 CinInputer 无限读取，永远成功。
然后另外弄一个 StopInputerAdapter，其接受一个 CinInputer 作为构造参数。
当 StopInputerAdapter 被读取时，他会检查是否为 -1，如果已经得到 -1，那么就返回 nullopt，不会进一步调用 CinInputer 了。</p>
<p>StopInputerAdapter 负责处理截断问题，CinInputer 只是负责读取 cin 输入。满足了<strong>单一责任原则</strong>。</p>
<pre><code class="language-cpp">struct StopInputerAdapter : Inputer {
    Inputer *inputer;
    int stopMark;

    StopInputerAdapter(Inputer *inputer, int stopMark)
        : inputer(inputer)
        , stopMark(stopMark)
    {}

    optional&lt;int&gt; fetch() override {
        auto tmp = inputer-&gt;fetch();
        if (tmp == stopMark)
            return nullopt;
        return tmp;
    }
};
</code></pre>
<p>这里的 StopInputerAdapter 就是一个适配器，他把 CinInputer 的接口（无限读取）叠加上了一个额外功能，读到指定的 stopMark 值就停止，产生了一个新的 Inputer。</p>
<pre><code class="language-cpp">reduce(new StopInputerAdapter(new CinInputer(), -1), new SumReducer());      // 从 cin 读到 -1 为止
reduce(new StopInputerAdapter(new VectorInputer(v), -1), new SumReducer());  // 从 vector 读到 -1 为止
reduce(new VectorInputer(), new SumReducer());  // 从 vector 读，但无需截断
</code></pre>
<p>这就是<strong>适配器模式</strong>：将一个类的接口添油加醋，转换成客户希望的另一个接口。</p>
<ul>
<li>StopInputerAdapter 这个适配器本身也是一个 Inputer，可以直接作为 reduce 的参数，适应了现有的<strong>策略模式</strong>。</li>
<li>StopInputerAdapter 并不依赖于参数 Inputer 的底层实现，可以是 CinInputer、也可以是 VectorInputer，满足了<strong>依赖倒置原则</strong>。</li>
<li>未来即使新增了不同类型的 Inputer，甚至是其他 InputerAdapter，一样可以配合 StopInputerAdapter 一起使用而无需任何修改，满足了<strong>开闭原则</strong>。</li>
</ul>
<hr />
<p>如果我们还想实现，过滤出所有正数和零，负数直接丢弃呢？</p>
<pre><code class="language-cpp">struct FilterInputerAdapter {
    Inputer *inputer;

    FilterInputerAdapter(Inputer *inputer)
        : inputer(inputer)
    {}

    optional&lt;int&gt; fetch() override {
        while (true) {
            auto tmp = inputer-&gt;fetch();
            if (!tmp.has_value()) {
                return nullopt;
            }
            if (tmp &gt;= 0) {
                return tmp;
            }
        }
    }
};
</code></pre>
<p>改进：Filter 的条件不应为写死的 <code>tmp &gt;= 0</code>，而应该是传入一个 FilterStrategy，允许用户扩展。</p>
<pre><code class="language-cpp">struct FilterStrategy {
    virtual bool shouldPass(int value) = 0;  // 返回 true 表示该值应该被保留
};

struct FilterStrategyAbove : FilterStrategy { // 大于一定值（threshold）才能通过
    int threshold;

    FilterStrategyAbove(int threshold) : threshold(threshold) {}

    bool shouldPass(int value) override {
        return value &gt; threshold;
    }
};

struct FilterStrategyBelow : FilterStrategy { // 小于一定值（threshold）才能通过
    int threshold;

    FilterStrategyBelow(int threshold) : threshold(threshold) {}

    bool shouldPass(int value) override {
        return value &lt; threshold;
    }
};

struct FilterInputerAdapter : Inputer {
    Inputer *inputer;
    FilterStrategy *strategy;

    FilterInputerAdapter(Inputer *inputer, FilterStrategy *strategy)
        : inputer(inputer), strategy(strategy)
    {}

    optional&lt;int&gt; fetch() override {
        while (true) {
            auto tmp = inputer-&gt;fetch();
            if (!tmp.has_value()) {
                return nullopt;
            }
            if (strategy-&gt;shouldPass(tmp)) {
                return tmp;
            }
        }
    }
};
</code></pre>
<p>FilterStrategy 又可以进一步运用适配器模式：例如我们可以把 FilterStrategyAbove(0) 和 FilterStrategyBelow(100) 组合起来，实现过滤出 0～100 范围内的整数。</p>
<pre><code class="language-cpp">struct FilterStrategyAnd : FilterStrategy {  // 要求 a 和 b 两个过滤策略都为 true，才能通过
    FilterStrategy *a;
    FilterStrategy *b;

    FilterStrategyAnd(FilterStrategy *a, FilterStrategy *b)
        : a(a), b(b)
    {}

    bool shouldPass(int value) override {
        return a-&gt;shouldPass(value) &amp;&amp; b-&gt;shouldPass(value);
    }
};
</code></pre>
<pre><code class="language-cpp">reduce(
    new FilterInputerAdapter(
        new StopInputerAdapter(
            new CinInputer(),
            -1
        ),
        new FilterStrategyAnd(
            new FilterStrategyAbove(0),
            new FilterStrategyBelow(100)
        )
    ),
    new SumReducer());
</code></pre>
<p>是不是逻辑非常清晰，而且容易扩展呢？</p>
<blockquote>
<p>实际上函数式和模板元编程更擅长做这种工作，但今天先介绍完原汁原味的 Java 风格面向对象，他们复用代码的思路是共通的。
你先学会走路，明天我们再来学习跑步，好吧？</p>
</blockquote>
<h2 id="_6">跨接口的适配器</h2>
<p>适配器模式还可以使原本由于接口不兼容而不能一起工作的那些类可以一起工作，例如一个第三方库提供了类似于我们 Inputer 的输入流接口，也是基于虚函数的。但是他的接口显然不能直接传入我们的 reduce 函数，我们的 reduce 函数只接受我们自己的 Inputer 接口。这时就可以用适配器，把接口翻译成我们的 reducer 能够理解的。</p>
<p>以下是一个自称 “Poost” 的第三方库提供的接口：</p>
<pre><code class="language-cpp">struct PoostInputer {
    virtual bool hasNext() = 0;
    virtual int getNext() = 0;
};
</code></pre>
<p>他们要求的用法是先判断 hasNext()，然后才能调用 getNext 读取出真正的值。小彭老师设计了一个 Poost 适配器，把 PoostInputer 翻译成我们的 Inputer：</p>
<pre><code class="language-cpp">struct PoostInputerAdapter : Inputer {
    PoostInputer *poostIn;

    PoostInputerAdapter(PoostInputer *poostIn)
        : poostIn(poostIn)
    {}

    optional&lt;int&gt; fetch() override {
        if (poostIn-&gt;hasNext()) {
            return poostIn-&gt;getNext();
        } else {
            return nullopt;
        }
    }
};
</code></pre>
<p>当我们得到一个 PoostInputer 时，如果想要调用我们自己的 reducer，就可以用这个 PoostInputerAdapter 套一层：</p>
<pre><code class="language-cpp">auto poostStdIn = poost::getStandardInput();
reduce(new PoostInputerAdapter(poostStdIn), new SumReducer());
</code></pre>
<p>这样就可以无缝地把 PoostInputer 作为 reduce 的参数了。</p>
<h1 id="_7">工厂模式</h1>
<p>现在你是一个游戏开发者，你的玩家可以装备武器，不同的武器可以发出不同的子弹！</p>
<p>你使用小彭老师教的<strong>策略模式</strong>，把不同的子弹类型作为不同的策略传入 player 函数，造成不同类型的伤害。</p>
<pre><code class="language-cpp">struct Bullet {
    virtual void explode() = 0;
};

struct AK47Bullet : Bullet {
    void explode() override {
        puts(&quot;物理伤害&quot;);
    }
};

struct MagicBullet : Bullet {
    void explode() override {
        puts(&quot;魔法伤害&quot;);
    }
};

void player(Bullet *bullet) {
    bullet-&gt;explode();
}

player(new AK47Bullet());
player(new MagicBullet());
</code></pre>
<p>但是这样就相当于每个玩家只有一发子弹，听个响就没了…</p>
<p>如何允许玩家源源不断地创造新子弹出来？我们可以把“创建子弹”这一过程抽象出来，放在一个“枪”类里。</p>
<pre><code class="language-cpp">struct Gun {
    virtual Bullet *shoot() = 0;
};

struct AK47Gun : Gun {
    Bullet *shoot() override {
        return new AK47Bullet();
    }
};

struct MagicGun : Gun {
    Bullet *shoot() override {
        return new MagicBullet();
    }
};

void player(Gun *gun) {
    for (int i = 0; i &lt; 100; i++) {
        Bullet *bullet = gun-&gt;shoot();
        bullet-&gt;explode();
    }
}

player(new AK47Gun());
player(new MagicGun());
</code></pre>
<p>现在，你的玩家可以直接选择不同的枪了！</p>
<p>这就是所谓的<strong>工厂模式</strong>：“枪”就是“子弹”对象的工厂。
传给玩家的是子弹的工厂——枪，而不是子弹本身。
只要调用工厂的 shoot 函数，玩家可以源源不断地创建新子弹出来。
正所谓授人以鱼不如授人以渔，你的玩家不再是被动接受子弹，而是可以自己创造子弹了！</p>
<p>工厂还可以具有一定的参数，例如我们需要模拟 AK47 可能“受潮”，导致产生的子弹威力降低。
就可以给枪加一个 isWet 参数，给子弹加一个 damage 参数，让 AK47 生成子弹的时候，根据 isWet 为子弹构造函数设置不同的 damage。</p>
<pre><code class="language-cpp">struct AK47Bullet {
    int damage;

    AK47Bullet(int damage) : damage(damage) {}

    void explode() {
        printf(&quot;造成 %d 点物理伤害\n&quot;, damage);
    }
};

struct AK47Gun : Gun {
    bool isWet;

    AK47Gun(bool isWet) : isWet(isWet) {}

    Bullet *shoot() override {
        if (isWet)
            return new AK47Bullet(5);  // 受潮了，伤害降低为 5
        else
            return new AK47Bullet(10); // 正常情况下伤害为 10
    }
};
</code></pre>
<p>我们还可以利用模板自动为不同的子弹类型批量定义工厂：</p>
<pre><code class="language-cpp">template &lt;class B&gt;
struct GunWithBullet : Gun {
    static_assert(is_base_of&lt;Bullet, B&gt;::value, &quot;B 必须是 Bullet 的子类&quot;);

    Bullet *shoot() override {
        return new B();
    }
};

void player(Gun *gun) {
    for (int i = 0; i &lt; 100; i++) {
        Bullet *bullet = gun-&gt;shoot();
        bullet-&gt;explode();
    }
}

player(new GunWithBullet&lt;AK47Bullet&gt;());
player(new GunWithBullet&lt;MagicBullet&gt;());
</code></pre>
<p>这样就不必每次添加新子弹类型时，都得新建一个相应的枪类型了，进一步避免了代码重复。可见模板元编程完全可与传统面向对象强强联手。</p>
<h2 id="_8">超级工厂模式</h2>
<pre><code class="language-cpp">Gun *getGun(string name) {
    if (name == &quot;AK47&quot;) {
        return new GunWithBullet&lt;AK47Bullet&gt;();
    } else if (name == &quot;Magic&quot;) {
        return new GunWithBullet&lt;MagicBullet&gt;();
    } else {
        throw runtime_error(&quot;没有这种枪&quot;);
    }
}

player(getGun(&quot;AK47&quot;));
player(getGun(&quot;Magic&quot;));
</code></pre>
<h2 id="raii">RAII 自动管理内存</h2>
<pre><code class="language-cpp">template &lt;class B&gt;
struct GunWithBullet : Gun {
    static_assert(is_base_of&lt;Bullet, B&gt;::value, &quot;B 必须是 Bullet 的子类&quot;);

    Bullet *shoot() override {
        return new B();
    }
};

void player(Gun *gun) {
    for (int i = 0; i &lt; 100; i++) {
        Bullet *bullet = gun-&gt;shoot();
        bullet-&gt;explode();
        delete bullet;  // 刚才没有 delete！会产生内存泄漏！
    }
}

player(new GunWithBullet&lt;AK47Bullet&gt;());
player(new GunWithBullet&lt;MagicBullet&gt;());
</code></pre>
<p>现在的工厂一般都会返回智能指针就没有这个问题。</p>
<p>具体来说就是用 <code>unique_ptr&lt;T&gt;</code> 代替 <code>T *</code>，用 <code>make_unique&lt;T&gt;(xxx)</code> 代替 <code>new T(xxx)</code>。</p>
<pre><code class="language-cpp">template &lt;class B&gt;
struct GunWithBullet : Gun {
    static_assert(is_base_of&lt;Bullet, B&gt;::value, &quot;B 必须是 Bullet 的子类&quot;);

    unique_ptr&lt;Bullet&gt; shoot() override {
        return make_unique&lt;B&gt;();
    }
};

void player(Gun *gun) {
    for (int i = 0; i &lt; 100; i++) {
        auto bullet = gun-&gt;shoot();
        bullet-&gt;explode();
        // unique_ptr 在退出当前 {} 时会自动释放，不用你惦记着了
    }
}

player(make_unique&lt;GunWithBullet&lt;AK47Bullet&gt;&gt;().get());
player(make_unique&lt;GunWithBullet&lt;MagicBullet&gt;&gt;().get());
</code></pre>
<blockquote>
<p>这里 C++ 标准保证了 unique_ptr 的生命周期是这一整行（; 结束前），整个 player 执行期间都活着，不会提前释放
正如 <code>func(string().c_str())</code> 不会有任何问题，string 要到 func 返回后才释放呢！</p>
</blockquote>
<p>只要把所有 <code>make_unique&lt;T&gt;</code> 看作 <code>new T</code>，把所有的 <code>unique_ptr&lt;T&gt;</code> 看作 <code>T *</code>，用法几乎一样，但没有内存泄漏，无需手动 delete。</p>
<h2 id="_9">工厂模式实战</h2>
<p>回到数组求和问题。</p>
<pre><code class="language-cpp">int sum(vector&lt;int&gt; v) {
    int res = 0;
    for (int i = 0; i &lt; v.size(); i++) {
        res = res + v[i];
    }
    return res;
}

int product(vector&lt;int&gt; v) {
    int res = 1;
    for (int i = 0; i &lt; v.size(); i++) {
        res = res * v[i];
    }
    return res;
}

int average(vector&lt;int&gt; v) {
    int res = 0;
    int count = 0;
    for (int i = 0; i &lt; v.size(); i++) {
        res = res + v[i];
        count = count + 1;
    }
    return res / count;
}
</code></pre>
<p>我们想要加一个求平均值的函数 average，这该如何与 sum 合起来？</p>
<p>注意因为我们要支持从 CinInputer 读入数据，并不一定像一样 VectorInputer 能够提前得到数组大小，不然也不需要 count 了。</p>
<pre><code class="language-cpp">int reduce(vector&lt;int&gt; v) {
    int res = ???;              // sum 时这里是 0，product 时这里是 1
    int count? = ???;           // sum 和 product 用不到该变量，只有 average 需要
    for (int i = 0; i &lt; v.size(); i++) {
        res = res ??? v[i];   // sum 时这里是 +，product 时这里是 *
        count? = count? ???;  // average 时这里还需要额外修改 count 变量！
    }
    return res;
}
</code></pre>
<p>看来我们需要允许 Reducer 的 init() 返回 “任意数量的状态变量”！
以前的设计让 init() 只能返回单个 int 是个错误的决定。
这时候就可以把 “任意数量的状态变量” 封装成一个新的类。
然后改为由这个类负责提供虚函数 add()。
且只需要提供一个右侧参数了，左侧的 res 变量已经存在 ReducerState 体内了。</p>
<pre><code class="language-cpp">struct ReducerState {
    virtual void add(int val) = 0;
    virtual int result() = 0;
};

struct Reducer {
    virtual unique_ptr&lt;ReducerState&gt; init() = 0;
};

struct SumReducerState : ReducerState {
    int res;

    SumReducerState() : res(0) {}

    void add(int val) override {
        res = res + val;
    }

    int result() override {
        return res;
    }
};

struct ProductReducerState : ReducerState {
    int res;

    ProductReducerState() : res(1) {}

    void add(int val) override {
        res = res * val;
    }

    int result() override {
        return res;
    }
};

struct AverageReducerState : ReducerState {
    int res;
    int count;

    AverageReducerState() : res(0), count(0) {}

    void add(int val) override {
        res = res + val;
        count = count + 1;
    }

    int result() override {
        return res / count;
    }
};

struct SumReducer : Reducer {
    unique_ptr&lt;ReducerState&gt; init() override {
        return make_unique&lt;SumReducerState&gt;();
    }
};

struct ProductReducer : Reducer {
    unique_ptr&lt;ReducerState&gt; init() override {
        return make_unique&lt;ProductReducerState&gt;();
    }
};

struct AverageReducer : Reducer {
    unique_ptr&lt;ReducerState&gt; init() override {
        return make_unique&lt;AverageReducerState&gt;();
    }
};
</code></pre>
<p>这里 Reducer 就成了 ReducerState 的工厂。</p>
<pre><code class="language-cpp">int reduce(Inputer *inputer, Reducer *reducer) {
    unique_ptr&lt;ReducerState&gt; state = reducer-&gt;init();
    while (auto val = inputer-&gt;fetch()) {
        state-&gt;add(val);
    }
    return state-&gt;result();
}

int main() {
    vector&lt;int&gt; v;
    reduce(make_unique&lt;VectorInputer&gt;(v).get(), make_unique&lt;SumReducer&gt;().get());
    reduce(make_unique&lt;VectorInputer&gt;(v).get(), make_unique&lt;ProductReducer&gt;().get());
    reduce(make_unique&lt;VectorInputer&gt;(v).get(), make_unique&lt;AverageReducer&gt;().get());
}
</code></pre>
<hr />
<p>现在，老板需求改变，他想要<strong>并行</strong>的 sum 和 product 函数！</p>
<p>并行版需要创建很多个任务，每个任务需要有一个自己的中间结果变量，最后的结果计算又需要一个中间变量。
还好你早已提前采用工厂模式，允许函数体内多次创建 ReducerState 对象。</p>
<pre><code class="language-cpp">int reduce(Inputer *inputer, Reducer *reducer) {
    tbb::task_group g;
    list&lt;unique_ptr&lt;ReducerState&gt;&gt; local_states;
    vector&lt;int&gt; chunk;
    auto enqueue_chunk = [&amp;]() {
        local_chunks.emplace_back();
        g.run([chunk = move(chunk), &amp;back = local_chunks.back()]() {
            auto local_state = reducer-&gt;init();
            for (auto &amp;&amp;c: chunk) {
                local_state-&gt;add(c);
            }
            back = move(local_state); // list 保证已经插入元素的引用不会失效，所以可以暂存 back 引用
        });
        chunk.clear();
    };
    while (auto tmp = inputer-&gt;fetch()) {
        if (chunk.size() &lt; 64) { // 还没填满 64 个
            chunk.push_back(tmp);
        } else { // 填满了 64 个，可以提交成一个单独任务了
            enqueue_chunk();
        }
    }
    if (chunk.size() &gt; 0) {
        enqueue_chunk(); // 提交不足 64 个的残余项
    }
    g.wait();
    auto final_state = reducer-&gt;init();
    for (auto &amp;&amp;local_state: local_states) {
        res = final_state-&gt;add(local_state-&gt;result());
    }
    return final_state-&gt;result();
}
</code></pre>
<p>只需要把 reducer 参数替换为 MinReducer、AverageReducer……就自动适用于不同的计算任务，而不用为他们每个单独编写并行版本的代码。</p>
<p>课后作业：使用模板批量定义所有的 Reducer！例如：</p>
<pre><code class="language-cpp">using MinReducer = ReducerWithState&lt;MinReducerState&gt;;
...
</code></pre>
<h1 id="_10">享元模式</h1>
<p>在二维游戏开发中，常常会提到一种称为 Sprite（精灵贴图）的黑话，实际上就是每个对象自己有一张贴图，贴图跟着物体的位置走。</p>
<pre><code class="language-cpp">struct Bullet {
    glm::vec3 position;
    glm::vec3 velocity;
    vector&lt;char&gt; texture;

    void draw() {
        glDrawPixels(position, texture);
    }
};
</code></pre>
<p>texture 里面存储着贴图的 RGB 数据，他直接就是 Bullet 的成员。
这样的话，如果我们的玩家打出了 100 颗子弹，就需要存储 100 个贴图数组。
如果我们的玩家同时打出了 1000 颗子弹，就需要存储 1000 个贴图数组。
这样的话，内存消耗将会非常大。然而所有同类型的 Bullet，其贴图数组其实是完全相同的，完全没必要各自存那么多份拷贝。</p>
<p>为解决这个问题，我们可以使用<strong>享元模式</strong>：共享多个对象之间<strong>相同</strong>的部分，节省内存开销。</p>
<p>这里每颗子弹的 position、velocity 显然都是各有不同的，不可能所有子弹都在同一个位置上。
但是很多子弹都会有着相同的贴图，只有不同类型的子弹贴图会不一样。
比如火焰弹和寒冰弹会有不同的贴图，但是当场上出现 100 颗火焰弹时，显然不需要拷贝 100 份完全相同的火焰弹贴图。</p>
<pre><code class="language-cpp">struct Sprite {  // Sprite 才是真正持有（很大的）贴图数据的
    vector&lt;char&gt; texture;

    void draw(glm::vec3 position) {
        glDrawPixels(position, texture);
    }
};

struct Bullet {
    glm::vec3 position;
    glm::vec3 velocity;
    shared_ptr&lt;Sprite&gt; sprite;  // 允许多个子弹对象共享同一个精灵贴图的所有权

    void draw() {
        sprite-&gt;draw(position);  // 转发给 Sprite 让他帮忙在我的位置绘制贴图
    }
};
</code></pre>
<p>需要绘制子弹时，Bullet 的 draw 只是简单地转发给 Sprite 类的 draw。
只要告诉 Sprite 子弹的位置就行，贴图数据已经存在 Sprite 内部，让他来负责真正绘制。
Bullet 类只需要专注于位置、速度的更新即可，不必去操心着贴图绘制的细节，实现了解耦。</p>
<p>这种函数调用的转发也被称为<strong>代理模式</strong>。</p>
<h2 id="_11">代理模式</h2>
<p>这样还有一个好处那就是，Sprite 可以设计成一个虚函数接口类：</p>
<pre><code class="language-cpp">struct Sprite {
    virtual void draw(glm::vec3 position) = 0;
};

struct FireSprite : Sprite {
    vector&lt;char&gt; fireTexture;

    FireSprite() : fireTexture(loadTexture(&quot;fire.jpg&quot;)) {}

    void draw(glm::vec3 position) override {
        glDrawPixels(position, fireTexture);
    }
};

struct IceSprite : Sprite { // 假如寒冰弹需要两张贴图，也没问题！因为虚接口类允许子类有不同的成员，不同的结构体大小
    vector&lt;char&gt; iceTexture1;
    vector&lt;char&gt; iceTexture2;

    IceSprite()
    : iceTexture1(loadTexture(&quot;ice1.jpg&quot;))
    , iceTexture2(loadTexture(&quot;ice2.jpg&quot;))
    {}

    void draw(glm::vec3 position) override {
        glDrawPixels(position, iceTexture1);
        glDrawPixels(position, iceTexture2);
    }
};
</code></pre>
<pre><code class="language-cpp">struct Bullet {
    glm::vec3 position;
    glm::vec3 velocity;
    shared_ptr&lt;Sprite&gt; sprite;  // Sprite 负责含有虚函数

    void draw() {  // Bullet 的 draw 就不用是虚函数了！
        sprite-&gt;draw(position);
    }
};
</code></pre>
<h1 id="_12">组件模式</h1>
<pre><code class="language-cpp"></code></pre>
<h1 id="_13">虚函数常见问题辨析</h1>
<h2 id="bool">返回 bool 的虚函数</h2>
<h2 id="_14">课后作业</h2>
<p>你拿到了一个大学生计算器的大作业：</p>
<pre><code class="language-cpp">int main() {
    char c;
    cout &lt;&lt; &quot;请输入第一个数：&quot;;
    cin &gt;&gt; a;
    cout &lt;&lt; &quot;请输入第二个数：&quot;;
    cin &gt;&gt; b;
    cout &lt;&lt; &quot;请输入运算符：&quot;;
    cin &gt;&gt; c;
    if (c == '+') {
        cout &lt;&lt; a + b;
    } else if (c == '-') {
        cout &lt;&lt; a - b;
    } else if (c == '*') {
        cout &lt;&lt; a * b;
    } else if (c == '/') {
        cout &lt;&lt; a / b;
    } else {
        cout &lt;&lt; &quot;不支持的运算符&quot;;
    }
}
</code></pre>
<p>你开始用策略模式改造它：</p>
<pre><code class="language-cpp">struct Calculator {
    virtual int calculate(int a, int b) = 0;
};

struct AddCalculator : Calculator {
    int calculate(int a, int b) override {
        return a + b;
    }
};

struct SubCalculator : Calculator {
    int calculate(int a, int b) override {
        return a - b;
    }
};

struct MulCalculator : Calculator {
    int calculate(int a, int b) override {
        return a * b;
    }
};

struct DivCalculator : Calculator {
    int calculate(int a, int b) override {
        return a / b;
    }
};

Calculator *getCalculator(char c) {
    if (c == '+') {
        calculator = new AddCalculator();
    } else if (c == '-') {
        calculator = new SubCalculator();
    } else if (c == '*') {
        calculator = new MulCalculator();
    } else if (c == '/') {
        calculator = new DivCalculator();
    } else {
        throw runtime_error(&quot;不支持的运算符&quot;);
    }
};

int main() {
    char c;
    cout &lt;&lt; &quot;请输入第一个数：&quot;;
    cin &gt;&gt; a;
    cout &lt;&lt; &quot;请输入第二个数：&quot;;
    cin &gt;&gt; b;
    cout &lt;&lt; &quot;请输入运算符：&quot;;
    cin &gt;&gt; c;
    Calculator *calculator = getCalculator(c);
    cout &lt;&lt; calculator-&gt;calculate(a, b);
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>小彭老师倾 ♥ 制作</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../js/print-site.js"></script>
        <script src="../extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
