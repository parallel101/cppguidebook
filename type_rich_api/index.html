<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="小彭老师">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>现代化的 API 设计指南 - ✝️小彭大典✝️</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/print-site-enum-headings1.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings2.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings3.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings4.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings5.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings6.css" rel="stylesheet">
        <link href="../css/print-site.css" rel="stylesheet">
        <link href="../css/print-site-mkdocs.css" rel="stylesheet">
        <link href="../extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/diff.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/java.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/llvm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/nasm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/txt.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">✝️小彭大典✝️</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">章节列表</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href=".." class="dropdown-item">前言</a>
</li>
                                    
<li>
    <a href="../hello_world/" class="dropdown-item">你好，世界</a>
</li>
                                    
<li>
    <a href="../platform/" class="dropdown-item">开发环境与平台选择</a>
</li>
                                    
<li>
    <a href="../variable_types/" class="dropdown-item">变量与类型 (未完工)</a>
</li>
                                    
<li>
    <a href="../functions/" class="dropdown-item">认识函数 (未完工)</a>
</li>
                                    
<li>
    <a href="../auto/" class="dropdown-item">auto 神教 (未完工)</a>
</li>
                                    
<li>
    <a href="../symbols/" class="dropdown-item">重新认识声明与定义（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_tricks/" class="dropdown-item">应知应会 C++ 小技巧</a>
</li>
                                    
<li>
    <a href="../lambda/" class="dropdown-item">小彭老师带你学函数式编程</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">现代化的 API 设计指南</a>
</li>
                                    
<li>
    <a href="../no_more_new/" class="dropdown-item">现代 C++ 从拒绝 new 开始</a>
</li>
                                    
<li>
    <a href="../stl_map/" class="dropdown-item">STL 精讲：std::map 和他的朋友们</a>
</li>
                                    
<li>
    <a href="../design_overview/" class="dropdown-item">设计模式总览 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_virtual/" class="dropdown-item">让虚函数再次伟大！</a>
</li>
                                    
<li>
    <a href="../design_gamedev/" class="dropdown-item">游戏开发中常用的设计模式</a>
</li>
                                    
<li>
    <a href="../design_functor/" class="dropdown-item">函数式设计模式</a>
</li>
                                    
<li>
    <a href="../design_variant/" class="dropdown-item">静态多态与面向数据编程 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_erasure/" class="dropdown-item">类型擦除神教及其实现 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_concept/" class="dropdown-item">鸭子类型与 C++20 concept (未完工)</a>
</li>
                                    
<li>
    <a href="../error_code/" class="dropdown-item">现代 C++ 错误处理知多少（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_lifetime/" class="dropdown-item">深入理解析构函数与生命周期</a>
</li>
                                    
<li>
    <a href="../cpp_memory/" class="dropdown-item">真正的 C++ 内存模型！ (未完工)</a>
</li>
                                    
<li>
    <a href="../unicode/" class="dropdown-item">字符编码那些事</a>
</li>
                                    
<li>
    <a href="../threading/" class="dropdown-item">C++ 多线程编程（未完工）</a>
</li>
                                    
<li>
    <a href="../test_and_safe/" class="dropdown-item">测试与安全话题（未完工）</a>
</li>
                                    
<li>
    <a href="../undef/" class="dropdown-item">未定义行为完整列表</a>
</li>
                                    
<li>
    <a href="../llvm_intro/" class="dropdown-item">小彭老师带你学 LLVM</a>
</li>
                                    
<li>
    <a href="../cuda_intro/" class="dropdown-item">现代 C++ 的 CUDA 编程</a>
</li>
                                    
<li>
    <a href="../cmake_tutor/" class="dropdown-item">学现代 C++ 从现代 CMake 学起（未完工）</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">关于</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about/" class="dropdown-item">关于小彭老师</a>
</li>
                                    
<li>
    <a href="../donate/" class="dropdown-item">赞助名单</a>
</li>
                                    
<li>
    <a href="../interview/" class="dropdown-item">小彭老师面试经验</a>
</li>
                                    
<li>
    <a href="../recommend/" class="dropdown-item">参考资料与项目</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook" class="nav-link">GitHub</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://space.bilibili.com/263032155" class="nav-link">Bilibili</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../lambda/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../no_more_new/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook/edit/master/docs/type_rich_api.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#api" class="nav-link">现代化的 API 设计指南</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">结构体传参</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_5" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_6" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_7" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_8" class="nav-link">返回一个结构体</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_9" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_10" class="nav-link">类型即注释</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_11" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_12" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_13" class="nav-link">拒绝指针！</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_14" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_15" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_16" class="nav-link">强类型封装</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_17" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_18" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#span" class="nav-link">span “胖指针”</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_19" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_20" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_21" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_22" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_23" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_24" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_25" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_26" class="nav-link">空值语义</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_27" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_28" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_29" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_30" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_31" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_32" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_33" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_34" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_35" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_36" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_37" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_38" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_39" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#stl" class="nav-link">点名批评的 STL 设计</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_40" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_41" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_42" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_43" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#stl_1" class="nav-link">点名表扬的 STL 部分</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_44" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_45" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_46" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_47" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_48" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_49" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_50" class="nav-link">枚举类型</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_51" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_52" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_53" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_54" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_55" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_56" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_57" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_58" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_59" class="nav-link">其他类型套皮</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_60" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_61" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#raii" class="nav-link">RAII 封装</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_62" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_63" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_64" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#mutex" class="nav-link">Mutex 封装</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_65" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_66" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cuda" class="nav-link">彩蛋：CUDA 封装实战</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_67" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_68" class="nav-link">变量名与作用域限制</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_69" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_70" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#getset" class="nav-link">你真的需要 get/set 吗？</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_71" class="nav-link">&mdash;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="api">现代化的 API 设计指南</h1>
<p>如何写出易于维护的代码，阻止犯错？</p>
<p><strong>类型就是最好的注释！</strong></p>
<p><strong>Type is all you need</strong></p>
<div class="toc">
<ul>
<li><a href="#api">现代化的 API 设计指南</a><ul>
<li><a href="#_1">&mdash;</a></li>
<li><a href="#_2">结构体传参</a></li>
<li><a href="#_3">&mdash;</a></li>
<li><a href="#_4">&mdash;</a></li>
<li><a href="#_5">&mdash;</a></li>
<li><a href="#_6">&mdash;</a></li>
<li><a href="#_7">&mdash;</a></li>
<li><a href="#_8">返回一个结构体</a></li>
<li><a href="#_9">&mdash;</a></li>
<li><a href="#_10">类型即注释</a></li>
<li><a href="#_11">&mdash;</a></li>
<li><a href="#_12">&mdash;</a></li>
<li><a href="#_13">拒绝指针！</a></li>
<li><a href="#_14">&mdash;</a></li>
<li><a href="#_15">&mdash;</a></li>
<li><a href="#_16">强类型封装</a></li>
<li><a href="#_17">&mdash;</a></li>
<li><a href="#_18">&mdash;</a></li>
<li><a href="#span">span “胖指针”</a></li>
<li><a href="#_19">&mdash;</a></li>
<li><a href="#_20">&mdash;</a></li>
<li><a href="#_21">&mdash;</a></li>
<li><a href="#_22">&mdash;</a></li>
<li><a href="#_23">&mdash;</a></li>
<li><a href="#_24">&mdash;</a></li>
<li><a href="#_25">&mdash;</a></li>
<li><a href="#_26">空值语义</a></li>
<li><a href="#_27">&mdash;</a></li>
<li><a href="#_28">&mdash;</a></li>
<li><a href="#_29">&mdash;</a></li>
<li><a href="#_30">&mdash;</a></li>
<li><a href="#_31">&mdash;</a></li>
<li><a href="#_32">&mdash;</a></li>
<li><a href="#_33">&mdash;</a></li>
<li><a href="#_34">&mdash;</a></li>
<li><a href="#_35">&mdash;</a></li>
<li><a href="#_36">&mdash;</a></li>
<li><a href="#_37">&mdash;</a></li>
<li><a href="#_38">&mdash;</a></li>
<li><a href="#_39">&mdash;</a></li>
<li><a href="#stl">点名批评的 STL 设计</a></li>
<li><a href="#_40">&mdash;</a></li>
<li><a href="#_41">&mdash;</a></li>
<li><a href="#_42">&mdash;</a></li>
<li><a href="#_43">&mdash;</a></li>
<li><a href="#stl_1">点名表扬的 STL 部分</a></li>
<li><a href="#_44">&mdash;</a></li>
<li><a href="#_45">&mdash;</a></li>
<li><a href="#_46">&mdash;</a></li>
<li><a href="#_47">&mdash;</a></li>
<li><a href="#_48">&mdash;</a></li>
<li><a href="#_49">&mdash;</a></li>
<li><a href="#_50">枚举类型</a></li>
<li><a href="#_51">&mdash;</a></li>
<li><a href="#_52">&mdash;</a></li>
<li><a href="#_53">&mdash;</a></li>
<li><a href="#_54">&mdash;</a></li>
<li><a href="#_55">&mdash;</a></li>
<li><a href="#_56">&mdash;</a></li>
<li><a href="#_57">&mdash;</a></li>
<li><a href="#_58">&mdash;</a></li>
<li><a href="#_59">其他类型套皮</a></li>
<li><a href="#_60">&mdash;</a></li>
<li><a href="#_61">&mdash;</a></li>
<li><a href="#raii">RAII 封装</a></li>
<li><a href="#_62">&mdash;</a></li>
<li><a href="#_63">&mdash;</a></li>
<li><a href="#_64">&mdash;</a></li>
<li><a href="#mutex">Mutex 封装</a></li>
<li><a href="#_65">&mdash;</a></li>
<li><a href="#_66">&mdash;</a></li>
<li><a href="#cuda">彩蛋：CUDA 封装实战</a></li>
<li><a href="#_67">&mdash;</a></li>
<li><a href="#_68">变量名与作用域限制</a></li>
<li><a href="#_69">&mdash;</a></li>
<li><a href="#_70">&mdash;</a></li>
<li><a href="#getset">你真的需要 get/set 吗？</a></li>
<li><a href="#_71">&mdash;</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">&mdash;</h2>
<hr />
<h2 id="_2">结构体传参</h2>
<h2 id="_3">&mdash;</h2>
<hr />
<pre><code class="language-cpp">void foo(string name, int age, int phone, int address);

foo(&quot;小彭老师&quot;, 24, 12345, 67890);
</code></pre>
<ul>
<li>痛点：参数多，类型相似，容易顺序写错而自己不察觉</li>
<li>天书：阅读代码时看不见参数名，不清楚每个参数分别代表什么</li>
</ul>
<blockquote>
<p>怎么办？</p>
</blockquote>
<pre><code class="language-cpp">struct FooOptions {
    string name;
    int age;
    int phone;
    int address;
};

void foo(FooOptions opts);

foo({.name = &quot;小彭老师&quot;, .age = 24, .phone = 12345, .address = 67890});
</code></pre>
<p>✔️ 优雅，每个参数负责做什么一目了然</p>
<h2 id="_4">&mdash;</h2>
<hr />
<p>也有某些大厂推崇注释参数名来增强可读性：</p>
<pre><code class="language-cpp">foo(/*name=*/&quot;小彭老师&quot;, /*age=*/24, /*phone=*/12345, /*address=*/67890);
</code></pre>
<p>但注释可以骗人：</p>
<pre><code class="language-cpp">foo(/*name=*/&quot;小彭老师&quot;, /*phone=*/12345, /*age=*/24, /*address=*/67890);
</code></pre>
<blockquote>
<p>这里 age 和 phone 参数写反了！阅读者如果不看下 foo 的定义，根本发现不了</p>
</blockquote>
<p>而代码不会：</p>
<pre><code class="language-cpp">// 即使顺序写错，只要名字写对依然可以正常运行
foo({.name = &quot;小彭老师&quot;, .phone = 12345, .age = 24, .address = 67890});
</code></pre>
<blockquote>
<p>总之，好的 API 设计绝不会给人留下犯错的机会！</p>
</blockquote>
<h2 id="_5">&mdash;</h2>
<hr />
<p>再来看一个场景，假设foo内部需要把所有参数转发给另一个函数bar：</p>
<pre><code class="language-cpp">void bar(int index, string name, int age, int phone, int address);

void foo(string name, int age, int phone, int address) {
    bar(get_hash_index(name), name, age, phone, address);
}
</code></pre>
<ul>
<li>痛点：你需要不断地复制粘贴所有这些参数，非常容易抄错</li>
<li>痛点：一旦参数类型有所修改，或者要加新参数，需要每个地方都改一下</li>
</ul>
<blockquote>
<p>怎么办？</p>
</blockquote>
<pre><code class="language-cpp">struct FooOptions {
    string name;
    int age;
    int phone;
    int address;
};

void bar(int index, FooOptions opts);

void foo(FooOptions opts) {
    // 所有逻辑上相关的参数全合并成一个结构体，方便使用更方便阅读
    bar(get_hash_index(opts.name), opts);
}
</code></pre>
<p>✔️ 优雅</p>
<h2 id="_6">&mdash;</h2>
<hr />
<p>当老板要求你增加一个参数 sex，加在 age 后面：</p>
<pre><code class="language-diff">-void foo(string name, int age, int phone, int address);
+void foo(string name, int age, int sex, int phone, int address);
</code></pre>
<p>你手忙脚乱地打开所有调用了 foo 的文件，发现有大量地方需要修改&hellip;</p>
<p>而优雅的 API 总设计师小彭老师只需轻轻修改一处：</p>
<pre><code class="language-cpp">struct FooOptions {
    string name;
    int age;
    int sex = 0; // 令 sex 默认为 0
    int phone;
    int address;
};
</code></pre>
<p>所有的老代码依然照常调用新的 foo 函数，未指定的 sex 会具有结构体里定义的默认值 0：</p>
<pre><code class="language-cpp">foo({.name = &quot;小彭老师&quot;, .phone = 12345, .age = 24, .address = 67890});
</code></pre>
<h2 id="_7">&mdash;</h2>
<hr />
<h2 id="_8">返回一个结构体</h2>
<p>当你需要多个返回值时：不要返回 pair 或 tuple！</p>
<p>一些 STL 容器的 API 设计是反面典型，例如：</p>
<pre><code class="language-cpp">std::pair&lt;bool, iterator&gt; insert(std::pair&lt;K, V&gt; entry);
</code></pre>
<p>用的时候每次都要想一下，到底第一个是 bool 还是第二个是 bool 来着？然后看一眼 IDE 提示，才反应过来。</p>
<pre><code class="language-cpp">auto result = map.insert({&quot;hello&quot;, &quot;world&quot;});

cout &lt;&lt; &quot;是否成功: &quot; &lt;&lt; result.first &lt;&lt; '\n';
cout &lt;&lt; &quot;插入到位置: &quot; &lt;&lt; result.second &lt;&lt; '\n';
</code></pre>
<p>first？second？这算什么鬼？</p>
<p>更好的做法是返回一个定制的结构体：</p>
<pre><code class="language-cpp">struct insert_result_t {
    bool success;
    iterator position;
};

insert_result_t insert(std::pair&lt;K, V&gt; entry);
</code></pre>
<p>直接通过名字访问成员，语义清晰明确，我管你是第一个第二个，我只想要表示“是否成功(success)”的那个变量。</p>
<pre><code class="language-cpp">auto result = map.insert({&quot;hello&quot;, &quot;world&quot;});

cout &lt;&lt; &quot;是否成功: &quot; &lt;&lt; result.success &lt;&lt; '\n';
cout &lt;&lt; &quot;插入到位置: &quot; &lt;&lt; result.position &lt;&lt; '\n';
</code></pre>
<p>最好当然是返回和参数类型都是结构体：</p>
<pre><code class="language-cpp">struct insert_result_t {
    bool success;
    iterator position;
};

struct map_entry_t {
    K key;
    V value;
};

insert_result_t insert(map_entry_t entry);
</code></pre>
<p>这里说的都比较激进，你可能暂时不会认同，等你大手大脚犯了几个错以后，你自然会心服口服。
小彭老师以前也和你一样是指针仙人，不喜欢强类型，喜欢 <code>void *</code> 满天飞，然后随便改两行就蹦出个 Segmentation Fault，指针一时爽，调试火葬场，然后才开始反思。</p>
<p>STL 中依然在大量用 pair 是因为 map 容器出现的很早，历史原因。
我们自己项目的 API 就不要设计成这熊样了。</p>
<blockquote>
<p>当然，和某些二级指针返回仙人相比 <code>cudaError_t cudaMalloc(void **pret);</code>，返回 pair 已经算先进的了</p>
</blockquote>
<p>例如 C++17 中的 <code>from_chars</code> 函数，他的返回类型就是一个定制的结构体：</p>
<pre><code class="language-cpp">struct from_chars_result {
    const char *ptr;
    errc ec;
};

from_chars_result from_chars(const char *first, const char *last, int &amp;value);
</code></pre>
<p>这说明他们也已经意识到了以前动不动返回 pair 的设计是有问题的，已经在新标准中开始改用更好的设计。</p>
<h2 id="_9">&mdash;</h2>
<hr />
<h2 id="_10">类型即注释</h2>
<p>你是一个新来的员工，看到下面这个函数：</p>
<pre><code class="language-cpp">void foo(char *x);
</code></pre>
<p>这里的 x 有可能是：</p>
<ol>
<li>0结尾字符串，只读，但是作者忘了加 const</li>
<li>指向单个字符，用于返回单个 char（指针返回仙人）</li>
<li>指向一个字符数组缓冲区，用于返回字符串，但缓冲区大小的确定方式未知</li>
</ol>
<p>如果作者没写文档，变量名又非常含糊，根本不知道这个 x 参数要怎么用。</p>
<blockquote>
<p>类型写的好，能起到注释的作用！</p>
</blockquote>
<pre><code class="language-cpp">void foo(string x);
</code></pre>
<p>这样就一目了然了，很明显，是字符串类型的参数。</p>
<pre><code class="language-cpp">void foo(string &amp;x);
</code></pre>
<p>看起来是返回一个字符串，但是通过引用传参的方式来返回的</p>
<pre><code class="language-cpp">string foo();
</code></pre>
<p>通过常规方式直接返回一个字符串。</p>
<pre><code class="language-cpp">void foo(vector&lt;uint8_t&gt; x);
</code></pre>
<p>是一个 8 位无符号整数组成的数组！</p>
<pre><code class="language-cpp">void foo(span&lt;uint8_t&gt; x);
</code></pre>
<p>是一个 8 位无符号整数的数组切片。</p>
<pre><code class="language-cpp">void foo(string_view x);
</code></pre>
<p>是一个字符串的切片，可能是作者想要避免拷贝开销。</p>
<h2 id="_11">&mdash;</h2>
<hr />
<p>还可以使用类型别名：</p>
<pre><code class="language-cpp">using ISBN = string;

BookInfo foo(ISBN isbn);
</code></pre>
<p>这样用户一看就明白，这个函数是接收一个 ISBN 编号（出版刊物都有一个这种编号），返回关于这本书的详细信息。</p>
<p>尽管函数名 foo 让人摸不着头脑，但仅凭直观的类型标识，我们就能函数功能把猜的七七八八。</p>
<h2 id="_12">&mdash;</h2>
<hr />
<h2 id="_13">拒绝指针！</h2>
<p>注意，这里 foo 返回了一个指针！</p>
<pre><code class="language-cpp">BookInfo * foo(ISBN isbn);
</code></pre>
<p>他代表什么意思呢？</p>
<ol>
<li>指向一个内存中已经存在的书目项，由 foo 负责管理这片内存</li>
<li>返回一个 new 出来的 BookInfo 结构体，由用户负责 delete 释放内存</li>
<li>是否还有可能返回 NULL 表示找不到的情况？</li>
<li>甚至有可能返回的是一个 BookInfo 数组？指针指向数组的首个元素，数组长度的判定方式未知&hellip;</li>
</ol>
<p>太多歧义了！</p>
<pre><code class="language-cpp">BookInfo &amp; foo(ISBN isbn);
</code></pre>
<p>这就很清楚，foo 会负责管理 BookInfo 对象的生命周期，用户获得的只是一个临时的引用，并不持有所有权。</p>
<p>引用的特点：</p>
<ol>
<li>一定不会是 NULL（排除可能返回 NULL 的疑虑）</li>
<li>无法 delete 一个引用（排除可能需要用户负责释放内存的疑虑）</li>
<li>不会用于表示数组（排除可能返回数组首元素指针的疑虑）</li>
</ol>
<p>改用引用返回值，一下子思路就清晰了很多。没有那么多怀疑和猜测了，用途单一，用法明确，引用真是绝绝子。</p>
<pre><code class="language-cpp">std::unique_ptr&lt;BookInfo&gt; foo(ISBN isbn);
</code></pre>
<p>这就很清楚，foo 创建了一个新的 BookInfo，并把生命周期的所有权移交给了用户。</p>
<p>unique_ptr 的特点：</p>
<ol>
<li>独占所有权，不会与其他线程共享（排除可能多线程竞争的疑虑）</li>
<li>生命周期已经移交给用户，unique_ptr 变量离开用户的作用域后会自动释放，无需手动 delete</li>
<li>不会用于表示数组（如果要表示数组，会用 <code>unique_ptr&lt;BookInfo[]&gt;</code> 或者 <code>vector&lt;BookInfo&gt;</code>）</li>
</ol>
<p>但是 unique_ptr 有一个致命的焦虑点：他可以为 NULL！
所以当你看到一个函数返回 unique_ptr 或 shared_ptr，尽管减少了很多的疑虑，但“可能为NULL”的担忧仍然存在！
要么 foo 的作者在注释或文档里写明，“foo 不会返回 NULL”或者“foo 找不到时会返回 NULL”，打消你的疑虑。
但我们的诉求是通过类型，一眼就能看出函数所有的可能性，而不要去依赖可能骗人的注释。</p>
<p>为此微软实现了 <a href="https://github.com/microsoft/GSL">gsl</a> 库，通过类型修饰解决指针类语义含糊不清的问题：
他规定，所有套了一层 <code>gsl::not_null</code> 的原始指针或智能指针，里面都必然不会为 NULL。
在 not_null 类的构造函数中，有相应的断言检查传入的指针是否为空，如果为空会直接报错退出。</p>
<pre><code class="language-cpp">gsl::not_null&lt;FILE *&gt; p = nullptr;      // 编译期报错，因为他里面写着 not_null(nullptr_t) = delete;
gsl::not_null&lt;FILE *&gt; p = fopen(...);   // 如果 fopen 打开失败，且为 Debug 构建，运行时会触发断言错误
</code></pre>
<p>修改后的函数接口如下：</p>
<pre><code class="language-cpp">gsl::not_null&lt;std::unique_ptr&lt;BookInfo&gt;&gt; foo(ISBN isbn);
</code></pre>
<p>因为 gsl::not_null 的构造函数中会检测空指针，就向用户保证了我返回的不会是 NULL。</p>
<p>但是，有没有一种可能，你如果要转移所有权的话，我直接返回 BookInfo 本身不就行了？
除非 BookInfo 特别大，大到移动返回的开销都不得了。
直接返回类型本身，就是一定不可能为空的，且也能说明移交了对象所有权给用户。</p>
<pre><code class="language-cpp">BookInfo foo(ISBN isbn);
</code></pre>
<h2 id="_14">&mdash;</h2>
<hr />
<p>其实 GSL 里大量都是这种可有可无的玩意，比如 C++20 已经有了 std::span 和 std::byte，但是 GSL 还给你弄了个 gsl::span 和 gsl::byte，主要是为了兼容低版本编译器，如果你在新项目里能直接用上 C++20 标准的话，个人不是很推荐再去用了。</p>
<p>再比如 gsl::czstring 是 const char * 的类型别名，明确表示“0结尾字符串”，为的是和“指针返回仙人”区分开来，有必要吗？有没有一种可能，我们现在 const char * 基本上就“0结尾字符串”一种用法，而且我们大多也都是用 string 就可以了，const char * 又不安全，又语义模棱两可，何必再去为了用它专门引入个库，整个类型别名呢？</p>
<pre><code class="language-cpp">using czstring = const char *;

void foo(czstring s) {          // 发明 GSL 的人真是个天才！
    if (s == &quot;小彭老师&quot;)        // 错误！
    if (strcmp(s, &quot;小彭老师&quot;))  // 错误！
    if (!strcmp(s, &quot;小彭老师&quot;)) // 终于正确
    // 然而我完全可以直接用 string，== 的运算符重载能直接比较字符串内容
    // 还能随时随地 substr 切片，find 查找，size 常数复杂度查大小
}
</code></pre>
<p>使用各式各样功能明确的类型和容器，比如 string，vector，或引用。
而不是功能太多的指针，让用户学习你的 API 时产生误解，留下 BUG 隐患。
如果需要指针，也可以通过 const 限定，来告诉用户这个指针是只读的还是可写的。
总之，代码不会撒谎，代码层面能禁止的，能尽量限制用法的，就不要用注释和文档去协商解决。</p>
<h2 id="_15">&mdash;</h2>
<hr />
<h2 id="_16">强类型封装</h2>
<p>假设你正在学习这个 Linux 系统 API 函数：</p>
<pre><code class="language-cpp">ssize_t read(int fd, char *buf, size_t len);
// fd - 文件句柄，int 类型
</code></pre>
<p>但是你没有看他的函数参数类型和名字。你是这样调用的：</p>
<pre><code class="language-cpp">int fd = open(...);
char buf[32];
read(32, buf, fd);
char buf[32];
read(32, buf, fd);
</code></pre>
<p>你这里的 32 本意是缓冲区的大小，却不幸地和 fd 参数写错了位置，而编译器毫无报错，你浑然不知。</p>
<h2 id="_17">&mdash;</h2>
<hr />
<p>仅仅只是装模作样的用 typedef 定义个好看的类型别名，并没有任何意义！
他连你的参数名 fd 都能看不见，你觉得他会看到你的参数类型是个别名？</p>
<p>用户一样可以用一个根本不是文件句柄的臭整数来调用你，而得不到任何警告或报错：</p>
<pre><code class="language-cpp">typedef int FileHandle;
ssize_t read(FileHandle fd, char *buf, size_t len);

read(32, buf, fd); // 照样编译通过！
</code></pre>
<p>如果我们把文件句柄定义为一个结构体：</p>
<pre><code class="language-cpp">struct FileHandle {
    int handle;

    explicit FileHandle(int handle) : handle(handle) {}
};

ssize_t read(FileHandle handle, char *buf, size_t len);
</code></pre>
<p>就能在用户犯马虎的时候，给他弹出一个编译错误：</p>
<pre><code class="language-cpp">read(32, buf, fd);  // 编译报错：无法将 int 类型的 32 隐式转换为 FileHandle！
</code></pre>
<p>对于整数类型，也有的人喜欢用 C++11 的强类型枚举：</p>
<pre><code class="language-cpp">enum class FileHandle : int {};
</code></pre>
<p>这样一来，如果用户真的是想要读取“32号句柄”的文件，他就必须显式地写出完整类型才能编译通过：</p>
<pre><code class="language-cpp">read(FileHandle(32), buf, fd);  // 编译通过了
</code></pre>
<p>强迫你写上类型名，就给了你一次再思考的机会，让你突然惊醒：
哦天哪，我怎么把缓冲区大小当成句柄来传递了！
从而减少睁着眼睛还犯错的可能。</p>
<p>然后，你的 open 函数也返回 FileHandle，整个代码中就不用强制类型转换了。</p>
<pre><code class="language-cpp">FileHandle fd = open(std::filesystem::path(&quot;路径&quot;), OpenFlag::Read);
char buf[32];
read(fd, buf, 32);
</code></pre>
<h2 id="_18">&mdash;</h2>
<hr />
<h2 id="span">span “胖指针”</h2>
<h2 id="_19">&mdash;</h2>
<hr />
<p>假如你手一滑，或者老板需求改变，把 buf 缓冲区少留了两个字节：</p>
<pre><code class="language-cpp">char buf[30];
read(fd, buf, 32);
</code></pre>
<p>但你 read 的参数依然是 32，就产生了数组越界，又未定义行为了。</p>
<p>我们采用封装精神，把相关的 buf 和 size 封装成一个参数：</p>
<pre><code class="language-cpp">struct Span {
    char *data;
    size_t size;
};

ssize_t read(FileHandle fd, Span buf);
</code></pre>
<pre><code class="language-cpp">read(fd, Span{buf, 32});
</code></pre>
<p>注意：Span 不需要以引用形式传入函数！</p>
<pre><code class="language-cpp">void read(std::string &amp;buf);  // 如果是 string 类型，参数需要为引用，才能让 read 能够修改 buf 字符串
void read(Span buf);          // Span 不需要，因为 Span 并不是独占资源的类，Span 本身就是个轻量级的引用
</code></pre>
<p>vector 和 string 这种具有“拷贝构造函数”的 RAII 封装类才需要传入引用 <code>string &amp;buf</code>，如果直接传入会发生深拷贝，导致 read 内部修改的是 string 的一份拷贝，无法影响到外界原来的 string。
如果是 Span 参数就不需要 <code>Span &amp;buf</code> 引用了，Span 并不是 RAII 封装类，并不持有生命周期，并没有“拷贝构造函数”，他只是个对外部已有 vector、string、或 char[] 的引用。或者说 Span 本身就是一个对原缓冲区的引用，直接传入 read 内部一样可以修改你的缓冲区。</p>
<h2 id="_20">&mdash;</h2>
<hr />
<p>用 Span 结构体虽然看起来更明确了，但是依然不解决用户可能手滑写错缓冲区长度的问题：</p>
<pre><code class="language-cpp">char buf[30];
read(fd, Span{buf, 32});
</code></pre>
<p>为此，我们在 Span 里加入一个隐式构造函数：</p>
<pre><code class="language-cpp">struct Span {
    char *data;
    size_t size;

    template &lt;size_t N&gt;
    Span(char (&amp;buf)[N]) : data(buf), size(N) {}
};
</code></pre>
<p>这将允许 char [N] 隐式转换为 Span，且长度自动就是 N 的值。</p>
<p>此处如果写 <code>Span(char buf[N])</code>，会被 C 语言的某条沙雕规则，函数签名会等价于 <code>Span(char *buf)</code>，从而只能获取起始地址，而推导不了长度。使用数组引用作为参数 <code>Span(char (&amp;buf)[N])</code> 就不会被 C 语言自动退化成起始地址指针了。</p>
<p>用户只需要：</p>
<pre><code class="language-cpp">char buf[30];
read(fd, Span{buf});
</code></pre>
<p>等价于 <code>Span{buf, 30}</code>，数组长度自动推导，非常方便。</p>
<p>由于我们是隐式构造函数，还可以省略 Span 不写：</p>
<pre><code class="language-cpp">char buf[30];
read(fd, buf);  // 自动转换成 Span{buf, 30}
</code></pre>
<p>加入更多类型的支持：</p>
<pre><code class="language-cpp">struct Span {
    char *data;
    size_t size;

    template &lt;size_t N&gt;
    Span(char (&amp;buf)[N]) : data(buf), size(N) {}

    template &lt;size_t N&gt;
    Span(std::array&lt;char, N&gt; &amp;arr) : data(arr.data()), size(N) {}

    Span(std::vector&lt;char&gt; &amp;vec) : data(vec.data()), size(vec.size()) {}

    // 如果有需要，也可以显式写出 Span(buf, 30) 从首地址和长度构造出一个 Span 来
    explicit Span(char *data, size_t size) : data(data), size(size) {}
};
</code></pre>
<p>现在 C 数组、array、vector、都可以隐式转换为 Span 了：</p>
<pre><code class="language-cpp">char buf1[30];
Span span1 = buf1;

std::array&lt;char, 30&gt; buf2;
Span span2 = buf2;

std::vector&lt;char&gt; buf(30);
Span span3 = buf3;

const char *str = &quot;hello&quot;;
Span span4 = Span(str, strlen(str));
</code></pre>
<p>运用模板元编程，自动支持任何具有 data 和 size 成员的各种标准库容器，包括第三方的，只要他提供 data 和 size 函数。</p>
<pre><code class="language-cpp">template &lt;class Arr&gt;
concept has_data_size = requires (Arr arr) {
    { arr.data() } -&gt; std::convertible_to&lt;char *&gt;;
    { arr.size() } -&gt; std::same_as&lt;size_t&gt;;
};

struct Span {
    char *data;
    size_t size;

    template &lt;size_t N&gt;
    Span(char (&amp;buf)[N]) : data(buf), size(N) {}

    template &lt;has_data_size Arr&gt;
    Span(Arr &amp;&amp;arr) : data(arr.data()), size(arr.size()) {}
    // 满足 has_data_size 的任何类型都可以构造出 Span
    // 而标准库的 vector、string、array 容器都含有 .data() 和 .size() 成员函数
};
</code></pre>
<h2 id="_21">&mdash;</h2>
<hr />
<p>如果用户确实有修改长度的需要，可以通过 subspan 成员函数实现：</p>
<pre><code class="language-cpp">char buf[32];
read(fd, Span(buf).subspan(0, 10));  // 只读取前 10 个字节！
</code></pre>
<p>subspan 内部实现原理：</p>
<pre><code class="language-cpp">struct Span {
    char *data;
    size_t size;

    Span subspan(size_t start, size_t length = (size_t)-1) const {
        if (start &gt; size)  // 如果起始位置超出范围，则抛出异常
            throw std::out_of_range(&quot;subspan start out of range&quot;);
        auto restSize = size - start;
        if (length &gt; restSize) // 如果长度超过上限，则自动截断
            length = restSize;
        return Span(data + start, restSize + length);
    }
};
</code></pre>
<h2 id="_22">&mdash;</h2>
<hr />
<p>可以把 Span 变成模板类，支持任意类型的数组，比如 <code>Span&lt;int&gt;</code>。</p>
<pre><code class="language-cpp">template &lt;class Arr, class T&gt;
concept has_data_size = requires (Arr arr) {
    { std::data(arr) } -&gt; std::convertible_to&lt;T *&gt;;
    { std::size(arr) } -&gt; std::same_as&lt;size_t&gt;;
    // 使用 std::data 而不是 .data() 的好处：
    // std::data 对于 char (&amp;buf)[N] 这种数组类型也有重载！
    // 例如 std::size(buf) 会得到 int buf[N] 的正确长度 N
    // 而 sizeof buf 会得到 N * sizeof(int)
    // 类似于 sizeof(buf) / sizeof(buf[0]) 的效果
    // 不过如果 buf 是普通 int * 指针，会重载失败，直接报错，没有安全隐患
};

template &lt;class T&gt;
struct Span {
    T *data;
    size_t size;

    template &lt;has_data_size&lt;T&gt; Arr&gt;
    Span(Arr &amp;&amp;arr) : data(std::data(arr)), size(std::size(arr)) {}
    // 👆 同时囊括了 vector、string、array、原始数组
};

template &lt;has_data_size Arr&gt;
Span(Arr &amp;&amp;t) -&gt; Span&lt;std::remove_pointer_t&lt;decltype(std::data(std::declval&lt;Arr &amp;&amp;&gt;()))&gt;&gt;;
</code></pre>
<h2 id="_23">&mdash;</h2>
<hr />
<p><code>Span&lt;T&gt;</code> 表示可读写的数组。
对于只读的数组，用 <code>Span&lt;const T&gt;</code> 就可以。</p>
<pre><code class="language-cpp">ssize_t read(FileHandle fd, Span&lt;char&gt; buf);         // buf 可读写！
ssize_t write(FileHandle fd, Span&lt;const char&gt; buf);  // buf 只读！
</code></pre>
<h2 id="_24">&mdash;</h2>
<hr />
<p>好消息！这东西在 C++20 已经实装，那就是 std::span。
没有 C++20 开发环境的同学，也可以用 GSL 库的 gsl::span，或者 ABSL 库的 absl::Span 来体验。</p>
<p>C++17 还有专门针对字符串的区间类 std::string_view，可以从 std::string 隐式构造，用法类似，不过切片函数是 substr，还支持 find、find_first_of 等 std::string 有的字符串专属函数。</p>
<ul>
<li><code>std::span&lt;T&gt;</code> - 任意类型 T 的可读可写数组</li>
<li><code>std::span&lt;const T&gt;</code> - 任意类型 T 的只读数组</li>
<li><code>std::string_view</code> - 任意字符串</li>
</ul>
<p>在 read 函数内部，可以用 .data() 和 .size() 重新取出独立的首地址指针和缓冲区长度，用于伺候 C 语言的老函数：</p>
<pre><code class="language-cpp">ssize_t read(FileHandle fd, std::span&lt;char&gt; buf) {
    memset(buf.data(), 0, buf.size());  // 课后作业，用所学知识，优化 C 语言的 memset 函数吧！
    ...
}
</code></pre>
<p>也可以用 range-based for 循环来遍历：</p>
<pre><code class="language-cpp">ssize_t read(FileHandle fd, std::span&lt;char&gt; buf) {
    for (auto &amp; c : buf) {  // 注意这里一定要用 auto &amp; 哦！否则无法修改 buf 内容
        c = 'c';
        ...
    }
}
</code></pre>
<h2 id="_25">&mdash;</h2>
<hr />
<h2 id="_26">空值语义</h2>
<h2 id="_27">&mdash;</h2>
<hr />
<p>有的函数，比如刚才的 foo，会需要表示“可能找不到该书本”的情况。
粗糙的 API 设计者会返回一个指针，然后在文档里说“这个函数可能会返回 NULL！”</p>
<pre><code class="language-cpp">BookInfo *foo(ISBN isbn);
</code></pre>
<p>如果是这样的函数签名，是不是你很容易忘记 foo 有可能返回 NULL 表示“找不到书本”？</p>
<p>比如 <code>malloc</code> 函数在分配失败时，就会返回 NULL 并设置 errno 为 ENOMEM。
在 <code>man malloc</code> 文档中写的清清楚楚，但是谁会记得这个设定？
malloc 完随手就直接访问了（空指针解引用属未定义行为）。</p>
<p>在现代 C++17 中引入了 optional，他是个模板类型。
形如 <code>optional&lt;T&gt;</code> 的类型有两种可能的状态：</p>
<ol>
<li>为空（nullopt）</li>
<li>有值（T）</li>
</ol>
<p>如果一个函数可能成功返回 T，也可能失败，那就可以让他返回 <code>optional&lt;T&gt;</code>，用 nullopt 来表示失败。</p>
<pre><code class="language-cpp">std::optional&lt;BookInfo&gt; foo(ISBN isbn) {
    if (找到了) {
        return BookInfo(...);
    } else {
        return std::nullopt;
    }
}
</code></pre>
<p>nullopt 和指针的 nullptr 类似，但 optional 的用途更加单一，更具说明性。
如果你返回个指针人家不一定知道你的意思是可能返回 nullptr，可能还以为你是为了返回个 new 出来的数组，语义不明确。</p>
<p>调用的地方这样写：</p>
<pre><code class="language-cpp">auto book = foo(isbn);
if (book.has_value()) {  // book.has_vlaue() 为 true，则表示有值
    BookInfo realBook = book.value();
    print(&quot;找到了:&quot;, realBook);
} else {
    print(&quot;找不到这本书&quot;);
}
</code></pre>
<p>optional 类型可以在 if 条件中自动转换为 bool，判断是否有值，等价于 <code>.has_value()</code>：</p>
<pre><code class="language-cpp">auto book = foo(isbn);
if (book) {  // (bool)book 为 true，则表示有值
    BookInfo realBook = book.value();
    print(&quot;找到了:&quot;, realBook);
} else {
    print(&quot;找不到这本书&quot;);
}
</code></pre>
<p>可以通过 * 运算符读取其中的值，等价于 <code>.value()</code>）：</p>
<pre><code class="language-cpp">auto book = foo(isbn);
if (book) {
    BookInfo realBook = *book;
    print(&quot;找到了:&quot;, realBook);
} else {
    print(&quot;找不到这本书&quot;);
}
</code></pre>
<p>运用 C++17 的就地 if 语法：</p>
<pre><code class="language-cpp">if (auto book = foo(isbn); book.has_value()) {
    BookInfo realBook = *book;
    print(&quot;找到了:&quot;, realBook);
} else {
    print(&quot;找不到这本书&quot;);
}
</code></pre>
<p>由于 auto 出来的 optional 变量可以转换为 bool，分号后面的条件可以省略：</p>
<pre><code class="language-cpp">if (auto book = foo(isbn)) {
    print(&quot;找到了:&quot;, *book);
} else {
    print(&quot;找不到这本书&quot;);
}
</code></pre>
<p>optional 也支持 <code>-&gt;</code> 运算符访问成员：</p>
<pre><code class="language-cpp">if (auto book = foo(isbn)) {
    print(&quot;找到了:&quot;, book-&gt;name);
    book-&gt;readOnline();
}
</code></pre>
<p>optional 的 <code>.value()</code>，如果没有值，会抛出 <code>std::bad_optional_access</code> 异常。
用这个方法可以便捷地把“找不到书本”转换为异常抛出给上游调用者，而不用成堆的 if 判断和返回。</p>
<pre><code class="language-cpp">BookInfo book = foo(isbn).value();
</code></pre>
<p>也可以通过 <code>.value_or(默认值)</code> 指定“找不到书本”时的默认值：</p>
<pre><code class="language-cpp">BookInfo defaultBook;
BookInfo book = foo(isbn).value_or(defaultBook);
</code></pre>
<h2 id="_28">&mdash;</h2>
<hr />
<p>你接手了一个字符串转整数（可能转换失败）的函数 API：</p>
<pre><code class="language-cpp">// 文档：如果字符串解析失败，会返回 -1 并设置 errno 为 EINVAL！记得检查！若你忘记检查后果自负！
// 当指定 n 为 0 时，str 为 C 语言经典款 0 结尾字符串。
// 当指定 n 不为 0 时，str 的长度固定为 n，用于照顾参数可能不为 0 结尾字符串的情况。
int parseInt(const char *str, size_t n);
</code></pre>
<p>那么我如果检测到 -1，鬼知道是字符串里的数字就是 -1，还是因为出错才返回 -1？还要我去检查 errno，万一上一个函数出错留下的 EINVAL 呢？万一我忘记检查呢？</p>
<p>运用本期课程所学知识优化：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; parseInt(std::string_view str);
</code></pre>
<p>是不是功能，返回值，可能存在的错误情况，一目了然了？根本不需要什么难懂的注释，文档。</p>
<p>如果调用者想假定字符串解析不会出错：</p>
<pre><code class="language-cpp">parseInt(&quot;233&quot;).value();
</code></pre>
<p>如果调用者想当出错时默认返回 0：</p>
<pre><code class="language-cpp">parseInt(&quot;233&quot;).value_or(0);
</code></pre>
<p>parseInt 内部实现可能如下：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; parseInt(std::string_view sv) {
    int value;
    auto result = std::from_chars(str.data(), str.data() + str.size(), std::ref(value));
    if (result.ec == std::errc())
        return value;
    else
        return std::nullopt;
}
</code></pre>
<h2 id="_29">&mdash;</h2>
<hr />
<p>调用者的参数不论是 string 还是 C 语言风格的 const char *，都能隐式转换为通用的 string_view。</p>
<pre><code class="language-cpp">parseInt(&quot;-1&quot;);

string s;
cin &gt;&gt; s;
parseInt(s);

char perfGeek[2] = {'-', '1'};
parseInt(std::string_view{perfGeek, 2});
</code></pre>
<p>笑点解析：上面的代码有一处错误，你能发觉吗？</p>
<h2 id="_30">&mdash;</h2>
<hr />
<pre><code class="language-cpp">cin &gt;&gt; s;
</code></pre>
<p><code>cin &gt;&gt;</code> 可能会失败！没 想 到 吧</p>
<p>要是 int 等 POD 类型，如果不检测，会出现未初始化的 int 值，产生未定义行为！</p>
<pre><code class="language-cpp">int i;
cin &gt;&gt; i;
return i;  // 如果用户的输入值不是合法的整数，这里会产生典中典之内存中的随机数烫烫烫烤馄饨！
</code></pre>
<p>官方推荐的做法是每次都要检测是否失败！</p>
<pre><code class="language-cpp">int i;
if (!(cin &gt;&gt; i)) {
    throw std::runtime_error(&quot;读入 int 变量失败！&quot;);
}
return i;
</code></pre>
<p>但是谁记得住？所以从一开始就不要设计这种糟糕的 API。
特别是 <code>cin &gt;&gt;</code> 这种通过引用返回 i，却要人记得判断返回 bool 表示成败，忘记判断还会给你留着未初始化的煞笔设计。
如果让我来设计 cin 的话：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; readInt();

int i = cin.readInt().value();
</code></pre>
<p>这样如果用户要读取到值的话，必然要 <code>.value()</code>，从而如果 readInt 失败返回的是 nullopt，就必然抛出异常，避免了用户忘记判断错误的可能。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 在小彭老师自主研发的一款 co_async 协程库中，就重新设计了自己的异步字符流类，例如其中 getline 函数会返回 <code>std::expected&lt;std::string, std::system_error&gt;</code>。</p>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 在<a href="../error_code/">错误处理专题</a>中有进一步的详解。</p>
</blockquote>
<h2 id="_31">&mdash;</h2>
<hr />
<pre><code class="language-cpp">BookInfo * foo(ISBN isbn);
</code></pre>
<p>这是个返回智能指针的函数，单从函数声明来看，你能否知道他有没有可能返回空指针？不确定。</p>
<pre><code class="language-cpp">std::optional&lt;BookInfo *&gt; foo(ISBN isbn);
</code></pre>
<p>现在是不是很明确了，如果返回的是 nullopt，则表示空，然后 optional 内部的 BookInfo *，大概是不会为 NULL 的？</p>
<pre><code class="language-cpp">std::optional&lt;gsl::not_null&lt;BookInfo *&gt;&gt; foo(ISBN isbn);
</code></pre>
<p>这下更明确了，如果返回的是 nullopt，则表示空，然后 optional 内部的 BookInfo * 因为套了一层 gsl::not_null，必定不能为 NULL（否则会被 gsl::not_null 的断言检测到），函数的作者是绝对不会故意返回个 NULL 的。
如果失败，会返回 nullopt，而不是意义不明还容易忘记的空指针。</p>
<h2 id="_32">&mdash;</h2>
<p>还是不建议直接用原始指针，建议用智能指针或引用。</p>
<pre><code class="language-cpp">std::optional&lt;gsl::not_null&lt;std::unique_ptr&lt;BookInfo&gt;&gt;&gt; foo(ISBN isbn);
</code></pre>
<p>这个函数可能返回 nullopt 表示失败，成功则返回一个享有所有权的独占指针，指向单个对象。</p>
<p>小彭老师，我 <code>optional&lt;BookInfo &amp;&gt;</code> 出错了怎么办？</p>
<pre><code class="language-cpp">std::optional&lt;std::reference_wrapper&lt;BookInfo&gt;&gt; foo(ISBN isbn);
</code></pre>
<p>这个函数可能返回 nullopt 表示失败，成功则返回一个不享有所有权的引用，指向单个对象。</p>
<p>reference_wrapper 是对引用的包装，可隐式转换为引用：</p>
<pre><code class="language-cpp">int i;
std::reference_wrapper&lt;int&gt; ref = i;
int &amp;r = ref; // r 指向 i
</code></pre>
<p>使引用可以存到各种容器里：
且遇到 auto 不会自动退化（decay）：</p>
<pre><code class="language-cpp">int i;
std::reference_wrapper&lt;int&gt; ref = i;
auto ref2 = ref;  // ref2 推导为 std::reference_wrapper&lt;int&gt;
int &amp;r = i;
auto r2 = r;  // r2 推导为 int
</code></pre>
<p>且永远不会为 NULL：</p>
<pre><code class="language-cpp">std::reference_wrapper&lt;int&gt; ref; // 编译错误：引用必须初始化，reference_wrapper 当然也必须初始化
</code></pre>
<p>也可以通过 <code>*</code> 或 <code>-&gt;</code> 解引用：</p>
<pre><code class="language-cpp">BookInfo book;
std::reference_wrapper&lt;int&gt; refBook = book;
refBook-&gt;readOnline();
BookInfo deepCopyBook = *refBook;
</code></pre>
<h2 id="_33">&mdash;</h2>
<hr />
<p>注意 <code>.value()</code> 和 <code>*</code> 是有区别的，<code>*</code> 不会检测是否为空，不会抛出异常，但更高效。</p>
<pre><code class="language-cpp">o.value(); // 如果 o 里没有值，会抛出异常
*o;  // 如果 o 里没有值，会产生未定义行为！
o-&gt;readOnline();  // 如果 o 里没有值，会产生未定义行为！
</code></pre>
<p>因此一般会在判断了 optional 不为空以后才会去访问 <code>*</code> 和 <code>-&gt;</code>。而 <code>.value()</code> 可以直接访问。</p>
<pre><code class="language-cpp">print(foo().value()); // .value() 可以直接使用，不用判断
if (auto o = foo()) {
    // 判断过确认不为空了，才能访问 *o
    // 在已经判断过不为空的 if 分支中，用 * 比 .value() 更高效
    print(*o);
}
</code></pre>
<p>共享所有权
* n - shared_ptr<T[]>
* 1 - shared_ptr<T></p>
<p>独占所有权
* n - vector<T>, unique_ptr<T[]>
* 1 - unique_ptr<T></p>
<p>没所有权
* n - span<T>
* 1 - reference_wrapper<T>, T &amp;</p>
<h2 id="_34">&mdash;</h2>
<hr />
<p>接下来介绍 optional 的一些进阶用法。</p>
<pre><code class="language-cpp">std::optional&lt;BookInfo&gt; o = BookInfo(1, 2, 3);  // 初始化为 BookInfo 值
std::optional&lt;BookInfo&gt; o;  // 不写时默认初始化为空，等价于 o = std::nullopt
o.emplace(1, 2, 3);  // 就地构造，等价于 o = BookInfo(1, 2, 3); 但不需要移动 BookInfo 了
o.reset();  // 就地销毁，等价于 o = std::nullopt;
</code></pre>
<h2 id="_35">&mdash;</h2>
<hr />
<p>当不为空时将其中的 int 值加 1，否则保持为空不变，怎么写？</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; o = cin.readInt();
if (o) {
    o = *o + 1;
}
</code></pre>
<p>运用 C++23 引入的新函数 transform：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; o = cin.readInt();
o = o.transform([] (int n) { return n + 1; });
</code></pre>
<h2 id="_36">&mdash;</h2>
<hr />
<p>当不为空时将其中的 string 值解析为 int，否则保持为空不变。且解析函数可能失败，失败则也要将 optional 置为空，怎么写？</p>
<pre><code class="language-cpp">std::optional&lt;string&gt; o = cin.readLine();
std::optional&lt;int&gt; o2;
if (o) {
    o2 = parseInt(*o);
}

std::optional&lt;int&gt; parseInt(std::string_view sv) { ... }
</code></pre>
<p>运用 C++23 引入的新函数 and_then：</p>
<pre><code class="language-cpp">auto o = cin.readLine().and_then(parseInt);
</code></pre>
<h2 id="_37">&mdash;</h2>
<hr />
<p>当找不到指定书籍时，返回一本默认书籍作为替代：</p>
<pre><code class="language-cpp">auto o = findBook(isbn).value_or(getDefaultBook());
</code></pre>
<p>缺点：由于 value_or 的参数会提前被求值，即使 findBook 成功找到了书籍，也会执行 getDefaultBook 函数，然后将其作为死亡右值丢弃。如果创建默认书籍的过程很慢，那么就非常低效。</p>
<p>为此，C++23 引入了 or_else 函数。
只有 findBook 找不到时才会执行 lambda 中的函数体：</p>
<pre><code class="language-cpp">auto o = findBook(isbn).or_else([] -&gt; std::optional&lt;BookInfo&gt; {
    cout &lt;&lt; &quot;findBook 出错了，现在开始创建默认书籍，非常慢\n&quot;;
    return getDefaultBook();
});
</code></pre>
<h2 id="_38">&mdash;</h2>
<hr />
<p>此类函数都可以反复嵌套：</p>
<pre><code class="language-cpp">int i = cin.readLine()
    .or_else(getDefaultLine)
    .and_then(parseInt)
    .transform([] (auto i) { return i * 2; })
    .value_or(0);
</code></pre>
<p>加入函数式神教吧，函门！</p>
<h2 id="_39">&mdash;</h2>
<hr />
<h2 id="stl">点名批评的 STL 设计</h2>
<h2 id="_40">&mdash;</h2>
<hr />
<p>例如 std::stack 的设计就非常失败：</p>
<pre><code class="language-cpp">if (!stack.empty()) {
    auto val = std::move(stack.top());
    stack.pop();
}
</code></pre>
<p>我们必须判断 stack 不为空，才能弹出栈顶元素。对着一个空的栈 pop 是未定义行为。
而 pop() 又是一个返回 void 的函数，他只是删除栈顶元素，并不会返回元素。
我们必须先调用 top() 把栈顶取出来，然后才能 pop！</p>
<p>明明是同一个操作，却要拆成三个函数来完成，很烂。如果你不慎把判断条件写反：</p>
<pre><code class="language-cpp">if (stack.empty()) {
    auto val = std::move(stack.top());
    stack.pop();
}
</code></pre>
<p>就一个 Segmentation Fault 蹦你脸上，你找半天都找不到自己哪错了！</p>
<p>小彭老师重新设计，整合成一个函数：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; pop();
</code></pre>
<p>语义明确，用起来也方便，用户不容易犯错。</p>
<pre><code class="language-cpp">if (auto val = stack.pop()) {
    ...
}
</code></pre>
<p>把多个本就属于同一件事的函数，整合成一个，避免用户中间出纰漏。
从参数和返回值的类型上，限定自由度，减轻用户思考负担。</p>
<h2 id="_41">&mdash;</h2>
<hr />
<p>众所周知，vector 有两个函数用于访问指定位置的元素。</p>
<pre><code class="language-cpp">int &amp;operator[](size_t index);
int &amp;at(size_t index);

vec[3];  // 如果 vec 的大小不足 3，会发生数组越界！这是未定义行为
vec.at(3);  // 如果 vec 的大小不足 3，会抛出 out_of_range 异常
</code></pre>
<p>用户通常会根据自己的需要，如果他们非常自信自己的索引不会越界，可以用高效的 []，不做检测。
如果不确定，可以用更安全的 at()，一旦越界自动抛出异常，方便调试。</p>
<p>我们可以重新设计一个 .get() 函数：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; get(size_t index);
</code></pre>
<p>当检测到数组越界时，返回 nullopt。</p>
<pre><code class="language-cpp">*vec.get(3);             // 如果用户追求性能，可以把数组越界转化为未定义行为，从而让编译器自动优化掉越界的路径
vec.get(3).value();      // 如果用户追求安全，可以把数组越界转化为一个异常
vec.get(3).value_or(0);  // 如果用户想要在越界时获得默认值 0
</code></pre>
<p>这样就只需要一个函数，不论用户想要的是什么，都只需要这一个统一的 get() 函数。</p>
<h2 id="_42">&mdash;</h2>
<hr />
<p>小彭老师，你这个只能 get，要如何 set 呀？</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; get(size_t index);
bool set(size_t index, int value);  // 如果越界，返回 false
</code></pre>
<ul>
<li>缺点1：返回 bool 无法运用 optional 的小技巧：通过 value() 转化为异常，且用户容易忘记检查返回值。</li>
<li>缺点2：两个参数，一个是 size_t 一个是 int，还是很容易顺序搞混。</li>
</ul>
<pre><code class="language-cpp">std::optional&lt;std::reference_wrapper&lt;int&gt;&gt; get(size_t index);

auto x = **vec.get(3);         // 性能读
auto x = *vec.get(3).value();  // 安全读
*vec.get(3) = 42;              // 性能写
vec.get(3).value() = 42;       // 安全写
</code></pre>
<h2 id="_43">&mdash;</h2>
<hr />
<h2 id="stl_1">点名表扬的 STL 部分</h2>
<h2 id="_44">&mdash;</h2>
<hr />
<pre><code class="language-cpp">void Sleep(int delay);
</code></pre>
<p>谁知道这个 delay 的单位是什么？秒？毫秒？</p>
<pre><code class="language-cpp">void Sleep(int ms);
</code></pre>
<p>好吧，是毫秒。可是除非看一眼函数定义或文档，谁想得到这是个毫秒？</p>
<p>一个用户想要睡 3 秒，他写道：</p>
<pre><code class="language-cpp">Sleep(3);
</code></pre>
<p>编译器没有任何报错，一运行只睡了 3 毫秒。
用户大发雷霆以为你的 Sleep 函数有 BUG，我让他睡 3 秒怎么好像根本没睡啊。</p>
<h2 id="_45">&mdash;</h2>
<hr />
<pre><code class="language-cpp">void SleepMilliSeconds(int ms);
</code></pre>
<p>改个函数名可以解决一部分问题，当用户调用时，他需要手动打出 <code>MilliSeconds</code>，从而强迫他清醒一下，自己给的 3 到底是不是自己想要的。</p>
<h2 id="_46">&mdash;</h2>
<hr />
<pre><code class="language-cpp">struct MilliSeconds {
    int count;

    explicit MilliSeconds(int count) : count(count) {}
};

void Sleep(MilliSeconds delay);
</code></pre>
<p>现在，如果用户写出</p>
<pre><code class="language-cpp">Sleep(3);
</code></pre>
<p>编译器会报错。
他必须明确写出</p>
<pre><code class="language-cpp">Sleep(MilliSeconds(3));
</code></pre>
<p>才能通过编译。</p>
<h2 id="_47">&mdash;</h2>
<hr />
<p>标准库的 chrono 模块就大量运用了这种强类型封装：</p>
<pre><code class="language-cpp">this_thread::sleep_for(chrono::seconds(3));
</code></pre>
<p>如果你 <code>using namespace std::literials;</code> 还可以这样快捷地创建字面量：</p>
<pre><code class="language-cpp">this_thread::sleep_for(3ms);  // 3 毫秒
this_thread::sleep_for(3s);  // 3 秒
this_thread::sleep_for(3m);  // 3 分钟
this_thread::sleep_for(3h);  // 3 小时
</code></pre>
<p>且支持运算符重载，不同单位之间还可以互相转换：</p>
<pre><code class="language-cpp">this_thread::sleep_for(1s + 200ms);
chrono::minutes three_minutes = 180s;
</code></pre>
<h2 id="_48">&mdash;</h2>
<hr />
<p>chrono 是一个优秀的类型封装案例，把 time_t 类型封装成了强类型的 duration 和 time_point。</p>
<p>时间点（time_point）表示某个具体的时间，例如 2024 年 5 月 16 日 18:06:28。
时间段（duration）表示一段时间的长度，例如 1 天，2 小时，3 分钟，4 秒。</p>
<p>时间段很容易表示，只需要指定一个单位，比如秒，然后用一个数字就可以表示多少秒的时间段。
但是时间点就很难表示了，例如你无法</p>
<p>Unix 时间戳用一个数字来表示时间点，数字的含义是从当前时间到 1970 年 1 月 1 日 00:00:00 的秒数。
例如写作这篇文章的时间戳是 1715853968 (2024/5/16 18:06)。
C 语言用一个 <code>time_t</code>，实际上是 <code>long</code> 的类型别名来表示时间戳，但它有一个严重的问题：
它可以被当成时间点，也可以被当成时间段，这就造成了巨大的混乱。</p>
<pre><code class="language-cpp">time_t t0 = time(NULL);  // 时间点
...
time_t t1 = time(NULL);  // 时间点
time_t dt = t1 - t0;     // 时间段
</code></pre>
<ul>
<li>痛点：如果这里的负号写错，写成 <code>t1 + t0</code>，编译器不会报错，你可能根本没发现，浪费大量时间调试最后只发现一个低级错误。</li>
<li>模糊：时间点（t0、t1）和时间段（dt）都是 time_t，初次阅读代码很容易分不清哪个是时间点，哪个是时间段。</li>
</ul>
<p>如果不慎把“时间点”的 time_t 传入到本应只支持“时间段”的 sleep 函数，会出现“睡美人”的奇观：</p>
<pre><code class="language-cpp">time_t t = time(NULL);  // 返回 1715853968 表示当前时间点
sleep(t);               // 不小心把时间点当成时间段来用了！
</code></pre>
<p>这个程序会睡 1715853968 秒后才醒，即 54 年后！</p>
<pre><code class="language-cpp">chrono::system_clock::time_point last = chrono::system_clock::now();
...
chrono::system_clock::time_point now = chrono::system_clock::now();
chrono::system_clock::duration dt = now - last;
cout &lt;&lt; &quot;用了 &quot; &lt;&lt; duration_cast&lt;chrono::seconds&gt;(dt).count() &lt;&lt; &quot; 秒\n&quot;;
</code></pre>
<ul>
<li>一看就知道哪个是时间点，哪个是时间段</li>
<li>用错了编译器会报错</li>
<li>
<p>单位转换不会混淆</p>
</li>
<li>
<p>时间点 + 时间点 = 编译出错！因为时间点之间不允许相加，2024 + 2024，你是想加到 4048 年去吗？</p>
</li>
<li>时间点 - 时间点 = 时间段</li>
<li>时间点 + 时间段 = 时间点</li>
<li>时间点 - 时间段 = 时间点</li>
<li>时间段 + 时间段 = 时间段</li>
<li>时间段 - 时间段 = 时间段</li>
<li>时间段 × 常数 = 时间段</li>
<li>时间段 / 常数 = 时间段</li>
</ul>
<p>这就是本期课程的主题，通过强大的类型系统，对可能的用法加以严格的限制，最大限度阻止用户不经意间写出错误的代码。</p>
<h2 id="_49">&mdash;</h2>
<hr />
<h2 id="_50">枚举类型</h2>
<h2 id="_51">&mdash;</h2>
<hr />
<p>你的老板要求一个设定客户性别的函数：</p>
<pre><code class="language-cpp">void foo(int sex);
</code></pre>
<p>老板口头和员工约定说，0表示女，1表示男，2表示自定义。</p>
<p>这谁记得住？设想你是一个新来的员工，看到下面的代码：</p>
<pre><code class="language-cpp">foo(1);
</code></pre>
<p>你能猜到这个 1 是什么意思吗？</p>
<p>解决方法是使用枚举类型，给每个数值一个唯一的名字：</p>
<pre><code class="language-cpp">enum Sex {
    Female = 0,
    Male = 1,
    Custom = 2,
};

void foo(Sex sex);
</code></pre>
<p>再假设你是一个新来的员工，看到：</p>
<pre><code class="language-cpp">foo(Male);
</code></pre>
<p>是不是就一目了然啦？</p>
<h2 id="_52">&mdash;</h2>
<hr />
<p>枚举的值也可以不用写，让编译器自动按 0、1、2 的顺序分配值：</p>
<pre><code class="language-cpp">enum Sex {
    Female,   // 0
    Male,     // 1
    Custom,   // 2
};
</code></pre>
<p>可以指定从 1 开始计数：</p>
<pre><code class="language-cpp">enum Sex {
    Female = 1,
    Male,      // 2
    Custom,    // 3
};
</code></pre>
<h2 id="_53">&mdash;</h2>
<hr />
<p>但枚举类型还是可以骗人，再假设你是新来的，看到：</p>
<pre><code class="language-cpp">foo(Male, 24);
</code></pre>
<p>是不是想当然的感觉这个代码没问题？</p>
<p>但当你看到 foo 准确的函数定义时，傻眼了：</p>
<pre><code class="language-cpp">void foo(int age, Sex sex);
</code></pre>
<p>相当于注册了一个 1 岁，性别是 24 的伪人。且程序员很容易看不出问题，编译器也不报错。</p>
<p>为此，C++11 引入了<strong>强类型枚举</strong>：</p>
<pre><code class="language-cpp">enum class Sex {
    Female = 0,
    Male = 1,
    Custom = 2,
};
</code></pre>
<p>现在，如果你再不小心把 sex 传入 age 的话，编译器会报错！因为强类型枚举不允许与 int 隐式转换。</p>
<p>而且强类型枚举会需要显式写出 <code>Sex::</code> 类型前缀，当你有很多枚举类型时不容易混淆：</p>
<pre><code class="language-cpp">foo(24, Sex::Male);
</code></pre>
<p>如果你的 Sex 范围很小，只需要 uint8_t 的内存就够，可以用这个语法指定枚举的“后台类型”：</p>
<pre><code class="language-cpp">enum class Sex : uint8_t {
    Female = 0,
    Male = 1,
    Custom = 2,
};

static_assert(sizeof(Sex) == 1);
</code></pre>
<h2 id="_54">&mdash;</h2>
<hr />
<p>假如你的所有 age 都是 int 类型的，但是现在，老板突然心血来潮：</p>
<p>说为了“优化存储空间”，想要把所有 age 改成 uint8_t 类型的！</p>
<p>为了预防未来可能需要改变类型的需求，也是为了可读性，我们可以使用类型别名：</p>
<pre><code class="language-cpp">using Age = int;

void foo(Age age, Sex sex);
</code></pre>
<p>这样当老板需要改变底层类型时，只需要改动一行：</p>
<pre><code class="language-cpp">using Age = uint8_t;
</code></pre>
<p>就能自动让所有代码都使用 uint8_t 作为 age 了。</p>
<h2 id="_55">&mdash;</h2>
<hr />
<p>但是类型别名毕竟只是别名，并没有强制保障：</p>
<pre><code class="language-cpp">using Age = int;
using Phone = int;

foo(Age age, Phone phone);

void bar() {
    Age age = 42;
    Phone phone = 12345;

    foo(phone, age); // 不小心写反了！而编译器不会提醒你！
}
</code></pre>
<p>因为 Age 和 Phone 只是类型别名，实际上还是同样的 int 类型&hellip;所以编译器甚至不会有任何警告。</p>
<p>有一种很极端的做法是把 Age 和 Phone 也做成枚举，但没有定义任何值：</p>
<pre><code class="language-cpp">enum class Age : int {};
enum class Phone : int {};
</code></pre>
<p>这样用到的时候就只能通过强制转换的语法：</p>
<pre><code class="language-cpp">foo(Age(42), Phone(12345));
</code></pre>
<p>并且如果写错顺序，尝试把 Phone 传入 Age 类型的参数，编译器会立即报错，阻止你埋下 BUG 隐患。</p>
<h2 id="_56">&mdash;</h2>
<hr />
<p>小彭老师，我用了你的方法以后，不能做加法了怎么办？</p>
<pre><code class="language-cpp">Age(42) + Age(1) // 编译器错误！
</code></pre>
<p>这是因为 Age 是强类型枚举，不能隐式转换为 int 后做加法。</p>
<p>可以定义一个运算符重载：</p>
<pre><code class="language-cpp">enum class Age : int {};

inline Age operator+(Age a, Age b) {
    return Age((int)a + (int)b);
}
</code></pre>
<p>或者运用模板元编程，直接让加法运算符对于所有枚举类型都默认生效：</p>
<pre><code class="language-cpp">template &lt;class T&gt; requires std::is_enum_v&lt;T&gt;
T operator+(T a, T b) {
    using U = std::underlying_type_t&lt;T&gt;;
    return T((U)a + (U)b);
}
</code></pre>
<p>有时这反而是个优点，比如你可以只定义加法运算符，就可以让 Age 不支持乘法，需要手动转换后才能乘，避免无意中犯错的可能。</p>
<h2 id="_57">&mdash;</h2>
<hr />
<p>小彭老师，我用了你推荐的<strong>强类型枚举</strong>，不支持我最爱的或运算 <code>|</code> 了怎么办？</p>
<pre><code class="language-cpp">enum class OpenFlag {
    Create = 1,
    Read = 2,
    Write = 4,
    Truncate = 8,
    Append = 16,
    Binary = 32,
};

inline OpenFlag operator|(OpenFlag a, OpenFlag b) {
    return OpenFlag((int)a | (int)b);
}

inline OpenFlag operator&amp;(OpenFlag a, OpenFlag b) {
    return OpenFlag((int)a &amp; (int)b);
}

inline OpenFlag operator~(OpenFlag a) {
    return OpenFlag(~(int)a);
}
</code></pre>
<h2 id="_58">&mdash;</h2>
<hr />
<h2 id="_59">其他类型套皮</h2>
<h2 id="_60">&mdash;</h2>
<hr />
<p>小彭老师，我很喜欢强类型枚举这一套，但我的参数不是整数类型，而是 double、string 等类型，怎么办？</p>
<pre><code class="language-cpp">struct Name {
private:
    std::string value;

public:
    explicit operator std::string() const {
        return value;
    }

    explicit Name(std::string value) : value(value) {}
};
</code></pre>
<p>这里我们写 explicit 就可以阻止隐式类型转换，起到与强类型枚举类似的作用。</p>
<p>或者运用模板元编程：</p>
<pre><code class="language-cpp">// 此处使用 CRTP 模式是为了让 Typed 每次都实例化出不同的基类，阻止 object-slicing
template &lt;class CRTP, class T&gt;
struct Typed {
protected:
    T value;

public:
    explicit operator T() const {
        return value;
    }

    explicit Typed(T value) : value(value) {}
};
</code></pre>
<pre><code class="language-cpp">struct Name : Typed&lt;Name, std::string&gt; {};

struct Meter : Typed&lt;Meter, double&gt; {
    using Typed&lt;Kilometer, double&gt;::Typed;
};

struct Kilometer : Typed&lt;Kilometer, double&gt; {
    using Typed&lt;Kilometer, double&gt;::Typed;
    operator Meter() const {
        // 允许隐式转换为米
        return Meter(value * 1000);
    }
};

Meter m = Kilometer(1);
// m = Meter(1000);
foo(m);
</code></pre>
<h2 id="_61">&mdash;</h2>
<hr />
<h2 id="raii">RAII 封装</h2>
<h2 id="_62">&mdash;</h2>
<hr />
<p>小彭老师，我的函数就是涉及“开始”和“结束”两个操作，用户的操作需要穿插在其中间，怎么整合呢？</p>
<pre><code class="language-cpp">mysql_connection *conn = mysql_connect(&quot;127.0.0.1&quot;);
mysql_execute(conn, &quot;drop database paolu&quot;);
mysql_close(conn); // 用户可能忘记关闭连接！破坏库设计者想要的用法
</code></pre>
<p>这种大多是获取资源，和释放资源两个操作。</p>
<p>因为 mysql 是个 C 语言的库，他没有 RAII 封装，让他手动封装有的同学又嫌弃麻烦。</p>
<p>这时我会告诉他们一个 shared_ptr 小妙招：构造函数的第二个参数可以指定释放函数，代替默认的 delete</p>
<pre><code class="language-cpp">auto conn = std::shared_ptr&lt;mysql_connection&gt;(mysql_connect(&quot;127.0.0.1&quot;), mysql_close);
mysql_execute(conn.get(), &quot;drop database paolu&quot;);
// conn 离开作用域时，会自动调用 mysql_close，杜绝了一个出错的可能
</code></pre>
<h2 id="_63">&mdash;</h2>
<hr />
<p>以封装 C 语言的 FILE 为例。</p>
<pre><code class="language-cpp">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *file);
</code></pre>
<p>这个 size 和 nmemb 真是太糟糕了，本意是为了支持不同元素类型的数组。
size 是元素本身大小，nmemb 是元素数量。实际读取的字节数是 size * nmemb。
我就经常把 ptr 和 file 顺序写反，这个莫名其妙的参数顺序太反直觉了！</p>
<p>小彭老师运用现代 C++ 思想封装之：</p>
<pre><code class="language-cpp">using FileHandle = std::shared_ptr&lt;FILE&gt;;

enum class OpenMode {
    Read,
    Write,
    Append,
};

inline OpenMode operator|(OpenMode a, OpenMode b) {
    return OpenMode((int)a | (int)b);
}

auto modeLut = std::map&lt;OpenMode, std::string&gt;{
    {OpenMode::Read, &quot;r&quot;},
    {OpenMode::Write, &quot;w&quot;},
    {OpenMode::Append, &quot;a&quot;},
    {OpenMode::Read | OpenMode::Write, &quot;w+&quot;},
    {OpenMode::Read | OpenMode::Append, &quot;a+&quot;},
};

FileHandle file_open(std::filesystem::path path, OpenMode mode) {
#ifdef _WIN32
    return std::shared_ptr&lt;FILE&gt;(_wfopen(path.wstring().c_str(), modeLut.at(mode)), fclose);
#else
    return std::shared_ptr&lt;FILE&gt;(fopen(path.string().c_str(), modeLut.at(mode)), fclose);
#endif
}

struct [[nodiscard]] FileResult {
    std::optional&lt;size_t&gt; numElements;
    std::errc errorCode;  // std::errc 是个强类型枚举，用于取代 C 语言 errno 的 int 类型
    bool isEndOfFile;
};

template &lt;class T&gt;
FileResult file_read(FileHandle file, std::span&lt;T&gt; elements) {
    auto n = fread(elements.data(), sizeof(T), elements.size(), file.get());
    return {
        .numElements = n == 0 ? n : std::nullopt,
        .errorCode = std::errc(ferror(file.get())),
        .isEndOfFile = (bool)feof(file.get()),
    };
}
</code></pre>
<p>是不是接口更加简单易懂，没有犯错的机会了？</p>
<pre><code class="language-cpp">FileHandle file = file_open(&quot;hello.txt&quot;, OpenMode::Read);
int arr[32];
file_read(file, arr).numElements.value();  // 如果没有读到东西，这里会抛出异常
// 退出作用域时，shared_ptr 会自动为你关闭文件，无需再提供 file_close 函数
</code></pre>
<h2 id="_64">&mdash;</h2>
<hr />
<h2 id="mutex">Mutex 封装</h2>
<h2 id="_65">&mdash;</h2>
<hr />
<h2 id="_66">&mdash;</h2>
<hr />
<h2 id="cuda">彩蛋：CUDA 封装实战</h2>
<h2 id="_67">&mdash;</h2>
<hr />
<h2 id="_68">变量名与作用域限制</h2>
<h2 id="_69">&mdash;</h2>
<hr />
<h2 id="_70">&mdash;</h2>
<hr />
<h2 id="getset">你真的需要 get/set 吗？</h2>
<h2 id="_71">&mdash;</h2>
<hr />
<p>TODO</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>小彭老师倾 ♥ 制作</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../js/print-site.js"></script>
        <script src="../extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
