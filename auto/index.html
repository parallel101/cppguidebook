<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="小彭老师">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>auto 神教 - ✝️小彭大典✝️</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/print-site-enum-headings1.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings2.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings3.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings4.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings5.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings6.css" rel="stylesheet">
        <link href="../css/print-site.css" rel="stylesheet">
        <link href="../css/print-site-mkdocs.css" rel="stylesheet">
        <link href="../extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/diff.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/java.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/llvm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/nasm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/txt.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">✝️小彭大典✝️</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">章节列表</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href=".." class="dropdown-item">前言</a>
</li>
                                    
<li>
    <a href="../hello_world/" class="dropdown-item">你好，世界</a>
</li>
                                    
<li>
    <a href="../platform/" class="dropdown-item">开发环境与平台选择</a>
</li>
                                    
<li>
    <a href="../variable_types/" class="dropdown-item">变量与类型 (未完工)</a>
</li>
                                    
<li>
    <a href="../functions/" class="dropdown-item">认识函数 (未完工)</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">auto 神教</a>
</li>
                                    
<li>
    <a href="../symbols/" class="dropdown-item">重新认识声明与定义（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_tricks/" class="dropdown-item">应知应会 C++ 小技巧</a>
</li>
                                    
<li>
    <a href="../lambda/" class="dropdown-item">小彭老师带你学函数式编程</a>
</li>
                                    
<li>
    <a href="../type_rich_api/" class="dropdown-item">现代化的 API 设计指南</a>
</li>
                                    
<li>
    <a href="../no_more_new/" class="dropdown-item">现代 C++ 从拒绝 new 开始</a>
</li>
                                    
<li>
    <a href="../stl_map/" class="dropdown-item">STL 精讲：std::map 和他的朋友们</a>
</li>
                                    
<li>
    <a href="../design_overview/" class="dropdown-item">设计模式总览 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_virtual/" class="dropdown-item">让虚函数再次伟大！</a>
</li>
                                    
<li>
    <a href="../design_gamedev/" class="dropdown-item">游戏开发中常用的设计模式</a>
</li>
                                    
<li>
    <a href="../design_functor/" class="dropdown-item">函数式设计模式</a>
</li>
                                    
<li>
    <a href="../design_variant/" class="dropdown-item">静态多态与面向数据编程 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_erasure/" class="dropdown-item">类型擦除神教及其实现 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_concept/" class="dropdown-item">鸭子类型与 C++20 concept (未完工)</a>
</li>
                                    
<li>
    <a href="../error_code/" class="dropdown-item">现代 C++ 错误处理知多少（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_lifetime/" class="dropdown-item">深入理解析构函数与生命周期</a>
</li>
                                    
<li>
    <a href="../cpp_memory/" class="dropdown-item">真正的 C++ 内存模型！ (未完工)</a>
</li>
                                    
<li>
    <a href="../unicode/" class="dropdown-item">字符编码那些事</a>
</li>
                                    
<li>
    <a href="../threading/" class="dropdown-item">C++ 多线程编程（未完工）</a>
</li>
                                    
<li>
    <a href="../test_and_safe/" class="dropdown-item">测试与安全话题（未完工）</a>
</li>
                                    
<li>
    <a href="../undef/" class="dropdown-item">未定义行为完整列表</a>
</li>
                                    
<li>
    <a href="../llvm_intro/" class="dropdown-item">小彭老师带你学 LLVM</a>
</li>
                                    
<li>
    <a href="../cuda_intro/" class="dropdown-item">现代 C++ 的 CUDA 编程</a>
</li>
                                    
<li>
    <a href="../cmake_tutor/" class="dropdown-item">学现代 C++ 从现代 CMake 学起（未完工）</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">关于</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about/" class="dropdown-item">关于小彭老师</a>
</li>
                                    
<li>
    <a href="../donate/" class="dropdown-item">赞助名单</a>
</li>
                                    
<li>
    <a href="../interview/" class="dropdown-item">小彭老师面试经验</a>
</li>
                                    
<li>
    <a href="../recommend/" class="dropdown-item">参考资料与项目</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook" class="nav-link">GitHub</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://space.bilibili.com/263032155" class="nav-link">Bilibili</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../functions/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../symbols/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook/edit/master/docs/auto.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#auto" class="nav-link">auto 神教</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#auto_1" class="nav-link">auto 关键字的前世今生</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#auto_2" class="nav-link">变量声明为 auto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#auto_3" class="nav-link">返回类型 auto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#for-auto" class="nav-link">范围 for 循环中的 auto &amp;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#auto_4" class="nav-link">参数类型 auto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="auto"><code>auto</code> 神教</h1>
<h2 id="auto_1"><code>auto</code> 关键字的前世今生</h2>
<p>TODO</p>
<h2 id="auto_2">变量声明为 <code>auto</code></h2>
<p>TODO</p>
<h2 id="auto_3">返回类型 <code>auto</code></h2>
<p>C++11 引入的 <code>auto</code> 关键字可以用作函数的返回类型，但它只是一个“占位”，让我们得以后置返回类型，并没有多大作用，非常残废。</p>
<pre><code class="language-cpp">auto f() -&gt; int;
// 等价于：
int f();
</code></pre>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 闹了半天，还是要写返回类型，就只是挪到后面去好看一点……</p>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 当初引入后置返回类型实际的用途是 <code>auto f(int x) -&gt; decltype(x * x) { return x * x; }</code> 这种情况，但很容易被接下来 C++14 引入的真正 <code>auto</code> 返回类型推导平替了。</p>
</blockquote>
<p>但是 C++14 引入了函数<strong>返回类型推导</strong>，<code>auto</code> 才算真正意义上能用做函数返回类型，它会自动根据函数中的 <code>return</code> 表达式推导出函数的返回类型。</p>
<pre><code class="language-cpp">auto f(int x) {
    return x * x;  // 表达式 `x * x` 的类型为 int，所以 auto 类型推导为 int
}
// 等价于：
int f() {
    return x * x;
}
</code></pre>
<p>如果函数中没有 <code>return</code> 语句，那么 <code>auto</code> 会被自动推导为 <code>void</code>，非常方便。</p>
<pre><code class="language-cpp">auto f() {
    std::println(&quot;hello&quot;);
}
// 等价于：
void f() {
    std::println(&quot;hello&quot;);
}
</code></pre>
<p>值得注意的是，返回类型用 <code>auto</code> 来推导的函数，如果有多条 <code>return</code> 语句，那么他们必须都返回相同的类型，否则报错。</p>
<pre><code class="language-cpp">auto f(int x) {
    if (x &gt; 0) {
        return 1;    // int
    } else {
        return 3.14; // double
    }
} // 错误：有歧义，无法确定 auto 应该推导为 int 还是 double
</code></pre>
<p><code>auto</code> 还有一个缺点是，无法用于“分离声明和定义”的情况。因为推导 <code>auto</code> 类型需要知道函数体，才能看到里面的 <code>return</code> 表达式是什么类型。所以当 <code>auto</code> 返回类型被用于函数的非定义声明时，会直接报错。</p>
<pre><code class="language-cpp">auto f();  // 错误：看不到函数体，无法推导返回类型

auto f() { // 编译通过：auto 推导为 int
    return 1;  // 1 是 int 类型的表达式
}
</code></pre>
<p>因此，<code>auto</code> 通常只适用于头文件中“就地定义”的 <code>inline</code> 函数，不适合需要“分离 .cpp 文件”的函数。</p>
<h3 id="_1">返回引用类型</h3>
<p>返回类型声明为 <code>auto</code>，可以自动推导返回类型，但总是推导出普通的值类型，绝对不会带有引用或 <code>const</code> 修饰。</p>
<p>如果需要返回一个引用，并且希望自动推导引用的类型，可以写 <code>auto &amp;</code>。</p>
<pre><code class="language-cpp">int i;
int &amp;ref = i;

auto f() { // 返回类型推导为 int
    return i;
}

auto f() { // 返回类型推导依然为 int
    return ref;
}

auto &amp;f() { // 返回类型这才能推导为 int &amp;
    return ref;
}

auto &amp;f() { // 编译期报错：1 是纯右值，不可转为左值引用
    return 1;
}

auto &amp;f() { // 运行时出错：空悬引用是未定义行为
    int local = 42;
    return local;
}
</code></pre>
<p>这里的 <code>auto</code> 还可以带有 <code>const</code> 修饰，例如 <code>auto const &amp;</code> 可以让返回类型变成带有 <code>const</code> 修饰的常引用。</p>
<pre><code class="language-cpp">int i;
int &amp;ref = i;

```cpp
int i;

auto getValue() { // 返回类型推导为 int
    return i;
}

auto &amp;getRef() { // 返回类型推导为 int &amp;
    return i;
}

auto const &amp;getConstRef() { // 返回类型推导为 int const &amp;
    return i;
}
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>auto const &amp;</code> 与 <code>const auto &amp;</code> 完全等价，只是代码习惯问题。</p>
</blockquote>
<p>有趣的是，如果 <code>i</code> 是 <code>int const</code> 类型，则 <code>auto &amp;</code> 也可以自动推导为 <code>int const &amp;</code> 且不报错。</p>
<pre><code class="language-cpp">const int i;

auto const &amp;getConstRef() { // 返回类型推导为 int const &amp;
    return i;
}

auto &amp;getRef() { // 返回类型也会被推导为 int const &amp;
    return i;
}

int &amp;getRef() { // 报错！
    return i;
}
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>int const</code> 与 <code>const int</code> 是完全等价的，只是代码习惯问题。</p>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>auto &amp;</code> 可以兼容 <code>int const &amp;</code>，而 <code>int &amp;</code> 就不能兼容 <code>int const &amp;</code>！很奇怪吧？这是因为 <code>auto</code> 不一定必须是 <code>int</code>，也可以是 <code>const int</code> 这一整个类型。你可以把 <code>auto</code> 看作和模板函数参数一样，模板函数参数的 <code>T &amp;</code> 一样可以通过将 <code>T = const int</code> 从而捕获 <code>const int &amp;</code>。</p>
</blockquote>
<p>如果要允许 <code>auto</code> 推导为右值引用，只需写 <code>auto &amp;&amp;</code>。</p>
<pre><code class="language-cpp">std::string str;

auto &amp;&amp;getRVRef() { // std::string &amp;&amp;
    return std::move(str);
}

auto &amp;getRef() { // std::string &amp;
    return str;
}

auto const &amp;getConstRef() { // std::string const &amp;
    return str;
}
</code></pre>
<p>正如 <code>auto &amp;</code> 可以兼容 <code>auto const &amp;</code> 一样，由于 C++ 的某些特色机制，<code>auto &amp;&amp;</code> 其实也可以兼容 <code>auto &amp;</code>！</p>
<p>所以 <code>auto &amp;&amp;</code> 实际上不止支持右值引用，也支持左值引用，因此被称为“万能引用”。</p>
<p>也就是说，其实我们可以都写作 <code>auto &amp;&amp;</code>！让编译器自动根据我们 <code>return</code> 语句的表达式类型，判断返回类型是左还是右引用。</p>
<pre><code class="language-cpp">std::string str;

auto &amp;&amp;getRVRef() { // std::string &amp;&amp;
    return std::move(str);
}

auto &amp;&amp;getRef() { // std::string &amp;
    return str;
}

auto const &amp;getConstRef() { // std::string const &amp;
    return str;
}
</code></pre>
<p><code>auto &amp;&amp;</code> 不仅能推导为右值引用，也能推导为左值引用，常左值引用。</p>
<p>可以理解为集合的包含关系：<code>auto &amp;&amp;</code> &gt; <code>auto &amp;</code> &gt; <code>auto const &amp;</code></p>
<p>所以 <code>auto &amp;&amp;</code> 实际上可以推导所有引用，不论左右。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 这里的原因和刚才 <code>auto = int const</code> 从而 <code>auto &amp;</code> 可以接纳 <code>int const &amp;</code> 一样，<code>auto &amp;&amp;</code> 可以接纳 <code>int &amp;</code> 是因为 C++ 特色的“引用折叠”机制：<code>&amp; &amp;&amp; = &amp;</code> 即左引用碰到右引用，会得到左引用。所以编译器可以通过令 <code>auto = int &amp;</code> 从而使得 <code>auto &amp;&amp; = int &amp; &amp;&amp; = int &amp;</code>，从而实际上 <code>auto &amp;&amp;</code> 看似是右值引用，但是因为可以给 <code>auto</code> 带入一个左值引用 <code>int &amp;</code>，然后让左引用 <code>&amp;</code> 与右引用 <code>&amp;&amp;</code> “湮灭”，最终只剩下一个左引用 <code>&amp;</code>，在之后的模板函数专题中会更详细介绍这一特色机制。</p>
</blockquote>
<p>这就是为什么 <code>int &amp;&amp;</code> 就只是右值引用，而 <code>auto &amp;&amp;</code> 以及 <code>T &amp;&amp;</code> 则会叫做万能引用。一旦允许前面的参数为 <code>auto</code> 或者模板参数，就可以代换，就可以实现左右通吃。</p>
<h3 id="decltypeauto">真正的万能 <code>decltype(auto)</code></h3>
<p>返回类型声明为 <code>decltype(auto)</code> 的效果等价于把返回类型替换为 <code>decltype((返回表达式))</code>：</p>
<pre><code class="language-cpp">int i;

decltype(auto) func() {
    return i;
}
// 等价于：
decltype((i)) func() {
    return i;
}
// 等价于：
int &amp;func() {
    return i;
}
</code></pre>
<blockquote>
<p><img src="../img/warning.png" height="30px" width="auto" style="margin: 0; border: none"/> 注意 <code>decltype(i)</code> 是 <code>int</code> 而 <code>decltype((i))</code> 是 <code>int &amp;</code>。这是因为 <code>decltype</code> 实际上有两个版本！当 <code>decltype</code> 中的内容只是单独的一个标识符（变量名）时，会得到变量定义时的类型；而当 <code>decltype</code> 中的内容不是单纯的变量名，而是一个复杂的表达式时，就会进入 <code>decltype</code> 的第二个版本：表达式版，会求表达式的类型，例如当变量为 <code>int</code> 时，表达式 <code>(i)</code> 的类型是左值引用，<code>int &amp;</code>，而变量本身 <code>i</code> 的类型则是 <code>int</code>。此处加上 <code>()</code> 就是为了让 <code>decltype</code> 被迫进入“表达式”的那个版本，<code>decltype(auto)</code> 遵循的也是“表达式”这个版本的结果。</p>
</blockquote>
<pre><code class="language-cpp">int i;

decltype(auto) func() {
    return i;
}
// 等价于：
decltype((i + 1)) func() {
    return i + 1;
}
// 等价于：
int func() {
    return i + 1;
}
</code></pre>
<pre><code class="language-cpp">int i;

decltype(auto) func() {
    return std::move(i);
}
// 等价于：
decltype((std::move(i))) func() {
    return std::move(i);
}
// 等价于：
int &amp;&amp;func() {
    return std::move(i);
}
</code></pre>
<p>以上介绍的这些引用推导规则，其实也适用于局部变量的 <code>auto</code>，例如：</p>
<pre><code class="language-cpp">auto i = 0;              // int i = 0
auto &amp;ref = i;           // int &amp;ref = i
auto const &amp;cref = i;    // int const &amp;cref = i
auto &amp;&amp;rvref = std::move(i); // int &amp;&amp;rvref = move(i)

decltype(auto) j = i;    // int j = i
decltype(auto) k = ref;  // int &amp;k = ref
decltype(auto) l = cref; // int const &amp;l = cref
decltype(auto) m = std::move(rvref); // int &amp;&amp;m = rvref
</code></pre>
<h2 id="for-auto">范围 for 循环中的 <code>auto &amp;</code></h2>
<p>众所周知，在 C++11 的“范围 for 循环” (range-based for loop) 语法中，<code>auto</code> 的出镜率很高。</p>
<p>但是如果只是写 <code>auto i: arr</code> 的话，这会从 arr 中拷贝一份新的 <code>i</code> 变量出来，不仅产生了额外的开销，还意味着你对这 <code>i</code> 变量的修改不会反映到 <code>arr</code> 中原本的元素中去。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr = {1, 2, 3};
for (auto i: arr) {  // auto i 推导为 int i，会拷贝一份新的 int 变量
    i += 1; // 错误的写法，这样只是修改了 int 变量
}
print(arr); // 依然是 {1, 2, 3}
</code></pre>
<p>更好的写法是 <code>auto &amp;i: arr</code>，保存一份对数组中元素的引用，不仅避免了拷贝的开销（如果不是 <code>int</code> 而是其他更大的类型的话，这是一笔不小的开销），而且允许你就地修改数组中元素的值。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr = {1, 2, 3};
for (auto &amp;i: arr) {  // auto &amp;i 推导为 int &amp;i，保存的是对 arr 中原元素的一份引用，不发生拷贝
    i += 1; // 因为 i 现在是对 arr 中真正元素的引用，对其修改也会成功反映到原 arr 中去
}
print(arr); // 变成了 {2, 3, 4}
</code></pre>
<p>如果不打算修改数组，也可以用 <code>auto const &amp;</code>，让捕获到的引用添加上 <code>const</code> 修饰，避免一不小心修改了数组，同时提升代码可读性（人家一看就懂哪些 for 循环是想要修改原值，哪些不会修改原值）。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr = {1, 2, 3};
for (auto const &amp;i: arr) {  // auto const &amp;i 推导为 int const &amp;i，保存的是对 arr 中原元素的一份常引用，不发生拷贝，且不可修改
    i += 1; // 编译期出错！const 引用不可修改
}
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 对于遍历 <code>std::map</code>，由于刚才提到的 <code>auto &amp;</code> 实际上也兼容常引用，而 map 的值类型是 <code>std::pair&lt;const K, V&gt;</code>，所以即使你只需修改 <code>V</code> 的部分，只需使用 <code>auto &amp;</code> 配合 C++17 的“结构化绑定” (structural-binding) 语法拆包即可，<code>K</code> 的部分会自动带上 <code>const</code>，不会出现编译错误的。</p>
</blockquote>
<pre><code class="language-cpp">std::map&lt;std::string, std::string&gt; table;
for (auto &amp;[k, v]: table) { // 编译通过：k 的部分会自动带上 const
    k = &quot;hello&quot;; // 编译出错：k 推导为 std::string const &amp; 不可修改
    v = &quot;world&quot;; // 没问题：v 推导为 std::string &amp; 可以就地修改
}
</code></pre>
<h2 id="auto_4">参数类型 <code>auto</code></h2>
<p>C++20 引入了<strong>模板参数推导</strong>，可以让我们在函数参数中也使用 <code>auto</code>。</p>
<p>在函数参数中也使用 <code>auto</code> 实际上等价于将该参数声明为模板参数，仅仅是一种更便捷的写法。</p>
<pre><code class="language-cpp">void func(auto x) {
    std::cout &lt;&lt; x;
}
// 等价于:
template &lt;typename T&gt;
void func(T x) {
    std::cout &lt;&lt; x;
}

func(1); // 自动推导为调用 func&lt;int&gt;(1)
func(3.14); // 自动推导为调用 func&lt;double&gt;(3.14)
</code></pre>
<p>如果参数类型的 <code>auto</code> 带有如 <code>auto &amp;</code> 这样的修饰，则实际上等价于相应模板函数的 <code>T &amp;</code>。</p>
<pre><code class="language-cpp">// 自动推导为常引用
void func(auto const &amp;x) {
    std::cout &lt;&lt; x;
}
// 等价于:
template &lt;typename T&gt;
void func(T const &amp;x) {
    std::cout &lt;&lt; x;
}

// 自动推导为万能引用
void func(auto &amp;&amp;x) {
    std::cout &lt;&lt; x;
}
// 等价于:
template &lt;typename T&gt;
void func(T &amp;&amp;x) {
    std::cout &lt;&lt; x;
}
</code></pre>
<h3 id="auto_5"><code>auto</code> 在多态中的妙用</h3>
<p>传统的，基于类型重载的：</p>
<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

double square(double x) {
    return x * x;
}

int main() {
    square(2);    // 4（调用 int 版重载）
    square(3.14); // 9.8596（调用 double 版重载）
    // 如果现在又需要 float 版呢？又得写一版重载，内容还是完全一样的，浪费时间
}
</code></pre>
<p>基于 <code>auto</code> 模板参数推导的：</p>
<pre><code class="language-cpp">auto square(auto x) {
    return x * x;
}

int main() {
    square(2);    // 4（auto 推导为 int）
    square(3.14); // 9.8596（auto 推导为 double）
    // 即使未来产生了 float 版的需求，也不用添加任何代码，因为是 square 是很方便的模板函数
}
</code></pre>
<p>实际上等价于模板函数的如下写法：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
decltype(T() * T()) square(T x) {
    return x * x;
}
</code></pre>
<h3 id="auto_6">参数 <code>auto</code> 推导为引用</h3>
<p>和之前变量 <code>auto</code>，返回类型 <code>auto</code> 的 <code>auto &amp;</code>、<code>auto const &amp;</code>、<code>auto &amp;&amp;</code> 大差不差，C++20 这个参数 <code>auto</code> 同样也支持推导为引用。</p>
<pre><code class="language-cpp">void passByValue(auto x) { // 参数类型推导为 int
    x = 42;
}

void passByRef(auto &amp;x) { // 参数类型推导为 int &amp;
    x = 42;
}

void passByConstRef(auto const &amp;x) { // 参数类型推导为 int const &amp;
    x = 42; // 编译期错误：常引用无法写入！
}

int x = 1;
passByValue(x);
cout &lt;&lt; x; // 还是 1
passByRef(x);
cout &lt;&lt; x; // 42
</code></pre>
<pre><code class="language-cpp">void passByRef(auto &amp;x) {
    x = 1;
}

int x = 1;
const int const_x = 1;
passByRef(i); // 参数类型推导为 int &amp;
passByRef(const_x); // 参数类型推导为 const int &amp;
</code></pre>
<p>由于 <code>auto &amp;</code> 兼容 <code>auto const &amp;</code> 的尿性，此处第二个调用 <code>passByRef</code> 会把参数类型推导为 <code>const int &amp;</code>，这会导致里面的 x = 42 编译出错！</p>
<ul>
<li>所以 <code>auto &amp;</code> 实际上也允许传入 <code>const</code> 变量的引用，非常恼人，不要掉以轻心。</li>
<li>而 <code>auto const &amp;</code> 则可以安心，一定是带 <code>const</code> 的。</li>
</ul>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 所以实际上最常用的是 <code>auto const &amp;</code>。</p>
</blockquote>
<p>不仅如此 <code>auto const &amp;</code> 参数还可以传入纯右值（利用了 C++ 可以自动把纯右值转为 <code>const</code> 左引用的特性）。</p>
<p>对于已有的变量传入，可以避免一次拷贝；对于就地创建的纯右值表达式，则自动转换，非常方便。</p>
<pre><code class="language-cpp">void passByConstRef(auto const &amp;cref) {
    std::cout &lt;&lt; cref;
}

int i = 42;
passByConstRef(i);  // 传入 i 的引用
passByConstRef(42); // 利用 C++ 自动把纯右值 “42” 自动转为 const 左值的特性
</code></pre>
<p>对于这种自动转出来的 <code>const</code> 左值引用，其实际上是在栈上自动创建了一个 <code>const</code> 变量保存你临时创建的参数，然后在当前行结束后自动析构。</p>
<pre><code class="language-cpp">passByConstRef(42);
// 等价于：
{
    const int tmp = 42;
    passByConstRef(tmp); // 传入的是这个自动生成 tmp 变量的 const 引用
}
</code></pre>
<p>这个自动生成的 <code>tmp</code> 变量的生命周期是“一条语句”，也就是当前分号结束前，该变量的生命周期都存在，直到分号结束后才会析构，所以如下代码是安全的：</p>
<pre><code class="language-cpp">void someCFunc(const char *name);

someCFunc(std::string(&quot;hello&quot;).c_str());
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 此处 <code>std::string("hello")</code> 构造出的临时 <code>string</code> 类型变量的生命周期直到 <code>;</code> 才结束，而这时 <code>someCFunc</code> 早已执行完毕返回了，只要 <code>someCFunc</code> 对 <code>name</code> 的访问集中在当前这次函数调用中，没有把 <code>name</code> 参数存到全局变量中去，就不会有任何空悬指针问题。</p>
</blockquote>
<h3 id="auto_7"><code>auto &amp;&amp;</code> 参数万能引用及其转发</h3>
<p>TODO</p>
<p>然而，由于 C++ “默认自动变左值”的糟糕特色，即使你将一个传入时是右值的引用直接转发给另一个函数，这个参数也会默默退化成左值类型，需要再 <code>std::move</code> 一次才能保持他一直处于右值类型。</p>
<h3 id="stdforward"><code>std::forward</code> 帮手函数介绍</h3></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>小彭老师倾 ♥ 制作</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../js/print-site.js"></script>
        <script src="../extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
