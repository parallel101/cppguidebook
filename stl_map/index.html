<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="小彭老师">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>STL 精讲：std::map 和他的朋友们 - ✝️小彭大典✝️</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/print-site-enum-headings1.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings2.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings3.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings4.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings5.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings6.css" rel="stylesheet">
        <link href="../css/print-site.css" rel="stylesheet">
        <link href="../css/print-site-mkdocs.css" rel="stylesheet">
        <link href="../extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">✝️小彭大典✝️</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">章节列表</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href=".." class="dropdown-item">前言</a>
</li>
                                    
<li>
    <a href="../hello_world/" class="dropdown-item">你好，世界</a>
</li>
                                    
<li>
    <a href="../platform/" class="dropdown-item">开发环境与平台选择</a>
</li>
                                    
<li>
    <a href="../variable_types/" class="dropdown-item">变量与类型 (未完工)</a>
</li>
                                    
<li>
    <a href="../functions/" class="dropdown-item">认识函数 (未完工)</a>
</li>
                                    
<li>
    <a href="../cpp_tricks/" class="dropdown-item">应知应会 C++ 小技巧</a>
</li>
                                    
<li>
    <a href="../lambda/" class="dropdown-item">函数式编程</a>
</li>
                                    
<li>
    <a href="../type_rich_api/" class="dropdown-item">现代化的 API 设计指南</a>
</li>
                                    
<li>
    <a href="../no_more_new/" class="dropdown-item">现代 C++ 从拒绝 new 开始</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">STL 精讲：std::map 和他的朋友们</a>
</li>
                                    
<li>
    <a href="../design_overview/" class="dropdown-item">设计模式总览 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_virtual/" class="dropdown-item">让虚函数再次伟大！</a>
</li>
                                    
<li>
    <a href="../design_gamedev/" class="dropdown-item">游戏开发中常用的设计模式</a>
</li>
                                    
<li>
    <a href="../design_functor/" class="dropdown-item">函数式设计模式</a>
</li>
                                    
<li>
    <a href="../design_variant/" class="dropdown-item">静态多态与面向数据编程 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_erasure/" class="dropdown-item">类型擦除神教及其实现 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_concept/" class="dropdown-item">鸭子类型与 C++20 concept (未完工)</a>
</li>
                                    
<li>
    <a href="../error_code/" class="dropdown-item">现代 C++ 中的错误处理 (未完工)</a>
</li>
                                    
<li>
    <a href="../cpp_lifetime/" class="dropdown-item">深入理解析构函数与生命周期</a>
</li>
                                    
<li>
    <a href="../cpp_memory/" class="dropdown-item">真正的 C++ 内存模型！ (未完工)</a>
</li>
                                    
<li>
    <a href="../unicode/" class="dropdown-item">字符编码那些事</a>
</li>
                                    
<li>
    <a href="../undef/" class="dropdown-item">未定义行为完整列表</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">关于</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about/" class="dropdown-item">关于小彭老师</a>
</li>
                                    
<li>
    <a href="../donate/" class="dropdown-item">赞助名单</a>
</li>
                                    
<li>
    <a href="../recommend/" class="dropdown-item">参考资料与项目</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook" class="nav-link">GitHub</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://space.bilibili.com/263032155" class="nav-link">Bilibili</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../no_more_new/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../design_overview/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook/edit/master/docs/stl_map.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#stl-stdmap" class="nav-link">STL 精讲：std::map 和他的朋友们</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">前言</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_9" class="nav-link">什么是算法复杂度</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map" class="nav-link">map 的逻辑结构</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map_2" class="nav-link">map 的物理结构</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map_3" class="nav-link">开始使用 map 容器</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_18" class="nav-link">总结</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_19" class="nav-link">你知道吗？[] 的妙用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_25" class="nav-link">为什么需要反向查找表</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#value_type" class="nav-link">元编程查询成员类型：value_type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_28" class="nav-link">一边遍历一边删除部分元素</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#insert" class="nav-link">批量 insert</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#insert_5" class="nav-link">带插入位置提示的 insert</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#emplace" class="nav-link">分奴 emplace</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#try_emplace" class="nav-link">try_emplace 更好</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map-raii" class="nav-link">map 与 RAII</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_43" class="nav-link">增删改查总结</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_47" class="nav-link">节点句柄系列接口</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map_6" class="nav-link">map 自定义比较器</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map_8" class="nav-link">透明 map</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#multimap" class="nav-link">神奇的 multimap</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_66" class="nav-link">时间复杂度总结说明</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#unordered_map" class="nav-link">哈希表 unordered_map</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#unordered_map-map_1" class="nav-link">unordered_map 与 map 的异同</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_73" class="nav-link">经典案例</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_76" class="nav-link">问题：多线程安全</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_77" class="nav-link">本期孝点总结</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="stl-stdmap">STL 精讲：std::map 和他的朋友们</h1>
<!-- PG1 -->

<p>让高性能数据结构惠及每一人</p>
<p>https://github.com/parallel101/course/tree/master/slides/stl_map/experiment/</p>
<div class="toc">
<ul>
<li><a href="#stl-stdmap">STL 精讲：std::map 和他的朋友们</a><ul>
<li><a href="#_1">前言</a><ul>
<li><a href="#_2">课程简介</a></li>
<li><a href="#_3">课程亮点</a></li>
<li><a href="#_4">课程大纲</a></li>
<li><a href="#_5">实验环境</a></li>
<li><a href="#_6">如何使用课件</a></li>
<li><a href="#_7">如何运行案例代码</a></li>
<li><a href="#_8">课程书写习惯说明</a></li>
</ul>
</li>
<li><a href="#_9">什么是算法复杂度</a><ul>
<li><a href="#_10">关于算法复杂度，一个真实的小故事</a></li>
<li><a href="#_11">数据结构与复杂度</a></li>
</ul>
</li>
<li><a href="#map">map 的逻辑结构</a><ul>
<li><a href="#stdmap">为什么要学习 std::map</a></li>
<li><a href="#map_1">标准库中的 map 容器</a></li>
</ul>
</li>
<li><a href="#map_2">map 的物理结构</a><ul>
<li><a href="#_12">二叉排序树与二分法</a></li>
<li><a href="#_13">二叉排序树</a></li>
<li><a href="#_14">二叉树退化问题</a></li>
<li><a href="#vs">红黑树 vs 平衡树</a><ul>
<li><a href="#_15">平衡树</a></li>
<li><a href="#_16">红黑树</a></li>
<li><a href="#_17">红黑树实现平衡的秘密</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map_3">开始使用 map 容器</a></li>
</ul>
</li>
<li><a href="#_18">总结</a><ul>
<li><a href="#c">C 语言的退化规则真是害人不浅</a></li>
<li><a href="#_19">你知道吗？[] 的妙用</a><ul>
<li><a href="#_20">[] 妙用举例：出现次数统计</a><ul>
<li><a href="#_21">对比</a></li>
</ul>
</li>
<li><a href="#_22">[] 妙用举例：归类</a><ul>
<li><a href="#_23">对比</a></li>
</ul>
</li>
<li><a href="#_24">[] 妙用举例：线程局部变量</a></li>
</ul>
</li>
<li><a href="#_25">为什么需要反向查找表</a><ul>
<li><a href="#map_4">map 构建下标查找表</a></li>
<li><a href="#map-map">map 构建另一个 map 的反向查找表</a></li>
</ul>
</li>
<li><a href="#value_type">元编程查询成员类型：value_type</a><ul>
<li><a href="#typename">typename 修饰</a></li>
<li><a href="#decltype">decltype 大法好</a></li>
<li><a href="#_26">查询类名小工具</a></li>
<li><a href="#map_5">map 真正的元素类型究竟是什么？</a></li>
<li><a href="#count-contains">count 和 contains 没区别</a></li>
<li><a href="#end">end 不能解引用</a></li>
<li><a href="#find">find 的好处</a><ul>
<li><a href="#c17">C++17 语法糖</a></li>
<li><a href="#_27">题外话</a></li>
</ul>
</li>
<li><a href="#map-pair">对 map 而言，迭代器解引用得到的是 pair</a></li>
</ul>
</li>
<li><a href="#_28">一边遍历一边删除部分元素</a><ul>
<li><a href="#c20-erase_if">C++20 更好的写法：erase_if</a></li>
<li><a href="#insert_or_assign">insert_or_assign</a><ul>
<li><a href="#insert_or_assign_1">insert_or_assign 的优势</a></li>
<li><a href="#_29">效率问题</a><ul>
<li><a href="#_30">[]</a></li>
<li><a href="#insert_or_assign_2">insert_or_assign</a></li>
</ul>
</li>
<li><a href="#_31">那我应该用什么</a></li>
<li><a href="#insert_or_assign-vs-insert">insert_or_assign vs insert：顺序问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#insert">批量 insert</a><ul>
<li><a href="#insert_1">批量 insert 同样遵循不覆盖原则</a></li>
<li><a href="#insert-map">批量 insert 实现 map 合并</a><ul>
<li><a href="#_32">就地写入！</a></li>
<li><a href="#insert_2">批量 insert 优先保留已经有的</a></li>
<li><a href="#_33">其他操作：交集、并集、差集等</a></li>
</ul>
</li>
<li><a href="#insert_3">insert 一个初始化列表</a><ul>
<li><a href="#insert_4">小彭老师锐评批量 insert 有什么用</a></li>
</ul>
</li>
<li><a href="#operator">operator= 也支持初始化列表</a><ul>
<li><a href="#_34">赋值函数和构造函数概念辨析</a></li>
<li><a href="#assign">assign 函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#insert_5">带插入位置提示的 insert</a><ul>
<li><a href="#_35">复杂度分类讨论</a></li>
<li><a href="#_36">小学生的趣味早操</a></li>
<li><a href="#_37">小学生来的顺序已经有序的情况</a></li>
</ul>
</li>
<li><a href="#emplace">分奴 emplace</a><ul>
<li><a href="#emplace_hint">emplace_hint</a></li>
<li><a href="#emplace_1">emplace 的原理和优点</a></li>
</ul>
</li>
<li><a href="#try_emplace">try_emplace 更好</a><ul>
<li><a href="#try_emplace_1">try_emplace 可以避免移动！</a></li>
<li><a href="#try_emplace_2">谈谈 try_emplace 的优缺点</a></li>
<li><a href="#_38">什么是聚合初始化</a></li>
<li><a href="#c20">C++20 修复了聚合初始化不支持圆括号的缺点</a></li>
<li><a href="#_39">调用开销分析</a></li>
<li><a href="#try_emplace_3">try_emplace 成功提升性能的案例</a></li>
<li><a href="#try_emplace_4">带插入位置提示的 try_emplace</a></li>
<li><a href="#emplace_2">emplace 家族总结</a></li>
</ul>
</li>
<li><a href="#map-raii">map 与 RAII</a><ul>
<li><a href="#1">案例 1：资源类可以移动</a></li>
<li><a href="#2">案例 2：资源类禁止移动</a></li>
<li><a href="#_40">记得删除移动构造函数</a></li>
<li><a href="#_41">统一交给智能指针管理</a><ul>
<li><a href="#_42">智能指针帮你避免移动</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_43">增删改查总结</a><ul>
<li><a href="#_44">增删</a></li>
<li><a href="#_45">改查</a><ul>
<li><a href="#_46">初始化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_47">节点句柄系列接口</a><ul>
<li><a href="#extract">extract</a><ul>
<li><a href="#_48">用途举例</a></li>
</ul>
</li>
<li><a href="#insert_6">insert 节点版</a><ul>
<li><a href="#insert_return_type">insert_return_type</a></li>
</ul>
</li>
<li><a href="#extract-insert">extract + insert 运用案例</a></li>
<li><a href="#extract_1">extract 性能优化案例</a></li>
<li><a href="#_49">游离节点可以修改键值</a></li>
<li><a href="#insert_7">带提示的节点版 insert</a></li>
<li><a href="#mergemap">merge：map 的合并操作（并集）</a><ul>
<li><a href="#insert-vs-merge">批量 insert vs merge</a></li>
<li><a href="#merge-insert">merge 和 insert 一样不覆盖旧值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map_6">map 自定义比较器</a><ul>
<li><a href="#stdless">std::less 的作用</a><ul>
<li><a href="#operator_1">operator()</a></li>
</ul>
</li>
<li><a href="#_50">自定义排序方式</a><ul>
<li><a href="#_51">只需要小于号</a></li>
</ul>
</li>
<li><a href="#_52">自定义小于号的三种方式</a></li>
<li><a href="#_53">自定义按哪个字段来索引</a></li>
<li><a href="#c20_1">C++20 三路运算符 &lt;=&gt;</a></li>
<li><a href="#_54">仿函数运算符全家桶</a></li>
<li><a href="#greater">greater 实现反向排序</a></li>
<li><a href="#_55">大小写不敏感的字符串比较器</a></li>
<li><a href="#lambda">传入 lambda 做比较器</a><ul>
<li><a href="#map_7">map 构造函数是如何传入比较器的</a></li>
<li><a href="#_56">有状态（捕获变量）的比较器</a></li>
<li><a href="#function">建议用 function</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map_8">透明 map</a><ul>
<li><a href="#_57">什么是透明仿函数</a></li>
<li><a href="#_58">为什么需要透明仿函数</a></li>
<li><a href="#find_1">泛型版的 find 函数</a></li>
<li><a href="#find_2">泛型 find 的要求：透明</a><ul>
<li><a href="#_59">应用：字符串为键的字典</a></li>
<li><a href="#_60">应用：智能指针为键的字典</a></li>
<li><a href="#_61">应用：超大对象为键的字典</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#multimap">神奇的 multimap</a><ul>
<li><a href="#_62">元素的排列顺序</a></li>
<li><a href="#_63">用途：动态排序！</a></li>
<li><a href="#_64">查询某个键对应的多个值</a></li>
<li><a href="#lowerupper_bound">lower/upper_bound 实现范围查询</a></li>
<li><a href="#_65">课后练习</a></li>
</ul>
</li>
<li><a href="#_66">时间复杂度总结说明</a></li>
<li><a href="#unordered_map">哈希表 unordered_map</a><ul>
<li><a href="#unordered_map-map">unordered_map 与 map 之争：适用场景不同</a></li>
<li><a href="#unordered_map_1">原理：unordered_map 中的“桶”</a></li>
<li><a href="#hash-collision">哈希冲突 (hash-collision)</a></li>
</ul>
</li>
<li><a href="#unordered_map-map_1">unordered_map 与 map 的异同</a><ul>
<li><a href="#1_1">区别 1：有序性</a><ul>
<li><a href="#hash-equal_to">hash 和 equal_to</a></li>
<li><a href="#_67">哈希函数的思想</a></li>
<li><a href="#_68">自动取模</a></li>
</ul>
</li>
<li><a href="#hash-trait">hash 是个 trait 类</a></li>
<li><a href="#2_1">区别 2：时间复杂度</a><ul>
<li><a href="#_69">哈希表的复杂度不稳定</a></li>
<li><a href="#_70">哈希表的应用限制</a></li>
</ul>
</li>
<li><a href="#3">区别 3：迭代器失效条件</a></li>
<li><a href="#load_factor">负载率（load_factor）</a></li>
<li><a href="#rehash">rehash 函数</a></li>
<li><a href="#hash">hash 需要特化</a></li>
<li><a href="#tuple">给 tuple 等复合类型自定义哈希函数</a><ul>
<li><a href="#_71">试试看效果吧！</a></li>
</ul>
</li>
<li><a href="#hash_combine">更好的 hash_combine</a><ul>
<li><a href="#boosthash_combine">最先进的是 boost::hash_combine 的方法</a></li>
<li><a href="#_72">应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_73">经典案例</a><ul>
<li><a href="#map-function">map 和 function 结合使用</a></li>
<li><a href="#map-variant">map 和 variant 结合使用</a></li>
<li><a href="#map-string_view">map 和 string_view 结合使用透明查找案例</a></li>
<li><a href="#c-api">全局句柄表实现仿 C 语言 API</a></li>
<li><a href="#_74">全局注册表实现动态反射</a></li>
<li><a href="#_75">带缓存的编译函数</a></li>
</ul>
</li>
<li><a href="#_76">问题：多线程安全</a></li>
<li><a href="#_77">本期孝点总结</a></li>
</ul>
</li>
</ul>
</div>
<!-- PG2 -->

<h2 id="_1">前言</h2>
<h3 id="_2">课程简介</h3>
<p>😀😀😀</p>
<p>面向已经了解一定 C++ 语法，正在学习标准库的童鞋。</p>
<p>C++ 标准库又称 STL，包含了大量程序员常用的算法和数据结构，是 Bjarne Stroustrup 送给所有 C++ 程序员的一把瑞士军刀，然而发现很多童鞋并没有完全用好他，反而还被其复杂性误伤了。</p>
<p>如果你也对标准库一知半解，需要系统学习的话，那么本课程适合你。小彭老师将运用他特有的幽默答辩比喻，全面介绍各 STL 容器的所有用法。结合一系列实战案例，剖析常见坑点，使用技巧等。对比不同写法的性能与可读性，还会与 Python 语言相互类比方便记忆，科普的部分冷知识可以作为大厂面试加分项。</p>
<p>::right::</p>
<p><img alt="" src="../img/stl/maijiaxiu.jpg" width="320" /></p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 本课程受到童鞋一致好评</p>
</blockquote>
<hr />
<!-- PG3 -->

<h3 id="_3">课程亮点</h3>
<p>👍👍👍</p>
<p>本系列课程与《侯杰老师 STL 课》的区别：</p>
<ul>
<li>侯杰老师价值 2650 元，本课程录播上传 B 站免费观看，观众可以自行选择是否一键三连。</li>
<li>课件和案例源码开源，上传在 GitHub，可以自己下载来做修改，然后自己动手实验，加深理解。</li>
<li>侯杰老师注重理论和底层实现原理，而本课程注重应用，结合实战案例，着重展开重难点，坑点等。</li>
<li>很多学校里教的，百度上搜的，大多是老版本 C++，已经过时，而本课程基于较新的 C++17 和 C++20 标准。</li>
<li>有时存在部分 C++ 高级用法过于艰深，不能适合所有同学，本课程采用因材施教思想：对于新手，可以跳过看不懂的部分，看我提供的“保底用法”，不保证高性能和“优雅”，但至少能用；对学有余力的童鞋，则可以搏一搏上限，把高级用法也看懂，提升面试竞争力。总之不论你是哪个阶段的学习者，都能从此课程中获益。</li>
</ul>
<hr />
<!-- PG4 -->

<h3 id="_4">课程大纲</h3>
<p>✨✨✨</p>
<p>之前几期课程的录播已经上传到比站了<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>。</p>
<ol>
<li>vector 容器初体验 &amp; 迭代器入门 (BV1qF411T7sd)</li>
<li>你所不知道的 set 容器 &amp; 迭代器分类 (BV1m34y157wb)</li>
<li>string，string_view，const char * 的爱恨纠葛 (BV1ja411M7Di)</li>
<li>万能的 map 容器全家桶及其妙用举例 (本期)</li>
<li>函子 functor 与 lambda 表达式知多少</li>
<li>通过实战案例来学习 STL 算法库</li>
<li>C++ 标准输入输出流 &amp; 字符串格式化</li>
<li>traits 技术，用户自定义迭代器与算法</li>
<li>allocator，内存管理与对象生命周期</li>
<li>C++ 异常处理机制的前世今生</li>
</ol>
<hr />
<!-- PG5 -->

<h3 id="_5">实验环境</h3>
<p>✅✅✅</p>
<p>小彭老师个人推荐实验环境如下：</p>
<table>
<thead>
<tr>
<th>要求</th>
<th>❤❤❤</th>
<th>💣💣💣</th>
<th>💩💩💩</th>
<th>💀💀💀</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Arch Linux</td>
<td>Ubuntu 20.04</td>
<td>Wendous 10</td>
<td>Maike OS</td>
</tr>
<tr>
<td>知识储备</td>
<td>会一点 C++</td>
<td>大学 C 语言</td>
<td>Java 面向对象</td>
<td>编程小白</td>
</tr>
<tr>
<td>编译器</td>
<td>GCC 9 以上</td>
<td>Clang 12</td>
<td>VS2019</td>
<td>Apple Clang</td>
</tr>
<tr>
<td>构建系统</td>
<td>CMake 3.18</td>
<td>任意 C++ IDE</td>
<td>单文件编译运行</td>
<td>命令行手动编译</td>
</tr>
<tr>
<td>编辑器</td>
<td>Vim/NeoVim</td>
<td>CLion</td>
<td>VS Code</td>
<td>notepad</td>
</tr>
</tbody>
</table>
<p>游戏难度：❤ = 简单，💣 = 普通，💩 = 困难，💀 = 地狱副本</p>
<hr />
<!-- PG6 -->

<h3 id="_6">如何使用课件</h3>
<p>🥰🥰🥰</p>
<p>本系列课件和源码均公布在：https://github.com/parallel101/course</p>
<p>例如本期的课件位于 <code>course/stlseries/stl_map/slides.md</code>。</p>
<p>课件基于 Slidev<sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">1</a></sup> 开发，Markdown 格式书写，在浏览器中显示，在本地运行课件需要 Node.js：</p>
<ul>
<li>运行命令 <code>npm install</code> 即可自动安装 Slidev</li>
<li>运行命令 <code>npm run dev</code> 即可运行 Slidev 服务</li>
<li>浏览器访问 http://localhost:3030 即可看到课件</li>
</ul>
<p>如果报错找不到 <code>slidev</code> 命令，可以试试 <code>export PATH="$PWD/node_modules/.bin:$PATH"</code>。</p>
<p>如果不想自己配置 Node.js 也可以直接以文本文件格式打开 slides.md 浏览课件。</p>
<p>Slidev 服务运行时，你对 slides.md 的所有修改会立刻实时显现在浏览器中。</p>
<hr />
<!-- PG7 -->

<h3 id="_7">如何运行案例代码</h3>
<p>🥺🥺🥺</p>
<p>案例源码和所需头文件位于课件同目录的 <code>course/stlseries/stl_map/experiment/</code> 文件夹下。</p>
<p>其中 <code>main.cpp</code> 仅导入运行案例所需的头文件，具体各个案例代码分布在 slides.md 里。</p>
<p>如需测试课件中的具体代码，可以把 slides.md 中的案例代码粘贴到 main.cpp 的 main 函数体中进行实验。</p>
<p>此外为了方便，还有一些形如 <code>testxxx.cpp</code> 的文件是一些完整的测试案例，不用从 slides.md 中拷贝，可直接单独运行。</p>
<p>为了方便同学们实验，所需头文件都在同一个目录，没有第三方库依赖。既可以用 CMake 构建，也可以用任意自己喜欢的 IDE 或编辑器 <strong>单文件编译</strong> 运行，无强制要求，只需编译器支持 C++17 即可。</p>
<blockquote>
<p>如果你用 Visual Studio 自己的 sln 系统构建项目，记得开启 <code>/std:c++17</code> 选项。如果你用最新的 Visual Studio（已经支持 CMake）则直接选择“打开文件夹”打开本项目的 <code>experiment</code> 目录即可。</p>
</blockquote>
<hr />
<!-- PG8 -->

<p>附赠了一些实用头文件，同鞋们可以下载来研究，或者在自己的项目里随意运用。</p>
<p><font size="3px"></p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>print.h</td>
<td>内含 print 函数，支持打印绝大多数 STL 容器，方便调试</td>
</tr>
<tr>
<td>map_get.h</td>
<td>带默认值的 map 表项查询，稍后课程中会介绍到</td>
</tr>
<tr>
<td>ScopeProfiler.h</td>
<td>基于 RAII 的函数耗时统计，用于测量性能</td>
</tr>
<tr>
<td>OrderedMap.h</td>
<td>遍历顺序始终保持和插入顺序一致的魔改版 map</td>
</tr>
<tr>
<td>cppdemangle.h</td>
<td>获得类型的名字，以模板参数传入，详见该文件中的注释</td>
</tr>
<tr>
<td>hash.h</td>
<td>比 std::hash 更通用的 generic_hash 实现，支持任意区间和元组</td>
</tr>
<tr>
<td>bits_stdc++.h</td>
<td>仿照 bits/stdc++.h 的万能头文件跨平台版，一次性导入所有库</td>
</tr>
</tbody>
</table>
<p></font></p>
<hr />
<!-- PG9 -->

<h3 id="_8">课程书写习惯说明</h3>
<pre><code class="language-cpp">int const &amp;i  // 本课程书写习惯
const int&amp; i  // 官方文档书写习惯
</code></pre>
<pre><code class="language-cpp">template &lt;class T&gt;     // 本课程书写习惯
template &lt;typename T&gt;  // 官方文档书写习惯
</code></pre>
<p>仅为个人书写习惯不同，在 C++ 编译器看来都是等价的。</p>
<blockquote>
<p>我喜欢把 const 后置，其一是因为这有利于理解 <code>int const *</code> 和 <code>int *const</code> 的区别，如果写成 <code>const int *</code> 就会很困惑 const 究竟是修饰谁的，而用我的写法只需要简单理解为 “const 只修饰他前面的”。其二我经常需要把函数参数中 <code>T t</code> 修改成 <code>T const &amp;t</code>。连在一起加起来比较方便，只需要一次性插入 <code>const &amp;</code> 即可，不用前后两个地方分别加 <code>const</code> 和 <code>&amp;</code>，你觉得呢？</p>
</blockquote>
<hr />
<!-- PG10 -->

<pre><code class="language-cpp">using namespace std; // 仅为教学方便目的，不建议在现实工程中使用 ⚠️
</code></pre>
<p>由于使用了 <code>using namespace std</code>，本课程代码中的 <code>std::</code> 前缀均可以省略不写：</p>
<pre><code class="language-cpp">map&lt;string, vector&lt;int&gt;&gt; m;
erase_if(m, pred);
</code></pre>
<p>现实工程中不建议 <code>using namespace std</code>，请显式写出 <code>std::</code> 前缀：</p>
<pre><code class="language-cpp">std::map&lt;std::string, std::vector&lt;int&gt;&gt; m;
std::erase_if(m, pred);
</code></pre>
<hr />
<!-- PG11 -->

<p>我们自己做测试时经常会用 <code>&lt;bits/stdc++.h&gt;</code> 这个万能头文件。</p>
<p>可惜这个万能头文件在 VS 中似乎不存在<sup id="fnref3:1"><a class="footnote-ref" href="#fn:1">1</a></sup>，因此我自己写了一个跨平台的 <code>"bits_stdc++.h"</code> 放在源码同目录：</p>
<pre><code class="language-cpp">#include &quot;bits_stdc++.h&quot;  // 自动导入所有标准库的头文件
</code></pre>
<p>不过现实工程中，还是建议根据需要一个个导入，不要偷懒用这个不标准的头文件：</p>
<pre><code class="language-cpp">#include &lt;map&gt;            // 导入 std::map, std::multimap
#include &lt;unordered_map&gt;  // 导入 std::unordered_map, std::unordered_multimap
#include &lt;string&gt;         // 导入 std::string, std::wstring
#include &lt;algorithm&gt;      // 导入 std::set_difference, std::set_union, std::set_intersection 等一系列全局函数
// 下面代码中用到哪些容器，就导入哪些头文件
</code></pre>
<hr />
<!-- PG12 -->

<hr />
<!-- PG13 -->

<h2 id="_9">什么是算法复杂度</h2>
<h3 id="_10">关于算法复杂度，一个真实的小故事</h3>
<p>有一次一个同学发给我一份源码文件 tetreader.py，其功能是读取一个 tet 格式的文件（四面体网格模型）。</p>
<p>他问我为什么他写的这个 Python 代码这么慢，读取一个稍微大一点的模型就需要好几秒，他说久仰小彭老师性能优化的大名，想要我帮他优化一下，还问是不是应该用 C++ 写会比较高效一点？</p>
<p>我并不懂得四面体，但性能优化的思路是通用的。我打开文件看了一下，我发现他读取时需要查询一个点周围所有的面，他是这样查询的：</p>
<pre><code class="language-python"># 以下为他的大致伪代码
face_lut = []
for ... in ...:
    face_lut.append(vert_id)  # O(1) ✅
for ... in ...:
    face_id = face_lut.index(vert_id)  # O(N) ⚠️
</code></pre>
<p>我说你这个 face_lut 是个普通数组，数组的 index 函数是 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度的你不知道吗？他相当于暴力遍历了数组找到你需要的值，你这个 index 的调用还是在一个循环里的，所以是 <span class="arithmatex"><span class="MathJax_Preview">O(N^2)</span><script type="math/tex">O(N^2)</script></span> 复杂度！难怪这么慢了。</p>
<hr />
<!-- PG14 -->

<p>后来我给他改了一下，把他的 face_lut 改成字典，用字典查找，高效得多了：</p>
<pre><code class="language-python"># 以下为我优化后的大致伪代码
face_lut = {}
for ... in ...:
    face_lut[vert_id] = face_id  # O(1)+ ✅
for ... in ...:
    face_id = face_lut[vert_id]  # O(1)+ ✅
</code></pre>
<p>一次字典的查询只需要 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>，加上他外面的循环总共只有 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>，变成线性复杂度了。他一试，果然几毫秒就加载完了，我说用字典加速查找这不是常识吗？还搁着 C++ 呢？你就是 CUDA 来了也压不住复杂度的爆表呀？</p>
<p>他很高兴，不知道怎么感谢我，于是就把我推荐给张心欣了。</p>
<hr />
<h3 id="_11">数据结构与复杂度</h3>
<!-- PG15 -->

<p>不论什么语言，容器（或者用学校里的话说：数据结构）的正确使用，能够在复杂度层面上，大幅提升性能。</p>
<p>C++ 中也是如此，有数组（vector），字典（map），还有上一课讲过的集合（set）。</p>
<p>今天我们要介绍的就是 C++ 的字典容器 map，以及 C++11 引入的另一个字典容器 unordered_map，他们的区别我们最后会详细讨论。我们先学习较为简单的 map，随后学习 unordered_map 时也可以举一反三、融会贯通。</p>
<blockquote>
<p>介绍完这两个标准库自带的字典容器后，我们还将介绍一些常用的第三方库容器，例如 absl::flat_hash_map、tbb::concurrent_hash_map、google::dense_hash_map、robin_hood::unordered_map、tsl::robin_pg_map 等，需要根据应用场景选择适合的容器。</p>
</blockquote>
<p>map/set 家族都是高效查找的专家：</p>
<ul>
<li>vector 容器用 std::find 查找：<span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span></li>
<li>map 或 set 容器用 .find 查找：<span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></li>
<li>unordered_map 或 unordered_set 容器用 .find 查找：<span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span></li>
</ul>
<p>不仅是查找，map 们还支持高效的增删改查等操作。</p>
<hr />
<!-- PG16 -->

<h2 id="map">map 的逻辑结构</h2>
<p><img alt="logicmap" src="../img/stl/logicmap.png" /></p>
<p>特点：</p>
<ul>
<li>由一系列 <strong>键值对</strong> 组成</li>
<li>一个键只能对应一个值</li>
<li>键不得重复，值可以重复</li>
</ul>
<p><br/></p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> std::map, std::unordered_map, absl::flat_hash_map, tbb::concurrent_hash_map 都满足“键值对”这一基本逻辑结构，只是物理实现不同。</p>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 面壁者罗辑监督你的学习！</p>
</blockquote>
<p>在编程中我们常常需要用到“映射”的关系，这就非常需要用到以 map 为首的“键值对”这类容器了。</p>
<hr />
<h3 id="stdmap">为什么要学习 std::map</h3>
<p>map 的具体实现可以是红黑树、AVL 树、线性哈希表、链表哈希表、跳表……不同的实现在不同操作上的复杂度不同，分别适用于不同的场景。</p>
<p>用法上几乎是差不多的，他们都有着几乎相同的接口（除了部分扩展功能）。当你觉得红黑树的 std::map 不合适时，可以轻松把对象类型就地替换为链表哈希表 std::unordered_map 或是是线性哈希表 absl::flat_hash_map，而不用对其他代码有任何更改。</p>
<p>这就是所有 map 类容器都有着相同的<strong>逻辑结构</strong>：都是一个键-值映射，不同的只是他们的<strong>物理结构</strong>而已。</p>
<p>所有的 map 实现，都会模仿提供和 std::map 一样的 API。这就是为什么虽然 std::map 实现的很低效，我们还是要学他的原因。std::map 本身并不是完美的，但却提供了一个所有第三方都会遵循的统一接口。学会了 std::map，任何第三方库的 map 类容器你都可以轻易举一反三。</p>
<blockquote>
<p>不仅是各种第三方的 map 库，比如 rapidjson 库中的 JSON 对象，也提供了类似 std::map 的 <code>find</code> 和 <code>end</code> 迭代器接口：<code>MemberFind</code> 和 <code>MemberEnd</code>，来查找一个字典的子键；几何处理库 cgal 中的“顶点查找”功能也是基于类似的迭代器接口。总之，学会 std::map 将大大有助于你看懂这类业界公认的接口规范。</p>
</blockquote>
<hr />
<!-- PG17 -->

<h3 id="map_1">标准库中的 map 容器</h3>
<p>标准库中，map<sup id="fnref4:1"><a class="footnote-ref" href="#fn:1">1</a></sup> 是一个<strong>模板类</strong>，他的键类型，值类型，可以由尖括号内的参数指定，便于适应不同的用户需求。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 由于 C++ 标准库的容器大多都是模板类，提供的算法也大多是模板函数，因此 C++ 标准库常被称为标准模板库 (Standard-Template-Library, STL)。</p>
</blockquote>
<p>键类型和值类型可以是任意类型，包括基本类型，用户自定义的类，其他 STL 容器等，体现了容器的泛用性。</p>
<p>唯一的要求是：键必须支持比较，这里 map 要求的是小于运算符 <code>&lt;</code>。</p>
<ul>
<li>例如 <code>map&lt;string, int&gt;</code> 是一个键类型为 string，值类型为 int 的 map 容器。</li>
<li>例如 <code>map&lt;int, Student&gt;</code> 是一个键类型为 int，值类型为 Student 的 map 容器。</li>
<li>例如 <code>map&lt;char, vector&lt;int&gt;&gt;</code> 是一个键类型为 char，值类型为 <code>vector&lt;int&gt;</code> 的 map 容器。</li>
</ul>
<p>后面为了方便研究，以 <code>map&lt;K, V&gt;</code> 形式书写得出的结论，对于任何实际键和值类型，只需代入 K 和 V 即可。</p>
<blockquote>
<p>已知：要想使用 <code>map&lt;K, V&gt;</code>，就得满足 <code>K</code> 必须支持比较运算符 <code>&lt;</code>。</p>
<p>可得：要想使用 <code>map&lt;string, int&gt;</code>，就得满足 <code>string</code> 必须支持比较运算符 <code>&lt;</code><sup id="fnref4:2"><a class="footnote-ref" href="#fn:2">2</a></sup>。</p>
<p>已知：遍历 <code>map&lt;K, V&gt;</code> 时，是以键 <code>K</code> 部分从小到大的顺序遍历的。</p>
<p>可得：遍历 <code>map&lt;int, string&gt;</code> 时，是以键 <code>int</code> 部分从小到大的顺序遍历的。</p>
</blockquote>
<hr />
<!-- PG18 -->

<h2 id="map_2">map 的物理结构</h2>
<p><img alt="physmap" src="../img/stl/physmap.png" /></p>
<p>map 和 set 一样，都是基于红黑树的二叉排序树，实现 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度的高效查找。</p>
<p>vector 就是因为元素没有固定的顺序，所以才需要暴力遍历查找。</p>
<p>在持续的插入和删除操作下，始终维持元素的有序性，正是 map 实现高效查找的关键所在。</p>
<hr />
<!-- PG19 -->

<h3 id="_12">二叉排序树与二分法</h3>
<p>始终保存元素按键排序的好处是，如果需要寻找指定键值的元素，就可以采用二分法：</p>
<ol>
<li>从根节点开始查找。</li>
<li>如果当前节点的键小于要找的键，则往左子节点移动；</li>
<li>如果当前节点的键大于要找的键，则往左子节点移动；</li>
<li>如果当前节点的键等于要找的键，则该节点就是要找的节点，返回该节点。</li>
<li>如果当前节点已经是最后一层叶子节点，也没找到相等的键，则说明该键不存在。</li>
<li>把左/右子节点设为新的当前节点，然后回到第 2 步，重复这一查找过程。</li>
</ol>
<hr />
<h3 id="_13">二叉排序树</h3>
<!-- PG20 -->

<p>由于 map 的实现基于二叉排序树，map 额外有一个特点：<strong>有序</strong>。</p>
<p>map (或 set) 中的键 K 总是从小到大排列，方便进行二分查找，在 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 时间内找到对应元素。</p>
<p>每次插入新的键时，会找到适当的插入位置，使得插入后的 map 仍然有序。</p>
<blockquote>
<p>注：基于哈希散列表实现的 unordered_map (和 unordered_set)，就不具备<strong>有序</strong>这一特点。</p>
</blockquote>
<p><img alt="sortedset" src="../img/stl/sortedset.png" /></p>
<hr />
<!-- PG21 -->

<p><img alt="setvsmap" src="../img/stl/setvsmap.png" /></p>
<p>两者的区别在于：map 在 K 之外，额外外挂了一个 V 类型。</p>
<p>map 中的 V 类型不参与排序，只按照 K 进行排序。</p>
<p>这样当用户根据 K 找到的是 K-V 对，然后可以取出 K 对应的 V。</p>
<p>这就实现了从 K 到 V 的映射。</p>
<h3 id="_14">二叉树退化问题</h3>
<p>二叉排序树只解决了查找的问题，但是他并不能保证经历一通插入后的树不会“退化”。</p>
<p>如果插入的时候不小心，可能会让树的形状变得非常诡异！</p>
<p>例如，若插入数据的顺序是从小到大的，那就会一直在往右插入，清一色的一边倒，以至于几乎成了一根往右跑的链表。</p>
<p>如果插入顺序是从大到小，就变成一直往左边倒。即使插入的顺序不那么刻意，依然可能产生非常变态的形状，违背了二叉树的初衷。</p>
<p><img alt="binary_tree_best_worst_cases" src="../img/stl/binary_tree_best_worst_cases.png" /></p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 哥俩生异形呢？</p>
</blockquote>
<p>这样“退化”的二叉排序树，虽然能保持有序，但二分查找时就起不到加速作用了。</p>
<p>如果要找一个中间的元素，几乎就和链表一样，需要遍历整个右枝干。</p>
<p>为了限制二叉排序树不要长成畸形，我们引入一个指标：“深度”，表示从根节点到最底层叶子节点的距离。</p>
<p>要最大化二分查找的效率，就需要二叉树的深度尽可能的低。</p>
<p>因为二分查找的次数就取决于每个叶子节点的平均深度，要尽可能减少平均需要访问的次数，就是要减少二叉树的深度。</p>
<p>也就是说要让大家都尽可能贴近根部，但我们不可能让所有叶子都最贴近根部。</p>
<p>例如右侧只有一个叶子节点，他自己是深度最低了，但代价是左边全部挤在一条链表上了！这不公平。</p>
<p><img alt="binary_tree_almost_worst_case" src="../img/stl/binary_tree_almost_worst_case.png" /></p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 它自己倒是自由了，但它奴役了所有的人民</p>
</blockquote>
<p><img alt="slave-all" src="../img/stl/slave-all.jpg" /></p>
<p>所以要最大化二分查找的效率，我们真正需要的是让所有叶子节点都尽可能“平等”！</p>
<h3 id="vs">红黑树 vs 平衡树</h3>
<p>为了避免二叉树长成畸形，陷入一边倒的情况。我们需要在每次插入后，检查二叉树是否深度差距过大。</p>
<p>如果差的太多了，就需要进行一系列矫正操作，“劫富济贫”，把太长的枝干砍断，接在短的地方，尽可能保持所有叶子路径的深度差不多，这个“劫富济贫”的动作就是<strong>平衡操作 (balancing)</strong>。</p>
<p>问题是，最大能容忍叶子节点之间多大的深度差才开始矫正？针对这个问题，二叉排序树分为两派：</p>
<h4 id="_15">平衡树</h4>
<p>最理想的情况下，一颗含有 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 个节点的二叉树，至少需要有 <span class="arithmatex"><span class="MathJax_Preview">\lceil \log N \rceil</span><script type="math/tex">\lceil \log N \rceil</script></span> 深度。</p>
<p>这就是平衡树（AVL），他强制保证整个树处于完美的平衡状态，每个叶子节点之间的深度差距不会超过 1（当节点数量 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 不是 2 的整数倍时，这是不得不存在的 1 格差距）。</p>
<p><img alt="balanced_binary_tree" src="../img/stl/balanced_binary_tree.png" /></p>
<ul>
<li>优点：始终保持最完美的平衡，平均复杂度和最坏复杂度最低。所以平衡树的查找性能是最好的。</li>
<li>缺点：然而始终保持完美的平衡意味着，几乎每插入一个元素（可能会突然产生深度差距超过 1 的情况），就立即需要平衡一次。平衡一次的开销是比较大的，所以平衡树的性能是插入性能是比较差的。</li>
</ul>
<p>平衡树实现平衡的方式是“旋转”，他能始终保持最低的深度差：</p>
<p><img alt="avltree_right_rotate_with_grandchild" src="../img/stl/avltree_right_rotate_with_grandchild.png" /></p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 这里的细节我们不会深究，那是数据结构课的内容，届时会带大家手搓平衡树和红黑树，本期只是稍微了解 map 常见的底层实现，帮助你理解为什么 map 是有序容器。</p>
</blockquote>
<h4 id="_16">红黑树</h4>
<p>而红黑树认为，我们不需要总是保持深度差距为 1 那么小，我们只需要保证最深叶子和最浅叶子的深度差不超过 2 倍即可。</p>
<p>例如最浅的一个叶子是 6 深度，另一个最深的叶子可以是 12 深度。只有当最深的叶子超过 12 深度时，红黑树才会开始主动干预平衡，避免继续畸形发展下去。</p>
<ul>
<li>缺点：树可能有一定的一边倒情况，平均复杂度稍微降低，最坏复杂度可以达到原来的 2 倍！</li>
<li>优点：因为对不平衡现象更加宽松，正常插入时基本不需要平衡，只有特别扭曲了才会下场“救急”。所以红黑树是牺牲了一部分查找性能，换取了更好的插入和删除性能。</li>
</ul>
<p>总之，如果你的用况是插入比较少，但是查询非常多，那就适合用平衡树。</p>
<p>由于换来的这部分插入和删除性能实际上比损失的查找性能多，而 map 常见的用况确实需要经常增删改查，所以现在 C++ 标准库的 map 底层都是基于红黑树实现的。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 如果你的需求是大量查找的话，完全可以考虑用查找平均复杂度低至 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的哈希表 unordered_map。</p>
<p><img src="../img/book.png" height="30px" width="auto" style="margin: 0; border: none"/> 如果是一次性插入完毕后不会再修改，还可以用完美哈希表（frozen_map），他会为你的键值序列专门生成一个专用的哈希函数，编译期确定，且保证完全无冲突。例如你在做一种语言编译器，有很多“关键字”，比如“if”、“while”，你需要运行时频繁的查找这些关键字，而关键字有哪些在编译期是固定的，那就很适合用完美哈希。</p>
</blockquote>
<h4 id="_17">红黑树实现平衡的秘密</h4>
<p>红黑树是如何保证最深叶子和最浅叶子的深度差不超过 2 倍的呢？</p>
<p>他设定了这样 5 条规则：</p>
<ol>
<li>节点可以是红色或黑色的。</li>
<li>根节点总是黑色的。</li>
<li>所有叶子节点都是黑色（叶子节点就是 NULL）。</li>
<li>红色节点的两个子节点必须都是黑色的。</li>
<li>从任一节点到其所有叶子节点的路径都包含相同数量的黑色节点。</li>
</ol>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 什么规则类怪谈……</p>
</blockquote>
<p>看起来好像很复杂，但实际上大多是废话，有用的只是 4 和 5 这两条。</p>
<p>规则 4 翻译一下就是：不得出现相邻的红色节点（相邻指两个节点是父子关系）。这条规则还有一个隐含的信息：黑色节点可以相邻！</p>
<p>规则 5 翻译一下就是：从根节点到所有底层叶子的距离（以黑色节点数量计），必须相等。</p>
<p>因为规则 4 的存在，红色节点不可能相邻，也就是说最深的枝干只能是：红-黑-红-黑-红-黑-红-黑。</p>
<p>结合规则 5 来看，也就是说每条枝干上的黑色节点数量必须相同，因为最深的枝干是 4 个黑节点了，所以最浅的枝干至少也得有 4 个节点全是黑色的：黑-黑-黑-黑。</p>
<p>可以看到，规则 4 和规则 5 联合起来实际上就保证了：最深枝干的深度不会超过最浅枝干的 2 倍。</p>
<p><img alt="Red-black_tree_example" src="../img/stl/Red-black_tree_example.svg.png" /></p>
<p>如果超出了 2 倍，就不得不破坏红黑树的规则 4 或 5，从而触发“劫富济贫”的平衡操作，从而阻止了二叉树过于畸形化。</p>
<p>红黑树如何实现“劫富济贫”的细节我们就不再多谈了，小彭老师点到为止，接下来直接进入正题：</p>
<hr />
<h2 id="map_3">开始使用 map 容器</h2>
<!-- PG22 -->

<p>创建一个 map 对象：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config;
</code></pre>
<p>一开始 map 初始是空的，如何插入一些初始数据？</p>
<pre><code class="language-cpp">config[&quot;timeout&quot;] = 985;
config[&quot;delay&quot;] = 211;
</code></pre>
<p>数据插入成功了，根据键查询对应的值？</p>
<pre><code class="language-cpp">print(config[&quot;timeout&quot;]);
print(config[&quot;delay&quot;]);
</code></pre>
<p>查询时建议用 <code>.at(key)</code> 而不是 <code>[key]</code>：</p>
<pre><code class="language-cpp">print(config.at(&quot;timeout&quot;));
print(config.at(&quot;delay&quot;));
</code></pre>
<hr />
<!-- PG23 -->

<p>老生常谈的问题：map 中存 string 还是 const char *？</p>
<pre><code class="language-cpp">map&lt;const char *, const char *&gt; m;
m[&quot;hello&quot;] = &quot;old&quot;;    // 常量区的 &quot;hello&quot;
char key[] = &quot;hello&quot;;  // key 的地址在栈上
print(key == &quot;hello&quot;); // false
m[key] = &quot;new&quot;;        // 栈上变量的 key = &quot;hello&quot;
print(m);              // 两个重复的键 &quot;hello&quot;
</code></pre>
<pre><code>false
{hello: old, hello: new}
</code></pre>
<p>在 C++ 中，任何时候都务必用 string！别用 C 语言老掉牙的 const char *，太危险了。</p>
<p>const char * 危险的原因：</p>
<ol>
<li>const char * 的 == 判断的是指针的相等，两个 const char * 只要地址不同，即使实际的字符串相同，也不会被视为同一个元素（如上代码案例所示）。导致 map 里会出现重复的键，以及按键查找可能找不到等。</li>
<li>保存的是弱引用，如果你把局部的 char [] 或 string.c_str() 返回的 const char * 存入 map，等这些局部释放了，map 中的 const char * 就是一个空悬指针了，会造成 segfault。</li>
</ol>
<hr />
<!-- PG24 -->

<p>请用安全的 string：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
m[&quot;hello&quot;] = &quot;old&quot;;
string key = &quot;hello&quot;;
m[key] = &quot;new&quot;;
print(m);
print(key == &quot;hello&quot;);  // string 的 == 运算符是经过重载的，比较的是字符串里面的内容相等，而不是地址相等
</code></pre>
<pre><code>{&quot;hello&quot;: &quot;new&quot;}
true
</code></pre>
<table>
<thead>
<tr>
<th>描述</th>
<th>C++</th>
<th>Java</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容相等</td>
<td><code>string("hello") == string("hello")</code></td>
<td><code>"hello".equals("hello")</code></td>
<td><code>'hello' == 'hello'</code></td>
</tr>
<tr>
<td>地址相等</td>
<td><code>"hello" == "hello"</code></td>
<td><code>"hello" == "hello"</code></td>
<td><code>id('hello') == id('hello')</code></td>
</tr>
</tbody>
</table>
<hr />
<!-- PG25 -->

<p>如果你精通对象生命周期分析，能保证 key 指向的字符串活的比 m 久，想要避免拷贝，节省性能。</p>
<p>string 的弱引用版本：string_view，同样可以用封装了正确的 == 运算符，会比较字符串内容而不是地址：</p>
<pre><code class="language-cpp">map&lt;string_view, string_view&gt; m;
m[&quot;hello&quot;] = &quot;old&quot;;
string_view key = &quot;hello&quot;;
m[key] = &quot;new&quot;;
print(m);
print(key == &quot;hello&quot;);
// 此处 m 是栈上变量，key 是弱引用指向全局常量区（rodata），key 比 m 活得久，没有空悬指针问题
</code></pre>
<pre><code>{&quot;hello&quot;: &quot;new&quot;}
true
</code></pre>
<p>⚠️ string_view 属于不建议初学者使用的优化小寄巧：有手之前，非常好用。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 注：map 实际上完全没有用到 ==，用到的只有 &lt; 运算符，当需要判定 <code>a == b</code> 时，他会转而用 <code>!(a &lt; b || b &lt; a)</code> 来判定。</p>
</blockquote>
<p><br/></p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> string_view 也具有正确的 <code>hash&lt;string_view&gt;</code> 特化，因此也可以用做 unordered_map 的键类型。string_view 试图和 string 表现得完全一样，区别在于他是个弱引用，不持有对象，拷贝构造函数是浅拷贝。string_view 大小只有 16 个字节，内部是一个 const char * 和 size_t，但封装了正确的 ==，&lt;，&gt; 和 hash。</p>
</blockquote>
<hr />
<!-- PG26 -->

<p>C++11 新特性——花括号初始化列表，允许创建 map 时直接指定初始数据：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = { {&quot;timeout&quot;, 985}, {&quot;delay&quot;, 211} };
</code></pre>
<p>通常我们会换行写，一行一个键值对，看起来条理更清晰：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};

print(config.at(&quot;timeout&quot;));  // 985
</code></pre>
<hr />
<!-- PG27 -->

<p>总结花括号初始化语法：</p>
<pre><code class="language-cpp">map&lt;K, V&gt; m = {
    {k1, v1},
    {k2, v2},
    ...,
};
</code></pre>
<p>让 map 初始就具有这些数据。</p>
<hr />
<!-- PG28 -->

<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
</code></pre>
<p>等号可以省略（这其实相当于是在调用 map 的构造函数）：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config{
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
</code></pre>
<p>也可以先构造再赋值给 auto 变量：</p>
<pre><code class="language-cpp">auto config = map&lt;string, int&gt;{
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
</code></pre>
<p>都是等价的。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 关于构造函数、花括号列表的具体语法可以参考我的《高性能并行》系列第二课：https://www.bilibili.com/video/BV1LY411H7Gg。在 <a href="../cpp_tricks/">C++ 小妙招</a> 一章中也有介绍。</p>
</blockquote>
<hr />
<!-- PG29 -->

<p>作为函数参数时，可以用花括号初始化列表就地构造一个 map 对象：</p>
<pre><code class="language-cpp">void myfunc(map&lt;string, int&gt; config);  // 函数声明

myfunc(map&lt;string, int&gt;{               // 直接创建一个 map 传入
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
});
</code></pre>
<p>由于 <code>myfunc</code> 函数具有唯一确定的重载，要构造的参数类型 <code>map&lt;string, int&gt;</code> 可以省略不写：</p>
<pre><code class="language-cpp">myfunc({
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
});
</code></pre>
<p>函数这边，通常还会加上 <code>const &amp;</code> 修饰避免不必要的拷贝。</p>
<pre><code class="language-cpp">void myfunc(map&lt;string, int&gt; const &amp;config);
</code></pre>
<hr />
<!-- PG30 -->

<p>从 vector 中批量导入键值对：</p>
<pre><code class="language-cpp">vector&lt;pair&lt;string, int&gt;&gt; kvs = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
map&lt;string, int&gt; config(kvs.begin(), kvs.end());
</code></pre>
<p>与刚刚花括号初始化的写法等价，只不过是从现有的 vector 中导入。同样的写法也适用于从 array 导入。</p>
<blockquote>
<p>如果记不住这个写法，也可以自己手写 for 循环遍历 vector 逐个逐个插入 map，效果是一样的。</p>
</blockquote>
<p>冷知识，如果不是 vector 或 array，而是想从传统的 C 语言数组中导入：</p>
<pre><code class="language-cpp">pair&lt;string, int&gt; kvs[] = {  // C 语言原始数组
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
map&lt;string, int&gt; config(kvs, kvs + 2);                    // C++98
map&lt;string, int&gt; config(std::begin(kvs), std::end(kvs));  // C++17
</code></pre>
<blockquote>
<p>其中 <code>std::begin</code> 和 <code>std::end</code> 为 C++17 新增函数，专门用于照顾没法有成员函数 <code>.begin()</code> 的 C 语言数组。类似的全局函数还有 <code>std::size</code> 和 <code>std::data</code> 等……他们都是既兼容 STL 容器也兼容 C 数组的。</p>
</blockquote>
<hr />
<!-- PG31 -->

<p>重点来了：如何根据键查询相应的值？</p>
<p>很多同学都知道 map 具有 [] 运算符重载，[] 里写要查询的键就可以返回对应值，也可以用 = 往里面赋值，和某些脚本语言一样直观易懂。</p>
<pre><code class="language-cpp">config[&quot;timeout&quot;] = 985;       // 把 config 中键 timeout 对应值设为 985
auto val = config[&quot;timeout&quot;];  // 读取 config 中键 timeout 对应值
print(val);                    // 985
</code></pre>
<p>但其实用 [] 去<strong>读取元素</strong>是很不安全的，下面我会做实验演示这一点。</p>
<hr />
<!-- PG32 -->

<p>沉默的 []，无言的危险：当键不存在时，会返回 0 而不会出错！</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
print(config[&quot;timeout&quot;]); // 985
print(config[&quot;tmeout&quot;]);  // 默默返回 0
</code></pre>
<pre><code>985
0
</code></pre>
<p>当查询的键值不存在时，[] 会默默创建并返回 0，而不会爆出任何错误。</p>
<p>这非常危险，例如一个简简单单的拼写错误，就会导致 map 的查询默默返回 0，你还在那里找了半天摸不着头脑，根本没发现错误原来在 map 这里。</p>
<hr />
<!-- PG33 -->

<p>爱哭爱闹的 at()，反而更讨人喜欢</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
print(config.at(&quot;timeout&quot;));  // 985
print(config.at(&quot;tmeout&quot;));   // 该键不存在！响亮地出错
</code></pre>
<pre><code>985
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted (core dumped)
</code></pre>
<p>有经验的老手都明白一个道理：<strong>及时奔溃</strong>比<strong>容忍错误</strong>更有利于调试。即 fail-early, fail-loudly<sup id="fnref5:1"><a class="footnote-ref" href="#fn:1">1</a></sup> 原则。</p>
<p>例如 JS 和 Lua 的 [] 访问越界不报错而是返回 undefined / nil，导致实际出错的位置在好几十行之后，无法定位到真正出错的位置，这就是为什么后来发明了错误检查更严格的 TS。</p>
<p>使用 at() 可以帮助你更容易定位到错误，是好事。</p>
<hr />
<!-- PG35 -->

<blockquote>
<p>在官方文档和各种教学课件中，都会展示一个函数的“原型”来讲解。</p>
<p>原型展现了一个函数的名称，参数类型，返回类型等信息，掌握了函数的原型就等于掌握了函数的调用方法。</p>
<p>本课程后面也会大量使用，现在来教你如何看懂成员函数的原型。</p>
</blockquote>
<p>假设要研究的类型为 <code>map&lt;K, V&gt;</code>，其中 K 和 V 是模板参数，可以替换成你具体的类型。</p>
<p>例如当我使用 <code>map&lt;string, int&gt;</code> 时，就把下面所有的 K 替换成 string，V 替换成 int。</p>
<p><code>map&lt;K, V&gt;</code> 的 [] 和 at 员函数，原型如下：</p>
<pre><code class="language-cpp">V &amp;operator[](K const &amp;k);
V &amp;at(K const &amp;k);                   // 第一个版本的 at
V const &amp;at(K const &amp;k) const;       // 第二个版本的 at
</code></pre>
<p>可见 operator[] 只有一个版本，at 居然有名字相同的两个！这样不会发生冲突吗？</p>
<p>这是利用了 C++ 的“重载”功能，重载就是同一个函数有多个不同的版本，各个版本的参数类型不同。</p>
<hr />
<!-- PG36 -->

<blockquote>
<p>例如小彭老师打电话给 110，假如警察叔叔发现小彭老师报的案子是网络诈骗，那么他们会帮我转接到网警部门；假如发现小彭老师是被绑架了，那么他们可能会出动武警解救小彭老师。这就是 110 函数的两个重载，根据调用者传入的信息类型，决定要转给哪一个子部门。</p>
</blockquote>
<p>同理，编译器也是会根据调用时你传入的参数类型，决定要调用重载的哪一个具体版本。</p>
<ul>
<li>C 语言没有重载，函数名字相同就会发生冲突，编译器会当场报错。</li>
<li>C++ 支持重载，只有当函数名字相同，参数列表也相同时，才会发生冲突。</li>
<li>返回值类型不影响重载，重载只看参数列表。</li>
</ul>
<p>菜鸟教程上对 C++ 重载的解释<sup id="fnref6:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<blockquote>
<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
<p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>
</blockquote>
<hr />
<!-- PG37 -->

<pre><code class="language-cpp">V &amp;at(K const &amp;k);                   // 第一个版本的 at
V const &amp;at(K const &amp;k) const;       // 第二个版本的 at
</code></pre>
<p>但是上面这两个 at 函数的参数类型都是 <code>K const &amp;</code>，为什么可以重载呢？</p>
<p>注意看第二个版本最后面多了一个 const 关键字，这种写法是什么意思？小彭老师对其进行祛魅化：</p>
<pre><code class="language-cpp">V &amp;at(map&lt;K, V&gt; *this, K const &amp;k);                   // 第一个版本的 at
V const &amp;at(map&lt;K, V&gt; const *this, K const &amp;k);       // 第二个版本的 at
</code></pre>
<p>原来加在函数括号后面的 const，实际上是用于修饰 this 指针的！</p>
<blockquote>
<p>该写法仅供示意，并不是真的可以把 this 写成参数</p>
</blockquote>
<p>所以两个 at 的参数列表不同，不同在于传入 this 指针的类型，所以可以重载，不会冲突。</p>
<ul>
<li>当 map 对象为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; const *</code>，所以只能调用第二个版本的 at。</li>
<li>当 map 对象不为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; *</code>，两个重载都可以调用，但由于第一个重载更加符合，所以会调用第一个版本的 at。</li>
</ul>
<hr />
<!-- PG38 -->

<p>刚刚解释了函数重载，那么运算符重载呢？</p>
<p>因为原本 C 语言就有 [] 运算符，不过那只适用于原始指针和原始数组。而 C++ 允许也 [] 运算符支持其他用户自定义类型（比如 std::map），和 C 语言自带的相比就只有参数类型不同（一个是原始数组，一个是 std::map），所以和函数重载很相似，这就是运算符重载。</p>
<pre><code class="language-cpp">m[&quot;key&quot;];
</code></pre>
<p>会被编译器“翻译”成：</p>
<pre><code class="language-cpp">m.operator[](&quot;key&quot;);
</code></pre>
<p>以上代码并非仅供示意，是可以通过编译运行的。</p>
<blockquote>
<p>operator[] 虽然看起来很复杂一个关键字加特殊符号，其实无非就是个特殊的函数名，学过 Python 的童鞋可以把他想象成 <code>__getitem__</code>。</p>
</blockquote>
<pre><code class="language-cpp">V &amp;operator[](K const &amp;k);
</code></pre>
<p>结论：[] 运算符实际上是在调用 operator[] 函数。</p>
<blockquote>
<p>所有的所谓“运算符重载函数”实际上都是一个特殊的标识符，以<code>operator</code> + 运算符的形式，他们两个组成一个整体，你还可以试试 <code>string("hel").operator+("lo")</code>，和 <code>string("hel") + "lo"</code> 是等价的。</p>
</blockquote>
<hr />
<!-- PG39 -->

<p>因为 operator[] 这个成员函数后面没有 const 修饰，因此当 map 修饰为 const 时编译会不通过<sup id="fnref7:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<pre><code class="language-cpp">const map&lt;string, int&gt; config = {  // 此处如果是带 const &amp; 修饰的函数参数也是同理
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
print(config[&quot;timeout&quot;]);          // 编译出错
</code></pre>
<pre><code>/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp: In function ‘int main()’:
/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp:10:23: error: passing ‘const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, int&gt;’ as ‘this’ argument discards qualifiers [-fpermissive]
   10 | print(config[&quot;timeout&quot;]);
</code></pre>
<p>编译器说 discards qualifiers，意思是 map 有 const 修饰，但是 operator[] 没有。</p>
<p>这实际上就是在说：<code>map&lt;K, V&gt; const *this</code> 不能转换成 <code>map&lt;K, V&gt; *this</code>。</p>
<p>有 const 修饰的 map 作为 this 指针传入没 const 修饰的 operator[] 函数，是减少了修饰（discards qualifers）。</p>
<p>C++ 规定传参时只能增加修饰不能减少修饰：只能从 <code>map *</code> 转换到 <code>map const *</code> 而不能反之。</p>
<p>所以对着一个 const map 调用非 const 的成员函数 operator[] 就出错了，相比之下 at() 就可以在 const 修饰下编译通过。</p>
<hr />
<!-- PG34 -->

<p>为什么 operator[] 是非 const 修饰的呢？通常来说，一个成员函数不是 const，意味着他会<strong>就地修改 this 对象</strong>。</p>
<p>其实，operator[] 发现所查询的键值不存在时：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
print(config);
print(config[&quot;tmeout&quot;]);  // 有副作用！
print(config);
</code></pre>
<pre><code>{&quot;delay&quot;: 211, &quot;timeout&quot;: 985}
0
{&quot;delay&quot;: 211, &quot;timeout&quot;: 985, &quot;tmeout&quot;: 0}
</code></pre>
<p><strong>会自动创建那个不存在的键值！</strong></p>
<p>你以为你只是观察了一下 map 里的 &ldquo;tmeout&rdquo; 元素，却意外改变了 map 的内容，薛定谔直呼内行。</p>
<hr />
<!-- PG40 -->

<p>为什么把 [] 设计的这么危险？</p>
<p>既然已经有更安全的 .at()，为什么还要让 [] 继续存在呢？</p>
<pre><code class="language-cpp">map&lt;string, int&gt; config = {
    {&quot;delay&quot;, 211},
};
config.at(&quot;timeout&quot;) = 985;  // 键值不存在，报错！
config[&quot;timeout&quot;] = 985;     // 成功创建并写入 985
</code></pre>
<p>由上可见，当我们写入一个本不存在的键值的时候，恰恰需要 [] 的“自动创建”这一特性，这是 at() 所不具有的。</p>
<p>总结：读取时应该用 at() 更安全，写入时才需要用带有自动创建功能的 []。</p>
<blockquote>
<p>许多第三方库，例如 jsoncpp，他们的字典类型也使用类似的接口，at() 负责读，[] 负责写，分工明确！</p>
</blockquote>
<hr />
<!-- PG41 -->

<h1 id="_18">总结</h1>
<ul>
<li>读取元素时，统一用 at()</li>
<li>写入元素时，统一用 []</li>
</ul>
<pre><code class="language-cpp">auto val = m.at(&quot;key&quot;);
m[&quot;key&quot;] = val;
</code></pre>
<p>为什么其他语言比如 Python，只有一个 [] 就行了呢？而 C++ 需要两个？</p>
<ul>
<li>因为 Python 会检测 [] 位于等号左侧还是右侧，根据情况分别调用 <code>__getitem__</code> 或者 <code>__setitem__</code>。</li>
<li>C++ 编译器没有这个特殊检测，也检测不了，因为 C++ 的 [] 只是返回了个引用，并不知道 [] 函数返回以后，你是拿这个引用写入还是读取。为了保险起见他默认你是写入，所以先帮你创建了元素，返回这个元素的引用，让你写入。</li>
<li>而 Python 的引用是不能用 = 覆盖原值的，那样只会让变量指向新的引用，只能用 .func() 引用成员函数或者 += 才能就地修改原变量，这是 Python 这类脚本语言和 C++ 最本质的不同。</li>
<li>总而言之，我们用 C++ 的 map 读取元素时，需要显式地用 at() 告诉编译器我是打算读取。</li>
</ul>
<hr />
<p>[] 找不到就返回个“默认值”，其实也是很多语言的传统异能了，只有刚好 Python 比较对初学者友好，会自动判断你的 [] 是读取还是写入，如果是读取，当找不到键值时能友善的给你报错。</p>
<table>
<thead>
<tr>
<th>语言及其关联容器名</th>
<th>C++ map</th>
<th>Python dict</th>
<th>Lua table</th>
<th>JS HashMap</th>
<th>Java HashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>找不到键时的行为</td>
<td>默默返回 0</td>
<td>报错 KeyError</td>
<td>默默返回 nil</td>
<td>默默返回 undefined</td>
<td>.get()，默默返回 null</td>
</tr>
</tbody>
</table>
<p>其中 C++ 的 [] 最为恶劣，因为古代 C++ 中并没有一个 null 或 nil 之类的额外特殊常量。</p>
<p>[] 返回的必须是个具体的类型，由于 [] 不能报错，值的类型又千变万化，<code>map&lt;K, V&gt;</code> 的 [] 只能返回“V 类型默认构造函数创建的值”：对于 int 而言是 0，对于 string 而言是 &ldquo;&rdquo;（空字符串）。</p>
<blockquote>
<p>也正因如此，如果一个 <code>map&lt;K, V&gt;</code> 中的 V 类型没有默认构造函数，就无法使用 [] 了。看似美好的 [] 只是骗骗小彭友的面子工程，模棱两可，充满危险。高手都使用更专业的写入函数：insert 或 insert_or_assign 代替。这两个函数不需要默认构造函数，还更高效一些，稍后会详细介绍。</p>
</blockquote>
<hr />
<!-- PG43 -->

<p>at 与 [] 实战演练</p>
<p>我们现在的甲方是一个学校的大老板，他希望让我们管理学生信息，因此需要建立一个映射表，能够快速通过学生名字查询到相应的学生信息。思来想去 C++ 标准库中的 map 容器最合适。决定设计如下：</p>
<ul>
<li>键为学生的名字，string 类型。</li>
<li>值为一个自定义结构体，Student 类型，里面存放各种学生信息。</li>
</ul>
<p>然后自定义一下 Student 结构体，现在把除了名字以外的学生信息都塞到这个结构体里。</p>
<p>创建 <code>map&lt;string, Student&gt;</code> 对象，变量名为 <code>stus</code>，这个 map 就是甲方要求的学生表，成功交差。</p>
<pre><code class="language-cpp">struct Student {
    int id;             // 学号
    int age;            // 年龄
    string sex;         // 性别
    int money;          // 存款
    set&lt;string&gt; skills; // 技能
};

map&lt;string, Student&gt; stus;
</code></pre>
<hr />
<!-- PG44 -->

<p>现在小彭老师和他的童鞋们要进入这家学校了，让我们用 [] 大法插入他的个人信息：</p>
<pre><code class="language-cpp">stus[&quot;彭于斌&quot;] = Student{20220301, 22, &quot;自定义&quot;, {&quot;C&quot;, &quot;C++&quot;}};
stus[&quot;相依&quot;] = Student{20220301, 21, &quot;男&quot;, 2000, {&quot;Java&quot;, &quot;C&quot;}};
stus[&quot;樱花粉蜜糖&quot;] = Student{20220301, 20, &quot;女&quot;, 3000, {&quot;Python&quot;, &quot;CUDA&quot;}};
stus[&quot;Sputnik02&quot;] = Student{20220301, 19, &quot;男&quot;, 4000, {&quot;C++&quot;}};
</code></pre>
<p>由于 C++11 允许省略花括号前的类型不写，所以 Student 可以省略，简写成：</p>
<pre><code class="language-cpp">stus[&quot;彭于斌&quot;] = {20220301, 22, &quot;自定义&quot;, {&quot;C&quot;, &quot;C++&quot;}};
stus[&quot;相依&quot;] = {20220301, 21, &quot;男&quot;, 2000, {&quot;Java&quot;, &quot;C&quot;}};
stus[&quot;樱花粉蜜糖&quot;] = {20220301, 20, &quot;女&quot;, 3000, {&quot;Python&quot;, &quot;CUDA&quot;}};
stus[&quot;Sputnik02&quot;] = {20220301, 19, &quot;男&quot;, 4000, {&quot;C++&quot;}};
</code></pre>
<p>又由于 map 支持在初始化时就指定所有元素，我们直接写：</p>
<pre><code class="language-cpp">map&lt;string, Student&gt; stus = {
    {&quot;彭于斌&quot;, {20220301, 22, &quot;自定义&quot;, 1000, {&quot;C&quot;, &quot;C++&quot;}}},
    {&quot;相依&quot;, {20220301, 21, &quot;男&quot;, 2000, {&quot;Java&quot;, &quot;C&quot;}}},
    {&quot;樱花粉蜜糖&quot;, {20220301, 20, &quot;女&quot;, 3000, {&quot;Python&quot;, &quot;CUDA&quot;}}},
    {&quot;Sputnik02&quot;, {20220301, 19, &quot;男&quot;, 4000, {&quot;C++&quot;}}},
};
</code></pre>
<hr />
<!-- PG45 -->

<p>现在甲方要求添加一个“培训”函数，用于他们的 C++ 培训课。</p>
<p>培训函数的参数为字符串，表示要消费学生的名字。如果该名字学生不存在，则应该及时报错。</p>
<p>每次培训需要消费 2650 元，消费成功后，往技能 skills 集合中加入 &ldquo;C++&rdquo;。</p>
<pre><code class="language-cpp">void PeiXunCpp(string stuName) {
    auto stu = stus.at(stuName);  // 这是在栈上拷贝了一份完整的 Student 对象
    stu.money -= 2650;
    stu.skills.insert(&quot;C++&quot;);
}
</code></pre>
<p>然而，这样写是不对的！</p>
<p><code>stus.at(stuName)</code> 返回的是一个引用 <code>Student &amp;</code> 指向 map 中的学生对象。但是等号左侧，却是个不带任何修饰的 <code>auto</code>，他会被推导为 <code>Student</code>。如何从一个引用 <code>Student &amp;</code> 转换为具体的 <code>Student</code>？找不到 <code>Student(Student &amp;)</code>，但是找到了最接近的 <code>Student(Student const &amp;)</code> 函数（这是编译器自动生成的拷贝构造函数），因此我们拷贝了一份 map 中的学生对象，到栈上的 stu 变量，之后不论如何修改，修改的都是这个栈上对象，而不会对 map 中的学生对象产生任何影响。</p>
<p>结论：把引用保存到普通变量中，则引用会退化，造成深拷贝！不仅影响性能，还影响功能！stu 已经是一个独立的 Student 对象，对 stu 的修改已经不会影响到 stus.at(stuName) 指向的那个 Student 对象了。</p>
<p>此时你对这个普通变量的所有修改，都不会同步到 map 中的那个 Student 中去！</p>
<hr />
<!-- PG46 -->

<p>我们现在对相依童鞋进行 C++ 培训：</p>
<pre><code class="language-cpp">PeiXunCpp(&quot;相依&quot;);
print(stus.at(&quot;相依&quot;));
</code></pre>
<p>结果发现他的存款一分没少，也没学会 C++：</p>
<pre><code>{id: 20220302, age: 21, sex: &quot;男&quot;, money: 2000, skills: {&quot;C&quot;, &quot;Java&quot;}}
</code></pre>
<p>看来我们的修改没有在 map 中生效？原来是因为我们在 PeiXunCpp 函数里：</p>
<pre><code class="language-cpp">auto stu = stus.at(stuName);  // 在栈上拷贝了一份完整的 Student 对象
</code></pre>
<p>一不小心就用了“克隆人”技术！从学生表里的“相依1号”，克隆了一份放到栈上的“相依2号”！</p>
<p>然后我们扣了这个临时克隆人“相依2号”的钱，并给他培训 C++ 技术。</p>
<p>然而我们培训的是栈上的临时变量“相依2号”，克隆前的“相依1号”并没有受到培训，也没有扣钱。</p>
<p>然后呢？残忍的事情发生了！在小彭老师一通操作培训完“相依2号”后，我们把他送上断头台——析构了！</p>
<p>而这一切“相依1号”完全不知情，他只知道有人喊他做克隆，然后就回家玩 Java 去了，并没有培训 C++ 的记忆。</p>
<hr />
<!-- PG47 -->

<p>要防止引用退化成普通变量，需要把变量类型也改成引用！这种是浅拷贝，stu 和 stus.at(stuName) 指向的仍然是同一个 Student 对象。用 <code>auto</code> 捕获的话，改成 <code>auto &amp;</code> 就行。</p>
<pre><code class="language-cpp">void PeiXunCpp(string stuName) {
    auto &amp;stu = stus.at(stuName);  // 在栈上创建一个指向原 Student 对象的引用
    stu.money -= 2650;
    stu.skills.insert(&quot;C++&quot;);
}
</code></pre>
<pre><code>{id: 20220302, age: 21, sex: &quot;男&quot;, money: -650, skills: {&quot;C&quot;, &quot;C++&quot;, &quot;Java&quot;}}
</code></pre>
<p>终于，正版“相依1号”本体鞋废了 C++！</p>
<p>之后如果再从“相依1号”身上克隆，克隆出来的“相依n号”也都会具有培训过 C++ 的记忆了。</p>
<p>引用相当于身份证，我们复印了“相依”的身份证，身份证不仅复印起来比克隆一个大活人容易（拷贝开销）从而提升性能，而且通过身份证可以找到本人，对身份证的修改会被编译器自动改为对本人的修改，例如通过“相依”的身份证在银行开卡等，银行要的是身份证，不是克隆人哦。</p>
<hr />
<!-- PG48 -->

<p>引用是一个烫手的香香面包，普通变量就像一个臭臭的答辩马桶，把面包放到马桶（auto）里，面包就臭掉，腐烂掉，不能吃了！要让面包转移阵地了以后依然好吃，需要放到保鲜盒（auto &amp;）里。</p>
<p>这就是 C++ 的 decay（中文刚好是“退化”、“变质”的意思）规则。</p>
<p>以下都是“香香面包”，放进马桶里会变质：</p>
<ul>
<li><code>T &amp;</code> 会变质成 <code>T</code>（引用变质成普通变量）</li>
<li><code>T []</code> 会变质成 <code>T *</code>（数组变质成首地址指针）</li>
<li><code>T ()</code> 会变质成 <code>T (*)()</code>（函数变质成函数指针）</li>
</ul>
<p>在函数的参数中、函数的返回值中、auto 捕获的变量中，放入这些“香香面包”都会发生变质！</p>
<p>如何避免变质？那就不要用马桶（普通变量）装面包呗！用保鲜盒（引用变量）装！</p>
<ul>
<li>避免引用 <code>T &amp;t</code> 变质，就得把函数参数类型改成引用，或者用 <code>auto &amp;</code>，<code>auto const &amp;</code> 捕获才行。</li>
<li>避免原生数组 <code>T t[N]</code> 变质，也可以改成引用 <code>T (&amp;t)[N]</code>，但比较繁琐，不如直接改用 C++11 封装的安全静态数组 <code>array&lt;T, N&gt;</code> 或 C++98 就有的安全动态数组 <code>vector&lt;T&gt;</code>。</li>
<li>避免函数 <code>T f()</code> 变质，可以 <code>T (&amp;f)()</code>，但繁琐，不如直接改用 C++11 的函数对象 <code>function&lt;T()&gt;</code>。</li>
</ul>
<p><img alt="autodecays" src="../img/stl/autodecays.png" /></p>
<hr />
<!-- PG49 -->

<h3 id="c">C 语言的退化规则真是害人不浅</h3>
<p>题外话：邪恶的退化规则造成空悬指针的案例</p>
<pre><code class="language-cpp">typedef double arr_t[10];

auto func(arr_t val) {
    arr_t ret;
    memcpy(ret, val, sizeof(arr_t));  // 对 val 做一些运算, 把计算结果保存到 ret
    return ret;     // double [10] 自动变质成 double *
}

int main() {
    arr_t val = {1, 2, 3, 4};
    auto ret = func(val);             // 此处 auto 会被推导为 double *
    print(std::span(ret, ret + 10));
    return 0;
}
</code></pre>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 小时候看这集 <span class="arithmatex"><span class="MathJax_Preview">^{14}C</span><script type="math/tex">^{14}C</script></span> 语言“衰变”导致程序 Segmentation fault 了。</p>
</blockquote>
<p><img alt="u235decay" src="../img/stl/u235decay.webp" /></p>
<hr />
<!-- PG50 -->

<p>修复方法：别再用 C 语言的煞笔原始人数组了！用 C++ 封装好的 array，无隐患</p>
<pre><code class="language-cpp">typedef std::array&lt;double, 10&gt; arr_t;  // 如需动态长度，改用 vector 亦可

auto func(arr_t val) {
    arr_t ret;
    ret = val;  // 对 val 做一些运算, 把计算结果保存到 ret
    return ret;
}

int main() {
    arr_t val = {1, 2, 3, 4};
    auto ret = func(val);
    print(ret);
    return 0;
}
</code></pre>
<pre><code>{1, 2, 3, 4, 0, 0, 0, 0, 0, 0}
</code></pre>
<hr />
<!-- PG51 -->

<p>如果你还是学不会怎么保留香香引用的话，土办法：也可以在修改后再次用 [] 写回学生表。这样学生表里不会 C++ 的“相依1号”就会被我们栈上培训过 C++ 的“相依1号”覆盖，现在学生表里的也是有 C++ 技能的“相依”辣！只不过需要翻来覆去克隆了好几次比较低效而已，至少能用了，建议只有学不懂引用的童鞋再用这种保底写法。</p>
<pre><code class="language-cpp">void PeiXunCpp(string stuName) {
    auto stu = stus.at(stuName);  // 克隆了一份“相依2号”
    stu.money -= 2650;
    stu.skills.insert(&quot;C++&quot;);
    stus[stuName] = stu;          // “相依2号”夺舍，把“相依1号”给覆盖掉了
}
</code></pre>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 狂想：如果克隆“相依1号”同学，得到“相依2号”，然后把原来的杀……啊不对，“析构”掉，然后对外谎称“这还是原来的相依1号呀！”会不会被发现呢？</p>
</blockquote>
<p>脑筋急转弯：上面代码第 5 行也可以改用 at，为什么？小彭老师不是说 “at 用于读取，[] 用于写入” 吗？</p>
<p>我们童鞋要学会变通！小彭老师警告说 “[] 只能用于写入”，是因为我们平时的写入，实际上都是需要写入到一个不存在的元素，所以 [] 会自动创建元素就很方便；如果是 at() 就不符合“写入时自动创建不存在的键“。但是现在的情况是我们第 2 行已经访问过 <code>at("相依")</code>，那么就可以确认 <code>"相依"</code> 已经存在了，因此我写入的一定是个已经存在的元素，这时 [] 和 at 已经没区别了，所以用 at 的非 const 重载，一样可以写入。</p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 我们童鞋不是去死记硬背《小彭老师语录》，把小彭老师名言当做“两个凡是”圣经。要理解小彭老师会这么说的原因是什么，这样才能根据不同实际情况，实事求是看问题，才是符合小彭老师唯物编程观的（孝）</p>
</blockquote>
<hr />
<!-- PG52 -->

<p>如果要根据学号进行查找呢？那就以学号为键，然后把学生姓名放到 Student 结构体中。</p>
<p>如果同时有根据学号进行查找和根据姓名查找两种需求呢？</p>
<p>同时高效地根据多个键进行查找，甚至指定各种条件，比如查询所有会 C++ 的学生等，这可不是 map 能搞定的，或者说能搞定但不高效（最后往往只能暴力遍历查找，时间复杂度太高）。这是个专门的研究领域，称为：关系数据库。</p>
<p>关系数据库的实现有 MySQL，SQLite，MongoDB 等。C++ 等编程语言只需调用他们提供的 API 即可，不必自己手动实现这些复杂的查找和插入算法。</p>
<p>这就是为什么专业的“学生管理系统”都会用关系数据库，而不是自己手动维护一个 map。关系数据库底层的数据结构更复杂，但经过高度封装，效率更高，提供的功能也更全面，用起来也比较无感。何况 map 存在内存中，电脑一关机，学生数据就没了！而数据库可以把数据持久化到磁盘中，相当于在磁盘里构建出了一颗查找树，关机后数据依然保持。</p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 相依同学好不容易考出满分，结果小彭老师一不小心踢了一脚电脑，重启，全部学生档案丢失，白考！</p>
</blockquote>
<hr />
<!-- PG53 -->

<p>查询 map 中元素的数量</p>
<pre><code class="language-cpp">size_t size() const noexcept;
</code></pre>
<p>使用 <code>m.size()</code> 获得的 map 大小，或者说其中元素的数量。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m;
print(m.size()); // 0
m[&quot;fuck&quot;] = 985;
print(m.size()); // 1
m[&quot;dick&quot;] = 211;
print(m.size()); // 2
</code></pre>
<hr />
<!-- PG54 -->

<p>应用举例：给每个键一个独一无二的计数</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m;
m[&quot;fuck&quot;] = m.size();
m[&quot;dick&quot;] = m.size();
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 需要 C++17 以上的版本，才能保证等号右边的 <code>m.size()</code> 先于 <code>m["fuck"]</code> 求值。C++14 中上面这段代码行为未定义，需要改用 <code>m.insert({"fuck", m.size()})</code> 的写法（函数参数总是优先于函数求值，这保证 <code>m.size()</code> 先求值，然后才发生元素插入）。</p>
</blockquote>
<hr />
<!-- PG55 -->

<p>判断一个键是否存在：count 函数</p>
<pre><code class="language-cpp">size_t count(K const &amp;k) const;
</code></pre>
<p>count 返回容器中键和参数 k 相等的元素个数，类型为 size_t（无符号 64 位整数）。</p>
<p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p>
<p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p>
<hr />
<!-- PG56 -->

<p>因此可以直接通过 count 的返回值是否为 0 判断一个键在 map 中是否存在：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fuck&quot;, &quot;rust&quot;},
};
print(msg);
if (msg.count(&quot;fuck&quot;)) {
    print(&quot;存在fuck，其值为&quot;, msg.at(&quot;fuck&quot;));
} else {
    print(&quot;找不到fuck&quot;);
}
if (msg.count(&quot;dick&quot;)) {
    print(&quot;存在dick，其值为&quot;, msg.at(&quot;suck&quot;));
} else {
    print(&quot;找不到dick&quot;);
}
</code></pre>
<pre><code>{&quot;fuck&quot;: &quot;rust&quot;, &quot;hello&quot;: &quot;world&quot;}
存在fuck，其值为 &quot;rust&quot;
找不到dick
</code></pre>
<p>C++20 中建议改用返回类型为 <code>bool</code> 的 <code>contains</code> 函数，函数名和类型更加一目了然，但实际效果和 <code>count</code> 是一样的。</p>
<pre><code class="language-cpp">if (msg.contains(&quot;fuck&quot;)) {
    print(&quot;存在fuck，其值为&quot;, msg.at(&quot;fuck&quot;));
} else {
    print(&quot;找不到fuck&quot;);
}
</code></pre>
<!-- PG57 -->

<h2 id="_19">你知道吗？[] 的妙用</h2>
<p>除了写入元素需要用 [] 以外，还有一些案例中合理运用 [] 会非常的方便。</p>
<p>[] 的效果：当所查询的键值不存在时，会调用默认构造函数创建一个元素<sup id="fnref8:1"><a class="footnote-ref" href="#fn:1">1</a></sup>。</p>
<ul>
<li>对于 int, float 等数值类型而言，默认值是 0。</li>
<li>对于指针（包括智能指针）而言，默认值是 nullptr。</li>
<li>对于 string 而言，默认值是空字符串 &ldquo;&rdquo;。</li>
<li>对于 vector 而言，默认值是空数组 {}。</li>
<li>对于自定义类而言，会调用你写的默认构造函数，如果没有，则每个成员都取默认值。</li>
</ul>
<!-- PG58 -->

<h3 id="_20">[] 妙用举例：出现次数统计</h3>
<pre><code class="language-cpp">vector&lt;string&gt; input = {&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;};
map&lt;string, int&gt; counter;
for (auto const &amp;key: input) {
    counter[key]++;
}
print(counter);
</code></pre>
<pre><code>{&quot;hello&quot;: 2, &quot;world&quot;: 1}
</code></pre>
<!-- PG59 -->

<h4 id="_21">对比</h4>
<p>活用 [] 自动创建 0 元素的特性</p>
<pre><code class="language-cpp">map&lt;string, int&gt; counter;
for (auto const &amp;key: input) {
    counter[key]++;
}
</code></pre>
<p>古板的写法</p>
<pre><code class="language-cpp">map&lt;string, int&gt; counter;
for (auto const &amp;key: input) {
    if (!counter.count(key)) {
        counter[key] = 1;
    } else {
        counter[key] = counter.at(key) + 1;
    }
}
</code></pre>
<h3 id="_22">[] 妙用举例：归类</h3>
<pre><code class="language-cpp">vector&lt;string&gt; input = {&quot;happy&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;weak&quot;, &quot;strong&quot;};
map&lt;char, vector&lt;string&gt;&gt; categories;
for (auto const &amp;str: input) {
    char key = str[0];
    categories[key].push_back(str);
}
print(categories);
</code></pre>
<pre><code>{'h': {&quot;happy&quot;, &quot;hello&quot;}, 'w': {&quot;world&quot;, &quot;weak&quot;}, 's': {&quot;strong&quot;}}
</code></pre>
<h4 id="_23">对比</h4>
<p>活用 [] 自动创建&rdquo;默认值&rdquo;元素的特性</p>
<pre><code class="language-cpp">map&lt;char, vector&lt;string&gt;&gt; categories;
for (auto const &amp;str: input) {
    char key = str[0];
    categories[key].push_back(str);
}
print(categories);
</code></pre>
<p>古板的写法</p>
<pre><code class="language-cpp">map&lt;char, vector&lt;string&gt;&gt; categories;
for (auto const &amp;str: input) {
    char key = str[0];
    if (!categories.count(key)) {
        categories[key] = {str};
    } else {
        categories[key].push_back(str);
    }
}
</code></pre>
<!-- PG62 -->

<p><img alt="Elegence" src="https://pica.zhimg.com/50/v2-f2560f634b1e09f81522f29f363827f7_720w.jpg" /></p>
<h3 id="_24">[] 妙用举例：线程局部变量</h3>
<pre><code class="language-cpp">concurrent_map&lt;std::thread::id, Data&gt; tls;
parallel_for([] {
    Data &amp;data = tls[std::this_thread::get_id()];
    ...;
});
</code></pre>
<p>不过 <code>thread_local</code> 关键字，可以取代。</p>
<!-- PG63 -->

<h2 id="_25">为什么需要反向查找表</h2>
<p>反面典型：查找特定元素在 vector 中的位置（下标）</p>
<pre><code class="language-cpp">size_t array_find(vector&lt;string&gt; const &amp;arr, string const &amp;val) {
    for (size_t i = 0; i &lt; arr.size(); i++) {
        if (arr[i] == val) return i;
    }
    return (size_t)-1;
}
vector&lt;string&gt; arr = {&quot;hello&quot;, &quot;world&quot;, &quot;nice&quot;, &quot;day&quot;, &quot;fucker&quot;};
print(&quot;hello在数组中的下标是：&quot;, array_find(arr, &quot;fucker&quot;));    // O(N) 低效
print(&quot;nice在数组中的下标是：&quot;, array_find(arr, &quot;nice&quot;));       // O(N) 低效
</code></pre>
<p>每次调用 <code>array_find</code>，都需要 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度。</p>
<pre><code>fucker在数组中的下标是：0
nice在数组中的下标是：2
</code></pre>
<p>如果查询 N 次，则复杂度就是 <span class="arithmatex"><span class="MathJax_Preview">O(N^2)</span><script type="math/tex">O(N^2)</script></span>。</p>
<blockquote>
<p>注：假设 vector 中不存在重复的元素</p>
</blockquote>
<h3 id="map_4">map 构建下标查找表</h3>
<p>正确做法：构建 vector 的反向查找表，以后查找更高效</p>
<pre><code class="language-cpp">vector&lt;string&gt; arr = {&quot;hello&quot;, &quot;world&quot;, &quot;nice&quot;, &quot;day&quot;, &quot;fucker&quot;};
map&lt;string, size_t&gt; arrinv;
for (size_t i = 0; i &lt; arr.size(); i++) {                // O(N) 一次性受苦
    arrinv[arr[i]] = i;
}
print(&quot;反向查找表构建成功：&quot;, arrinv);
print(&quot;fucker在数组中的下标是：&quot;, arrinv.at(&quot;fucker&quot;));  // O(log N) 高效
print(&quot;nice在数组中的下标是：&quot;, arrinv.at(&quot;nice&quot;));      // O(log N) 高效
</code></pre>
<p>只有第一次构造反向查找表时，需要 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度。</p>
<p>以后每次调用 <code>map.at</code>，只需要 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度。</p>
<pre><code>反向查找表构建成功：{&quot;day&quot;: 3, &quot;fucker&quot;, 4, &quot;hello&quot;: 0, &quot;nice&quot;: 2, &quot;world&quot;: 1}
fucker在数组中的下标是：4
nice在数组中的下标是：2
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 轶事：在数据库中，这种反向查找表被称为“倒序索引”，小彭老师之前在不知道这个术语的情况下，独立产生了反向查找表的思想</p>
</blockquote>
<!-- PG65 -->

<pre><code class="language-cpp">for (size_t i = 0; i &lt; arr.size(); i++) {
    arrinv[arr[i]] = i;
}
</code></pre>
<p>提前构造好查找表 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>，以后每次查找只需要 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度就行。</p>
<ul>
<li>（正向查找）已知下标 i，求元素 v：<code>v = arr[i]</code></li>
<li>（反向查找）已知元素 v，求下标 i：<code>i = arrinv[v]</code></li>
</ul>
<p>如果查询 N 次，则复杂度就是 <span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span>，比优化前高效。</p>
<p>因此当需要多次查找且原数组保持不变时，强烈推荐用这种方法，更高效。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 只有当 vector 更新时，才需要重新构建 map。如果 vector 的删除采用 back-swap-erase（见 <a href="../cpp_tricks/">C++ 小妙招</a>），那么无需完全重构 map，只需更新 swap 的两个元素即可，总复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>，这样就实现了一个 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 的有下标又能快速查找数组，兼具 map 和 vector 的优势。在之后的数据结构进阶课中我们会详细介绍此类复合数据结构。</p>
</blockquote>
<h3 id="map-map">map 构建另一个 map 的反向查找表</h3>
<!-- PG66 -->

<p>map 只能通过值映射到键，能不能反过来通过键查找值？</p>
<p>案例：构建另一个 map 的反向查找表</p>
<pre><code class="language-cpp">map&lt;string, string&gt; tab = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fuck&quot;, &quot;rust&quot;},
};
map&lt;string, string&gt; tabinv;
for (auto const &amp;[k, v]: tab) {
    tabinv[v] = k;
}
print(tabinv);
</code></pre>
<p>效果就是，键变值，值变键，反一反，两个 map 互为逆运算：</p>
<pre><code>{&quot;rust&quot;: &quot;fuck&quot;, &quot;world&quot;: &quot;hello&quot;}
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 注意：要求 tab 中不能存在重复的值，键和值必须是一一对应关系，才能用这种方式构建双向查找表。否则一个值可能对应到两个键，反向表必须是 <code>map&lt;string, vector&lt;string&gt;&gt;</code> 了。</p>
</blockquote>
<hr />
<!-- PG67 -->

<h2 id="value_type">元编程查询成员类型：<code>value_type</code></h2>
<p>STL 容器的元素类型都可以通过成员 <code>value_type</code> 查询，常用于泛型编程（又称元编程）。</p>
<pre><code class="language-cpp">set&lt;int&gt;::value_type      // int
vector&lt;int&gt;::value_type   // int
string::value_type        // char
</code></pre>
<p>此外还有引用类型 <code>reference</code>，迭代器类型 <code>iterator</code>，常迭代器类型 <code>const_iterator</code> 等。</p>
<p>曾经在 C++98 中很常用，不过自从 C++11 有了 auto 和 decltype 以后，就不怎么用了，反正能自动推导返回类型。</p>
<p>C++23:</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;
for (auto const &amp;elem: arr) {
    std::println(&quot;{}&quot;, elem);
}
</code></pre>
<p>C++17:</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;
for (auto const &amp;elem: arr) {
    std::cout &lt;&lt; elem &lt;&lt; '\n';
}
</code></pre>
<p>C++11:</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;
for (auto it = arr.begin(); it != arr.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
<p>C++98:</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;
for (std::vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
<h3 id="typename">typename 修饰</h3>
<p>当容器有至少一个不确定的类型 T 作为模板参数时，就需要前面加上 <code>typename</code> 修饰了：</p>
<pre><code class="language-cpp">set&lt;int&gt;::value_type;               // 没有不定类型，不需要
typename set&lt;T&gt;::value_type;        // 包含有 T 是不定类型
typename set&lt;set&lt;T&gt;&gt;::value_type;   // 包含有 T 是不定类型
typename map&lt;int, T&gt;::value_type;   // 包含有 T 是不定类型
typename map&lt;K, T&gt;::value_type;     // 包含有 K、T 是不定类型
map&lt;int, string&gt;::value_type;       // 没有不定类型，不需要
</code></pre>
<p>如果你搞不清楚，始终加 <code>typename</code> 就行了，反正加多肯定不会有错。你就认为：这就是一个平时可以省略，偶尔不能省略的东西。</p>
<pre><code class="language-cpp">typename set&lt;int&gt;::value_type;    // 可以省略，但你加了也没关系
typename set&lt;T&gt;::value_type;      // 不能省略
typename set&lt;set&lt;T&gt;&gt;::value_type; // 不能省略
typename map&lt;int, T&gt;::value_type; // 不能省略
typename map&lt;K, T&gt;::value_type;   // 不能省略
typename map&lt;int, string&gt;::value_type; // 可以省略，但你加了也没关系
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 含有 T 的类型表达式称为 dependant-type，根本原因是因为在不知道具体是类型表达式还是值表达式的情况下，编译器无法区分模板的 <code>&lt;</code> 和小于符号 <code>&lt;</code>，以及类型的指针 <code>*</code> 和数值乘法 <code>*</code>。默认会认为是小于符号和数值乘法，加上 <code>typename</code> 后明确前面这一串是类型表达式，才知道这是模板的 <code>&lt;</code> 和指针的 <code>*</code>。</p>
</blockquote>
<h3 id="decltype">decltype 大法好</h3>
<p>也有更直观的获取 STL 容器元素类型的方法：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;

using T = std::decay_t&lt;decltype(arr[0])&gt;; // T = int
</code></pre>
<blockquote>
<p><img src="../img/warning.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>decltype</code> 必须配合 <code>std::decay_t</code> 才能用！否则会得到引用类型 <code>int &amp;</code>，后续使用中就坑到你！（因为 arr 的 [] 返回的是一个引用类型）</p>
</blockquote>
<pre><code class="language-cpp">// 错误示范
using T = decltype(arr[0]); // T = int &amp;

T i = 0; // int &amp;i = 0; 后续使用中编译出错！
</code></pre>
<hr />
<!-- PG68 -->

<h3 id="_26">查询类名小工具</h3>
<p>在本课程的案例代码中附带的 &ldquo;cppdemangle.h&rdquo;，可以实现根据指定的类型查询类型名称并打印出来。</p>
<p>跨平台，需要 C++11，支持 MSVC，Clang，GCC 三大编译器，例如：</p>
<pre><code class="language-cpp">int i;
print(cppdemangle&lt;decltype(std::move(i))&gt;());
print(cppdemangle&lt;std::string&gt;());
print(cppdemangle&lt;std::wstring::value_type&gt;());
</code></pre>
<p>在我的 GCC 12.2.1 上得到：</p>
<pre><code>&quot;int &amp;&amp;&quot;
&quot;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&quot;
&quot;wchar_t&quot;
</code></pre>
<hr />
<!-- PG69 -->

<h3 id="map_5">map 真正的元素类型究竟是什么？</h3>
<p>map 具有三个成员类型<sup id="fnref9:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<ul>
<li>元素类型：<code>value_type</code></li>
<li>键类型：<code>key_type</code></li>
<li>值类型：<code>mapped_type</code></li>
</ul>
<p>后面，将会一直以“元素”称呼官方的“value”，“键”称呼官方的“key”，“值”称呼官方的“mapped”</p>
<p>用 cppdemangle 做实验，看看这些成员类型具体是什么吧：</p>
<pre><code class="language-cpp">map&lt;int, float&gt;::value_type   // pair&lt;const int, float&gt;
map&lt;int, float&gt;::key_type     // int
map&lt;int, float&gt;::mapped_type  // float
</code></pre>
<p>结论：<code>map&lt;K, V&gt;</code> 的元素类型是 <code>pair&lt;const K, V&gt;</code> 而不是 <code>V</code>。</p>
<hr />
<!-- PG70 -->

<p>疑惑：<code>pair&lt;const K, V&gt;</code> 中，为什么 K 要加 const？</p>
<p>我们在 set 课中说过，set 内部采用红黑树数据结构保持有序，这样才能实现在 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 时间内高效查找。</p>
<p>键值改变的话会需要重新排序，如果只修改键值而不重新排序，会破坏有序性，导致二分查找结果错误！所以 set 只提供了不可变迭代器（const_iterator），没有可变的迭代器，不允许用户修改任何元素的值。</p>
<p>map 和 set 一样也是红黑树，不同在于：map 只有键 K 的部分会参与排序，V 是个旁观者，随便修改也没关系。</p>
<p>所以 map 有可变迭代器，只是在其值类型 value_type 中给键的部分，K，加上了 const 修饰：不允许修改 K，但可以随意修改 V。</p>
<p>如果你确实需要修改键值，那么请先取出旧值，把这个键删了，然后再以同样的值重新插入一遍到新的键。相当于重新构建了一个 <code>pair&lt;const K, V&gt;</code> 对象。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> C++17 开始也可以用更高效 <code>node_handle</code> 系列 API，避免数据发生移动，稍后介绍。</p>
</blockquote>
<hr />
<!-- PG71 -->

<pre><code class="language-cpp">iterator begin();
const_iterator begin() const;
iterator end();
const_iterator end() const;
</code></pre>
<p>begin() 和 end() 迭代器分别指向 map 的首个元素和最后一个元素的后一位。</p>
<p>其中 end() 迭代器指向的地址为虚空索敌，不可解引用，仅仅作为一个“标志”存在（回顾之前 vector 课）。</p>
<hr />
<!-- PG72 -->

<ul>
<li>迭代器可以通过 <code>*it</code> 或 <code>it-&gt;</code> 解引用，获取其指向的元素。</li>
<li>由于 map 内部总是保持有序，map 的首个元素一定是键最小的元素。</li>
<li>由于 map 内部总是保持有序，map 的最后一个元素一定是键最大的元素。</li>
</ul>
<p>例如要查询成绩最好和最坏的学生，可以把成绩当做 key，学生名做 value 依次插入 map，他会帮我们排序：</p>
<pre><code class="language-cpp">map&lt;int, string&gt; score = {
    {100, &quot;彭于斌&quot;},
    {80, &quot;樱花粉蜜糖&quot;},
    {0, &quot;相依&quot;},
    {60, &quot;Sputnik02&quot;},
};
string poorestStudent = score.begin()-&gt;second;   // 成绩最差学生的姓名
string bestStudent = prev(score.end())-&gt;second;  // 成绩最好学生的姓名
print(&quot;最低分:&quot;, poorestStudent);
print(&quot;最高分:&quot;, bestStudent);
</code></pre>
<pre><code>最低分: &quot;相依&quot;
最高分: &quot;彭于斌&quot;
</code></pre>
<blockquote>
<p>注：仅当确保 <code>score.size() != 0</code> 时才可以解引用，否则 begin() 和 end() 都是虚空迭代器，这时解引用会奔溃。</p>
</blockquote>
<hr />
<!-- PG73 -->

<p>map 的遍历：古代 C++98 的迭代器大法</p>
<pre><code class="language-cpp">for (map&lt;string, int&gt;::iterator it = m.begin(); it != m.end(); ++it) {
    print(&quot;Key:&quot;, it-&gt;first);
    print(&quot;Value:&quot;, it-&gt;second);
}
</code></pre>
<p>要特别注意迭代器是一个指向元素的指针，不是元素本身！要用 <code>-&gt;</code> 而不是 <code>.</code>。</p>
<hr />
<!-- PG74 -->

<p>运用 C++11 的 auto 简写一下：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    print(&quot;Key:&quot;, it-&gt;first);
    print(&quot;Value:&quot;, it-&gt;second);
}
</code></pre>
<p>运用 C++17 结构化绑定（structured-binding）语法<sup id="fnref10:1"><a class="footnote-ref" href="#fn:1">1</a></sup>直接拆开 pair 类型：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto [k, v] = *it;
    print(&quot;Key:&quot;, k);
    print(&quot;Value:&quot;, v);
}
</code></pre>
<hr />
<!-- PG75 -->

<p>map 的遍历：现代 C++17 基于范围的循环（range-based loop）</p>
<pre><code class="language-cpp">for (auto kv: m) {
    print(&quot;Key:&quot;, kv.first);
    print(&quot;Value:&quot;, kv.second);
}
</code></pre>
<p>同时运用 C++17 结构化绑定语法<sup id="fnref11:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<pre><code class="language-cpp">for (auto [k, v]: m) {
    print(&quot;Key:&quot;, k);
    print(&quot;Value:&quot;, v);
}
</code></pre>
<hr />
<!-- PG76 -->

<p>如何在遍历的过程中修改值？</p>
<p>古代：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
    {&quot;rust&quot;, 211},
};
for (auto it = m.begin(); it != m.end(); ++it) {
    it-&gt;second = it-&gt;second + 1;
}
print(m);
</code></pre>
<pre><code>{&quot;fuck&quot;: 986, &quot;rust&quot;: 212}
</code></pre>
<hr />
<!-- PG77 -->

<p>如何在遍历的过程中修改值？</p>
<p>现代：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
    {&quot;rust&quot;, 211},
};
for (auto [k, v]: m) {
    v = v + 1;
}
print(m);
</code></pre>
<pre><code>{&quot;fuck&quot;: 985, &quot;rust&quot;: 211}
</code></pre>
<p>没有成功修改！为什么？</p>
<hr />
<!-- PG78 -->

<pre><code class="language-cpp">for (auto [k, v]: m) {
    v = v + 1;
}
</code></pre>
<p>Range-based loop 只是个花哨语法糖，他相当于：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto [k, v] = *it;
    v = v + 1;
}
</code></pre>
<p>Structured-binding 也只是个花哨语法糖，他相当于：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto tmp = *it;
    auto k = tmp.first;
    auto v = tmp.second;
    v = v + 1;
}
</code></pre>
<p>这样保存下来的 v 是个栈上变量，是对原值的一份拷贝，不仅浪费性能，且对 v 的修改不会反映到原 map 中去！</p>
<hr />
<!-- PG79 -->

<pre><code class="language-cpp">for (auto &amp;[k, v]: m) {  // 解决方案是在这里加一个小小的 &amp;，让 range-based loop 捕获引用而不是拷贝
    v = v + 1;
}
</code></pre>
<p>同样是拆除 Range-based loop 的花哨语法糖，相当于：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto &amp;[k, v] = *it;
    v = v + 1;
}
</code></pre>
<p>继续拆除 Structured-binding 的花哨语法糖，相当于：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto &amp;tmp = *it;
    auto &amp;k = tmp.first;
    auto &amp;v = tmp.second;
    v = v + 1;
}
</code></pre>
<p>这样保存下来的 v 是个引用，是对原值的引用（用 Rust 的话说叫 borrowed）。不仅避免拷贝的开销节省了性能，而且对 v 的修改会实时反映到原 map 中去。</p>
<hr />
<!-- PG80 -->

<p>总结，当需要在遍历的同时修改 map 中的值时，要用 <code>auto &amp;</code> 捕获引用：</p>
<pre><code class="language-cpp">for (auto &amp;[k, v]: m) {  // 捕获一个引用，写入这个引用会立即作用在原值上
    v = v + 1;
}
</code></pre>
<p>即使不需要修改 map 中的值时，也建议用 <code>auto const &amp;</code> 避免拷贝的开销：</p>
<pre><code class="language-cpp">for (auto const &amp;[k, v]: m) {   // 捕获只读的 const 引用，引用避免拷贝开销，const 避免不小心手滑写入
    print(v);
}
</code></pre>
<hr />
<!-- PG81 -->

<p>注：即使捕获为 <code>auto &amp;</code>，由于 map 的元素类型是 <code>pair&lt;const K, V&gt;</code> 所以 K 部分还是会捕获为 <code>K const &amp;</code>，无法写入。</p>
<pre><code class="language-cpp">for (auto &amp;[k, v]: m) {
    k = &quot;key&quot;;    // 编译期报错：const 引用不可写入！
    v = 985211;   // OK
}
</code></pre>
<p>只是如果捕获为 <code>auto const &amp;</code> 就两个都不允许写入了。</p>
<pre><code class="language-cpp">for (auto const &amp;[k, v]: m) {
    k = &quot;key&quot;;    // 编译期报错：const 引用不可写入！
    v = 985211;   // 编译期报错：const 引用不可写入！
}
</code></pre>
<hr />
<!-- PG82 -->

<pre><code class="language-cpp">iterator find(K const &amp;k);
const_iterator find(K const &amp;k) const;
</code></pre>
<p>m.find(key) 函数，根据指定的键 key 查找元素<sup id="fnref12:1"><a class="footnote-ref" href="#fn:1">1</a></sup>。</p>
<ul>
<li>成功找到，则返回指向找到元素的迭代器</li>
<li>找不到，则返回 m.end()</li>
</ul>
<p>由于 STL 传统异能之 end() 虚空索敌，他不可能指向任何值，所以经常作为找不到时候缺省的返回值。</p>
<p>可以用 <code>m.find(key) != m.end()</code> 判断一个元素是否存在，等价于 <code>m.count(key) != 0</code>。</p>
<p>第二个版本的原型作用是：如果 map 本身有 const 修饰，则返回的也是 const 迭代器。</p>
<p>为的是防止你在一个 const map 里 find 了以后利用迭代器变相修改 map 里的值。</p>
<h3 id="count-contains">count 和 contains 没区别</h3>
<!-- PG83 -->

<p>实际上 count 和 contains 函数就是基于 find 实现的，性能没有区别，glibc 源码：</p>
<pre><code class="language-cpp">#if __cplusplus &gt; 201703L
      /**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  True if there is an element with the specified key.
       */
      bool
      contains(const key_type&amp; __x) const
      { return _M_t.find(__x) != _M_t.end(); }

      template&lt;typename _Kt&gt;
      auto
      contains(const _Kt&amp; __x) const
      -&gt; decltype(_M_t._M_find_tr(__x), void(), true)
      { return _M_t._M_find_tr(__x) != _M_t.end(); }
#endif
</code></pre>
<pre><code class="language-cpp">      /**
       *  @brief  Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multimaps; for map the result will
       *  either be 0 (not present) or 1 (present).
       */
      size_type
      count(const key_type&amp; __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
</code></pre>
<pre><code class="language-cpp">// 以下三者等价
m.contains(key)
m.count(key)
m.find(key) != m.end()
</code></pre>
<h3 id="end">end 不能解引用</h3>
<p>检查过不是 m.end()，以确认成功找到后，就可以通过 * 运算符解引用获取迭代器指向的值：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
};
auto it = m.find(&quot;fuck&quot;);  // 寻找 K 为 &quot;fuck&quot; 的元素
if (it != m.end()) {
    auto kv = *it;     // 解引用得到 K-V 对
    print(kv);         // {&quot;fuck&quot;, 985}
    print(kv.first);   // &quot;fuck&quot;
    print(kv.second);  // 985
} else {
    print(&quot;找不到 fuck！&quot;);
}
</code></pre>
<h3 id="find">find 的好处</h3>
<p>find 的高效在于，可以把两次查询合并成一次。</p>
<p>保底写法：开销 <span class="arithmatex"><span class="MathJax_Preview">2 \log N</span><script type="math/tex">2 \log N</script></span></p>
<pre><code class="language-cpp">if (m.count(&quot;key&quot;)) {    // 第一次查询，只包含&quot;是否找到&quot;的信息
    print(m.at(&quot;key&quot;));  // 第二次查询，只包含&quot;找到了什么&quot;的信息
}
</code></pre>
<p>高效写法：开销 <span class="arithmatex"><span class="MathJax_Preview">\log N</span><script type="math/tex">\log N</script></span></p>
<pre><code class="language-cpp">auto it = m.find(&quot;key&quot;); // 一次性查询
if (it != m.end()) {     // 查询的结果，既包含&quot;是否找到&quot;的信息
    print(it-&gt;second);   // 也包含&quot;找到了什么&quot;的信息
}
</code></pre>
<h4 id="c17">C++17 语法糖</h4>
<!-- PG86 -->

<p>C++17 的 if-auto 语法糖如何简化 find 的迭代器判断</p>
<pre><code class="language-cpp">auto it = m.find(&quot;key1&quot;);
if (it != m.end()) {
    print(it-&gt;second);
}
auto it = m.find(&quot;key2&quot;);  // 编译器报错：变量 it 重复定义！
if (it != m.end()) {
    print(it-&gt;second);
}
</code></pre>
<p>虽然删去前面的 auto 可以解决问题，但是如果这里是不同类型的 map 就尬了，得另外想一个变量名。</p>
<p>而 C++17 的 if-auto 语法糖捕获的 it 是限制在当前 if 作用域的，不会跑出去和别人发生冲突。</p>
<pre><code class="language-cpp">if (auto it = m.find(&quot;key1&quot;); it != m.end()) {
    print(it-&gt;second);
}
if (auto it = m.find(&quot;key2&quot;); it != m.end()) {  // 这个变量 it 是局域的，不会和上一个局域的 it 产生名字冲突
    print(it-&gt;second);
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">{
    auto it = m.find(&quot;key1&quot;);
    if (it != m.end()) {
        print(it-&gt;second);
    }
}
</code></pre>
<h4 id="_27">题外话</h4>
<!-- PG87 -->

<p>我给 C++ 标准委员会提一个建议，能不能给迭代器加一个 <code>operator bool</code> 代替烦人的 <code>!= m.end()</code>？</p>
<pre><code class="language-cpp">struct iterator {
    _RbTreeNode *node;

    bool operator!=(iterator const &amp;other) const noexcept {
        return node == other.node;
    }

    operator bool() const noexcept {
        return node;
    }
};
</code></pre>
<p>那样的话就可以直接：</p>
<pre><code class="language-cpp">if (auto it = m.find(&quot;key&quot;)) {
    print(it-&gt;second);
}
</code></pre>
<p>因为 if-auto 省略分号后面的条件时，默认就是 <code>if (auto it = m.find("key"); (bool)it)</code></p>
<h3 id="map-pair">对 map 而言，迭代器解引用得到的是 pair</h3>
<!-- PG88 -->

<p>注意 <code>*it</code> 解引用得到的是 <code>pair&lt;const K, V&gt;</code> 类型的键值对，需要 <code>(*it).second</code> 才能获取单独的值 V。</p>
<p>好在 C 语言就有 <code>-&gt;</code> 运算符作为语法糖，我们可以简写成 <code>it-&gt;second</code>，与 <code>(*it).second</code> 等价。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
};
auto it = m.find(&quot;fuck&quot;);   // 寻找 K 为 &quot;fuck&quot; 的元素
if (it != m.end()) {
    print(it-&gt;second);      // 迭代器有效，可以直接获得值部分 985
} else {
    print(&quot;找不到 fuck！&quot;);  // 这个分支里不得用 * 和 -&gt; 运算符解引用 it
}
</code></pre>
<p>大多数情况下我们查询只需要获取值 V 的部分就行了，直接 <code>it-&gt;second</code> 就可以了✅</p>
<blockquote>
<p>注意：find 找不到键时，会返回 <code>m.end()</code>，这是个无效迭代器，只作为标识符使用（类比 Python 中的 find 有时会返回 -1）。</p>
<p>没有确认 <code>it != m.end()</code> 前，不可以访问 <code>it-&gt;second</code>！那相当于解引用一个空指针，会造成 segfault（更专业一点说是 UB）。</p>
<p>记住，一定要在 <code>it != m.end()</code> 的分支里才能访问 <code>it-&gt;second</code> 哦！你得先检查过饭碗里没有老鼠💩之后，才能安心吃饭！</p>
<p>如果你想让老妈（标准库）自动帮你检查有没有老鼠💩，那就用会自动报错的 at（类比 Python 中的 index 找不到直接报错）。</p>
<p>之所以用 find，是因为有时饭碗里出老鼠💩，是计划的一部分！例如当有老鼠💩时你可以改吃别的零食。而 at 这个良心老妈呢？一发现老鼠💩就拖着你去警察局报案，零食（默认值）也不让你吃了。今日行程全部取消，维权（异常处理，找上层 try-catch 块）设为第一要务。</p>
</blockquote>
<hr />
<!-- PG89 -->

<pre><code class="language-cpp">iterator find(K const &amp;k);
const_iterator find(K const &amp;k) const;
</code></pre>
<p>如果 map 没有 const 修饰，则其 find 返回的 it 也是非 const 迭代器。</p>
<pre><code class="language-cpp">const map&lt;string, int&gt; cm;
map&lt;string, int&gt;::const_iterator cit = cm.find(&quot;key&quot;);
print(cit-&gt;second);  // OK: 可以读取
cit-&gt;second = 1;     // 编译期报错: 不允许写入 const 迭代器指向的值

map&lt;string, int&gt; m;
map&lt;string, int&gt;::iterator it = m.find(&quot;key&quot;);
print(it-&gt;second);   // OK: 可以读取
it-&gt;second = 1;      // OK: 可以写入
</code></pre>
<p><code>it-&gt;second</code> 可以写入，it 是迭代器，迭代器类似于指针，写入迭代器指向的 second 就可以修改 map 里的值部分。</p>
<p><code>it-&gt;first</code> 是键部分，由于 map 的真正元素类型是 <code>pair&lt;const K, V&gt;</code> 所以这部分无法被修改。</p>
<hr />
<!-- PG90 -->

<p>带默认值的查询</p>
<p>众所周知，Python 中的 dict 有一个 m.get(key, defl) 的功能，效果是当 key 不存在时，返回 defl 这个默认值代替 m[key]，而 C++ 的 map 却没有，只能用一套组合拳代替：</p>
<pre><code class="language-cpp">m.count(key) ? m.at(key) : defl
</code></pre>
<p>但上面这样写是比较低效的，相当于查询了 map 两遍，at 里还额外做了一次多余的异常判断。</p>
<p>正常来说是用通用 find 去找，返回一个迭代器，然后判断是不是 end() 决定要不要采用默认值。</p>
<pre><code class="language-cpp">auto it = m.find(key);
return it != m.end() ? it-&gt;second : defl;
</code></pre>
<blockquote>
<p>饭碗里发现了老鼠💩？别急着报警，这也在我的预料之中：启用 B 计划，改吃 defl 这款美味零食即可！</p>
<p>如果是良心老妈 at，就直接启用 C 计划：<img alt="Plan C" src="../img/stl/planc.png" /> 抛出异常然后奔溃了，虽然这很方便我们程序员调试。</p>
</blockquote>
<hr />
<!-- PG91 -->

<p>由于自带默认值的查询这一功能实在是太常用了，为了把这个操作浓缩到一行，我建议同学们封装成函数放到自己的项目公共头文件（一般是 utils.h 之类的名称）里方便以后使用：</p>
<pre><code class="language-cpp">template &lt;class M&gt;
typename M::mapped_type map_get
( M const &amp;m
, typename M::key_type const &amp;key
, typename M::mapped_type const &amp;defl
) {
  typename M::const_iterator it = m.find(key);
  if (it != m.end()) {
    return it-&gt;second;
  } else {
    return defl;
  }
}
</code></pre>
<pre><code class="language-cpp">int val = map_get(config, &quot;timeout&quot;, -1);  // 如果配置文件里不指定，则默认 timeout 为 -1
</code></pre>
<hr />
<!-- PG92 -->

<p>这样还不够优雅，我们还可以更优雅地运用 C++17 的函数式容器 optional：</p>
<pre><code class="language-cpp">template &lt;class M&gt;
std::optional&lt;typename M::mapped_type&gt; map_get
( M const &amp;m
, typename M::key_type const &amp;key
) {
  typename M::const_iterator it = m.find(key);
  if (it != m.end()) {
    return it-&gt;second;
  } else {
    return std::nullopt;
  }
}
</code></pre>
<p>当找不到时就返回 nullopt，找到就返回含有值的 optional。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 本段代码已附在案例代码库的 &ldquo;map_get.h&rdquo; 文件中，等课后可以去 GitHub 下载，赶紧用在你的项目中吧！</p>
</blockquote>
<hr />
<!-- PG93 -->

<p>调用者可以自行运用 optional 的 value_or 函数<sup id="fnref13:1"><a class="footnote-ref" href="#fn:1">1</a></sup>指定找不到时采用的默认值：</p>
<pre><code class="language-cpp">int val = map_get(config, &quot;timeout&quot;).value_or(-1);
</code></pre>
<p>如果要实现 at 同样的找不到就自动报错功能，那就改用 value 函数：</p>
<pre><code class="language-cpp">int val = map_get(config, &quot;timeout&quot;).value();
</code></pre>
<p>optional 具有 <code>operator bool</code> 和无异常的 <code>operator*</code>，所以也可以配合 if-auto 语法糖使用：</p>
<pre><code class="language-cpp">if (auto o_val = map_get(config, &quot;timeout&quot;)) {
    int val = *o_val;
    print(&quot;找到了&quot;, val);
} else {
    print(&quot;找不到时的处理方案...&quot;);
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">auto o_val = map_get(config, &quot;timeout&quot;);
if (o_val) {
    int val = *o_val;
    print(&quot;找到了&quot;, val);
} else {
    print(&quot;找不到时的处理方案...&quot;);
}
</code></pre>
<hr />
<!-- PG94 -->

<p>以上是典型的函数式编程范式 (FP)，C++20 还引入了更多这样的玩意<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>，等有空会专门开节课为大家一一介绍。</p>
<pre><code class="language-cpp">auto even = [] (int i) { return 0 == i % 2; };
auto square = [] (int i) { return i * i; };
for (int i: std::views::iota(0, 6)
          | std::views::filter(even)
          | std::views::transform(square))
    print(i);  // 0 4 16
</code></pre>
<hr />
<!-- PG95 -->

<p>现在学习删除元素用的 erase 函数，其原型如下<sup id="fnref14:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<pre><code class="language-cpp">size_t erase(K const &amp;key);
</code></pre>
<p>指定键值 key，erase 会删除这个键值对应的元素。</p>
<p>返回一个整数，表示删除了多少个元素（只能是 0 或 1）。</p>
<hr />
<!-- PG96 -->

<pre><code class="language-cpp">size_t erase(K const &amp;key);
</code></pre>
<p>erase 运用举例：删除一个元素</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fuck&quot;, &quot;rust&quot;},
};
print(msg);
msg.erase(&quot;fuck&quot;);
print(msg);
</code></pre>
<pre><code>{&quot;fuck&quot;: &quot;rust&quot;, &quot;hello&quot;: &quot;world&quot;}
{&quot;hello&quot;: &quot;world&quot;}
</code></pre>
<hr />
<!-- PG97 -->

<pre><code class="language-cpp">size_t erase(K const &amp;key);
</code></pre>
<p>erase 的返回值和 count 一样，返回成功删除的元素个数，类型为 size_t（无符号 64 位整数）。</p>
<p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p>
<p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p>
<hr />
<!-- PG98 -->

<p>因此可以直接通过 erase 的返回值是否为 0 判断是否删除成功：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fuck&quot;, &quot;rust&quot;},
};
print(msg);
if (msg.erase(&quot;fuck&quot;)) {
    print(&quot;删除fuck成功&quot;);
} else {
    print(&quot;删除fuck失败，键不存在&quot;);
}
if (msg.erase(&quot;dick&quot;)) {
    print(&quot;删除dick成功&quot;);
} else {
    print(&quot;删除dick失败，键不存在&quot;);
}
print(msg);
</code></pre>
<pre><code>{&quot;fuck&quot;: &quot;rust&quot;, &quot;hello&quot;: &quot;world&quot;}
删除fuck成功
删除dick失败，键不存在
{&quot;hello&quot;: &quot;world&quot;}
</code></pre>
<hr />
<!-- PG99 -->

<pre><code class="language-cpp">size_t erase(K const &amp;key);  // 指定键版
iterator erase(iterator it);   // 已知位置版
</code></pre>
<p>区别：</p>
<ul>
<li>
<p>指定键版 erase(key) 实际上需要先调用 find(key) 找到元素位置，然后才能删除，而且还有找不到的可能性。</p>
</li>
<li>
<p>而已知位置的话（比如你已经事先用 find 找到了元素位置），可以用 erase(it) 直接用迭代器作为参数</p>
</li>
</ul>
<p>复杂度不同：</p>
<ul>
<li>
<p>指定键版 erase(key) 的时间复杂度：<span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>。</p>
</li>
<li>
<p>已知位置版 erase(it) 的时间复杂度：<span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>，更高效。</p>
</li>
</ul>
<p>其中 <span class="arithmatex"><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span> 代表这是平摊（Amortized）下来的时间复杂度。</p>
<p>这是因为即使已知位置，erase 有可能涉及树的更新，需要 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度。</p>
<p>但是大多数情况下需要的更新很少，平均下来是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的。</p>
<p>这种情况就会用记号 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span> 来表示。</p>
<hr />
<!-- PG100 -->

<p>erase(key) 可能是基于 erase(it) 实现的：</p>
<pre><code class="language-cpp">size_t erase(K const &amp;key) {  // 小彭老师猜想标准库内部
    auto it = this-&gt;find(key);  // O(log N)
    if (it != this-&gt;end()) {
        this-&gt;erase(it);        // O(1)+
        return 1;  // 找到了，删除成功
    } else {
        return 0;  // 找不到，没有删除
    }
}  // 开销大的 find(key) 会覆盖小的 erase(it)，所以 erase(key) 的总复杂度为 O(log N)
</code></pre>
<hr />
<!-- PG101 -->

<p>指定位置版 erase(it) 返回的是删除元素的下一个元素位置。</p>
<p>由于 map 内部保持键从小到大升序排列，所谓的下一个就是键比当前键大一个的元素，例如：</p>
<pre><code>{&quot;answer&quot;: 42, &quot;hello&quot;: 985, &quot;world&quot;: 211}
</code></pre>
<ul>
<li>erase(find(&ldquo;answer&rdquo;)) 会返回指向 &ldquo;hello&rdquo; 的迭代器，因为 &ldquo;hello&rdquo; 最接近且大于 &ldquo;answer&rdquo;。</li>
<li>erase(find(&ldquo;hello&rdquo;)) 会返回指向 &ldquo;world&rdquo; 的迭代器，因为 &ldquo;world&rdquo; 最接近且大于 &ldquo;hello&rdquo;。</li>
<li>erase(find(&ldquo;world&rdquo;)) 会返回 end()，因为 &ldquo;world&rdquo; 已经是最大键，没有下一个。</li>
</ul>
<p>此外 erase(it) 还有性能上的优势：</p>
<ul>
<li>指定位置版 erase(it) 的复杂度是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span></li>
<li>指定键版 erase(key) 的复杂度是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></li>
</ul>
<p>当已知指向要删除元素的迭代器时（例如先通过 find 找到），直接指定那个迭代器比指定键参数更高效。</p>
<p>删除成绩最差的学生：</p>
<pre><code class="language-cpp">score.erase(score.begin());
</code></pre>
<hr />
<!-- PG102 -->

<h2 id="_28">一边遍历一边删除部分元素</h2>
<p>常见需求场景：一边遍历一边删除部分元素（错误示范）</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fucker&quot;, &quot;rust&quot;},
    {&quot;fucking&quot;, &quot;java&quot;},
    {&quot;good&quot;, &quot;job&quot;},
};
for (auto const &amp;[k, v]: msg) {
    if (k.starts_with(&quot;fuck&quot;)) {
        msg.erase(k);  // 遍历过程中删除当前元素，会导致正在遍历中的迭代器失效，奔溃
    }
}
print(msg);
</code></pre>
<pre><code>Segmentation fault (core dumped)
</code></pre>
<hr />
<!-- PG103 -->

<p>引出问题：迭代器失效</p>
<ul>
<li>每当往 map 中插入新元素时，原先保存的迭代器不会失效。</li>
<li>删除 map 中的其他元素时，也不会失效。</li>
<li><strong>只有当删除的刚好是迭代器指向的那个元素时，才会失效</strong>。</li>
</ul>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
};
auto it = m.find(&quot;fuck&quot;);
m[&quot;dick&quot;] = 211;
print(it-&gt;second);  // 没有失效，打印 985
m.erase(&quot;dick&quot;);
print(it-&gt;second);  // 没有失效，打印 985
m.erase(&quot;fuck&quot;);
print(it-&gt;second);  // 没有失效，打印 985
</code></pre>
<hr />
<!-- PG104 -->

<p>map 比起 unordered_map 来，已经是非常稳定，随便增删改查都不会迭代器失效。</p>
<p>只有一个例外：删除的元素刚好是迭代器指向的。</p>
<p>你拿着个你朋友家的地址，结果你一发 RPG 导弹把他家炸了，还摸不着头脑“奇怪，明明就是这个地址呀”，这时确实无论如何都不能避免失效，不能怪 map。</p>
<p>而刚刚的案例中，我们删除的恰好就是当前正在遍历的迭代器正在指向的那个元素（即使你用了 range-based loop 语法糖他背后还是迭代器遍历）。</p>
<p>而当你对着一个失效的迭代器执行 <code>++it</code> 时，就产生了 segfault 错误。因为红黑树的迭代器要找到“下一个”节点，需要访问这个红黑树节点中存的 <code>next</code> 指针，而这个红黑树节点都已经删除了已经析构了已经释放内存了，里面存的 <code>next</code> 指针也已经释放，被其他系统数据覆盖，这时会访问到错误的指针——野指针。</p>
<hr />
<!-- PG105 -->

<p>所以《好友清除计划》完整的剧情是：</p>
<p>你有好多朋友，今天你要把他们全炸了。</p>
<p>1号朋友家里有一个字条，写着2号朋友家的地址。</p>
<p>2号朋友家里有一个字条，写着3号朋友家的地址。</p>
<p>&hellip;</p>
<p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it /* 进入燃烧中的1号朋友家 */) {
    m.erase(it);  // 一发 RPG 导弹炸毁1号朋友家
}
</code></pre>
<hr />
<!-- PG106 -->

<p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    m.erase(it);
}
</code></pre>
<p>正确的做法是，先进入1号朋友家，安全取出写着2号朋友家地址的字条后，再来一发 RPG 把1号朋友家炸掉。这样才能顺利找到2号朋友家，以此类推继续拆3号……</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ) {
    auto next_it = it;  // 先进入1号朋友的家
    ++next_it;          // 拿出写有2号朋友家地址的字条
    m.erase(it);        // 再发射 RPG 导弹
    it = next_it;       // 前往2号朋友家
}
</code></pre>
<hr />
<!-- PG107 -->

<p>注意到 erase 会返回删除元素的下一个元素的迭代器，也就是说这个 RPG 导弹非常智能，好像他就是专为《好友清除计划》设计的一样：他能在炸毁你朋友的房屋前，自动拿到其中的字条，并把他通过“弹射座椅”弹出来送到门外的你手上，把纸条安全送出来后，再爆炸摧毁你朋友的房屋。这样你就不用冒险进入燃烧的房屋拿字条（迭代器失效导致 segfault），也不用先劳烦您自己先进去一趟房屋拿字条了（上一页中那样提前保存 next_it）。</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ) {
    it = m.erase(it);        // 这款 RPG 导弹“智能地”在摧毁你朋友的房屋同时把其中的字条拿出来了!?
}
</code></pre>
<blockquote>
<p>只是注意这里 for 循环的步进条件 <code>++it</code> 要删掉，因为智能的 RPG 导弹 <code>it = m.erase(it)</code> 已经帮你步进了。</p>
</blockquote>
<hr />
<!-- PG108 -->

<p>一边遍历一边删除部分元素（正解<sup id="fnref15:1"><a class="footnote-ref" href="#fn:1">1</a></sup>）</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fucker&quot;, &quot;rust&quot;},
    {&quot;fucking&quot;, &quot;java&quot;},
    {&quot;good&quot;, &quot;job&quot;},
};
for (auto it = m.begin(); it != m.end(); ) {  // 没有 ++it
    auto const &amp;[k, v] = *it;
    if (k.starts_with(&quot;fuck&quot;)) {
        it = msg.erase(it);
    } else {
        ++it;
    }
}
print(msg);
</code></pre>
<pre><code>{&quot;good&quot;: &quot;job&quot;, &quot;hello&quot;: &quot;world&quot;}
</code></pre>
<hr />
<!-- PG109 -->

<p>::left::</p>
<p>不奔溃</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ) {
    auto const &amp;[k, v] = *it;
    if (k.starts_with(&quot;fuck&quot;)) {
        it = msg.erase(it);
    } else {
        ++it;
    }
}
</code></pre>
<p>::right::</p>
<p>奔溃</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    auto const &amp;[k, v] = *it;
    if (k.starts_with(&quot;fuck&quot;)) {
        msg.erase(it);
        // 或者 msg.erase(k);
    }
}
</code></pre>
<hr />
<!-- PG110 -->

<h3 id="c20-erase_if">C++20 更好的写法：erase_if</h3>
<p>批量删除符合条件的元素（C++20<sup id="fnref16:1"><a class="footnote-ref" href="#fn:1">1</a></sup>）</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fucker&quot;, &quot;rust&quot;},
    {&quot;fucking&quot;, &quot;java&quot;},
    {&quot;good&quot;, &quot;job&quot;},
};
std::erase_if(msg, [&amp;] (auto const &amp;kv) {
    auto &amp;[k, v] = kv;
    return k.starts_with(&quot;fuck&quot;);
});
print(msg);
</code></pre>
<pre><code>{&quot;good&quot;: &quot;job&quot;, &quot;hello&quot;: &quot;world&quot;}
</code></pre>
<hr />
<!-- PG111 -->

<p>如果你搞不懂迭代器这些，这里我提供一个保底写法，先把键提前保存到一个 vector 中去：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fucker&quot;, &quot;rust&quot;},
    {&quot;fucking&quot;, &quot;java&quot;},
    {&quot;good&quot;, &quot;job&quot;},
};
vector&lt;string&gt; keys;             // vector 或者 set 都可以
for (auto const &amp;[k, v]: msg) {  // 先把所有键提前拷贝到临时 vector 里
    keys.push_back(k);
}
for (auto const &amp;k: keys) {      // 遍历刚才保存的键
    if (k.starts_with(&quot;fuck&quot;)) {
        msg.erase(k);            // 键值对已经提前深拷贝到临时 vector 里，这时删除 map 里的键不会奔溃
    }
}
</code></pre>
<blockquote>
<p>小彭老师，永远的祛魅大师。</p>
</blockquote>
<hr />
<!-- PG112 -->

<p>还是搞不懂的话，也可以新建一个 map，条件反之，把不需要删除的元素插入新 map，过滤出需要保留的元素，最后再一次性用新 map 覆盖旧 map。</p>
<pre><code class="language-cpp">map&lt;string, string&gt; msg = {
    {&quot;hello&quot;, &quot;world&quot;},
    {&quot;fucker&quot;, &quot;rust&quot;},
    {&quot;fucking&quot;, &quot;java&quot;},
    {&quot;good&quot;, &quot;job&quot;},
};
map&lt;string, string&gt; newmsg;
for (auto const &amp;[k, v]: msg) {
    if (!k.starts_with(&quot;fuck&quot;)) {   // 注意这里条件反了，不需要删除的才插入 newmsg
        newmsg[k] = v;
    }
}
msg = std::move(newmsg);        // 覆盖旧的 map，用更高效的移动赋值函数，O(1) 复杂度
</code></pre>
<blockquote>
<p>小彭老师，永远的保底大师。</p>
</blockquote>
<hr />
<!-- PG113 -->

<p>接下来开始学习如何插入元素，map 的成员 insert 函数原型如下<sup id="fnref17:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<pre><code class="language-cpp">pair&lt;iterator, bool&gt; insert(pair&lt;const K, V&gt; const &amp;kv);
pair&lt;iterator, bool&gt; insert(pair&lt;const K, V&gt; &amp;&amp;kv);
</code></pre>
<p>他的参数类型就是刚刚介绍的 <code>value_type</code>，也就是 <code>pair&lt;const K, V&gt;</code>。</p>
<p>pair 是一个 STL 中常见的模板类型，<code>pair&lt;K, V&gt;</code> 有两个成员变量：</p>
<ul>
<li>first：V 类型，表示要插入元素的键</li>
<li>second：K 类型，表示要插入元素的值</li>
</ul>
<p>我称之为&rdquo;键值对&rdquo;。</p>
<hr />
<!-- PG114 -->

<p>试着用 insert 插入键值对：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m;
pair&lt;string, int&gt; p;
p.first = &quot;fuck&quot;;  // 键
p.second = 985;    // 值
m.insert(p);  // pair&lt;string, int&gt; 可以隐式转换为 insert 参数所需的 pair&lt;const string, int&gt;
print(m);
</code></pre>
<p>结果：</p>
<pre><code>{&quot;fuck&quot;: 985}
</code></pre>
<hr />
<!-- PG115 -->

<p>简化 insert</p>
<!-- <v-clicks> -->

<ol>
<li>直接使用 pair 的构造函数，初始化 first 和 second</li>
</ol>
<pre><code class="language-cpp">pair&lt;string, int&gt; p(&quot;fuck&quot;, 985);
m.insert(p);
</code></pre>
<ol start="2">
<li>不用创建一个临时变量，pair 表达式直接作为 insert 函数的参数</li>
</ol>
<pre><code class="language-cpp">m.insert(pair&lt;string, int&gt;(&quot;fuck&quot;, 985));
</code></pre>
<ol start="2">
<li>可以用 <code>std::make_pair</code> 这个函数，自动帮你推导模板参数类型，省略 <code>&lt;string, int&gt;</code></li>
</ol>
<pre><code class="language-cpp">m.insert(make_pair(&quot;fuck&quot;, 985));  // 虽然会推导为 pair&lt;const char *, int&gt; 但还是能隐式转换为 pair&lt;const string, int&gt;
</code></pre>
<ol start="3">
<li>由于 insert 函数原型已知参数类型，可以直接用 C++11 的花括号初始化列表 {&hellip;}，无需指定类型</li>
</ol>
<pre><code class="language-cpp">m.insert({&quot;fuck&quot;, 985});           // ✅
</code></pre>
<!-- </v-clicks> -->

<hr />
<!-- PG116 -->

<p>因此，insert 的最佳用法是：</p>
<pre><code class="language-cpp">map&lt;K, V&gt; m;
m.insert({&quot;key&quot;, &quot;val&quot;});
</code></pre>
<p>insert 插入和 [] 写入的异同：</p>
<ul>
<li>同：当键 K 不存在时，insert 和 [] 都会创建键值对。</li>
<li>异：当键 K 已经存在时，insert 不会覆盖，默默离开；而 [] 会覆盖旧的值。</li>
</ul>
<p>例子：</p>
<p>::left::</p>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
m.insert({&quot;key&quot;, &quot;old&quot;});
m.insert({&quot;key&quot;, &quot;new&quot;});  // 插入失败，默默放弃不出错
print(m);
</code></pre>
<pre><code>{&quot;key&quot;: &quot;old&quot;}
</code></pre>
<p>::right::</p>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
m[&quot;key&quot;] = &quot;old&quot;;
m[&quot;key&quot;] = &quot;new&quot;;        // 已经存在？我踏马强行覆盖！
print(m);
</code></pre>
<pre><code>{&quot;key&quot;: &quot;new&quot;}
</code></pre>
<hr />
<!-- PG117 -->

<p>insert 的返回值是 <code>pair&lt;iterator, bool&gt;</code> 类型，<del>STL 的尿性：在需要一次性返回两个值时喜欢用 pair</del>。</p>
<p>这又是一个 pair 类型，其具有两个成员：</p>
<ul>
<li>first：iterator 类型，是个迭代器</li>
<li>second：bool 类型，表示插入成功与否，如果发生键冲突则为 false</li>
</ul>
<p>其中 first 这个迭代器指向的是：</p>
<ul>
<li>如果插入成功（second 为 true），指向刚刚成功插入的元素位置</li>
<li>如果插入失败（second 为 false），说明已经有相同的键 K 存在，发生了键冲突，指向已经存在的那个元素</li>
</ul>
<hr />
<!-- PG118 -->

<p>其实 insert 返回的 first 迭代器等价于插入以后再重新用 find 找到刚刚插入的那个键，只是效率更高：</p>
<pre><code class="language-cpp">auto it = m.insert({k, v}).first;  // 高效，只需遍历一次
</code></pre>
<pre><code class="language-cpp">m.insert({k, v});     // 插入完就忘事了
auto it = m.find(k);  // 重新遍历第二次，但结果一样
</code></pre>
<p>参考 C 编程网<sup id="fnref18:1"><a class="footnote-ref" href="#fn:1">1</a></sup>对 insert 返回值的解释：</p>
<blockquote>
<p>当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；</p>
<p>反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。</p>
</blockquote>
<hr />
<!-- PG119 -->

<p>可以用 insert 返回的 second 判断插入多次是否成功：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
print(m.insert({&quot;key&quot;, &quot;old&quot;}).second);  // true
print(m.insert({&quot;key&quot;, &quot;new&quot;}).second);  // false
m.erase(&quot;key&quot;);     // 把原来的 {&quot;key&quot;, &quot;old&quot;} 删了
print(m.insert({&quot;key&quot;, &quot;new&quot;}).second);  // true
</code></pre>
<p>也可以用 structured-binding 语法拆解他返回的 <code>pair&lt;iterator, bool&gt;</code>：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; counter;
auto [it, success] = counter.insert(&quot;key&quot;, 1);  // 直接用
if (!success) {  // 如果已经存在，则修改其值+1
    it-&gt;second = it-&gt;second + 1;
} else {  // 如果不存在，则打印以下信息
    print(&quot;created a new entry!&quot;);
}
</code></pre>
<p>以上这一长串代码和之前“优雅”的计数 [] 等价：</p>
<pre><code class="language-cpp">counter[&quot;key&quot;]++;
</code></pre>
<h3 id="insert_or_assign">insert_or_assign</h3>
<!-- PG120 -->

<p>在 C++17 中，[] 写入有了个更高效的替代品 insert_or_assign<sup id="fnref19:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<pre><code class="language-cpp">pair&lt;iterator, bool&gt; insert_or_assign(K const &amp;k, V v);
pair&lt;iterator, bool&gt; insert_or_assign(K &amp;&amp;k, V v);
</code></pre>
<p>正如他名字的含义，“插入或者写入”：</p>
<ul>
<li>如果 K 不存在则创建（插入）</li>
<li>如果 K 已经存在则覆盖（写入）</li>
</ul>
<p>用法如下：</p>
<pre><code class="language-cpp">m.insert_or_assign(&quot;key&quot;, &quot;new&quot;);  // 与 insert 不同，他不需要 {...}，他的参数就是两个单独的 K 和 V
</code></pre>
<p>返回值依旧是 <code>pair&lt;iterator, bool&gt;</code>。由于这函数在键冲突时会覆盖，按理说是必定成功了，因此这个 bool 的含义从“是否插入成功”变为“是否创建了元素”，如果是创建的新元素返回true，如果覆盖了旧元素返回false。</p>
<hr />
<!-- PG121 -->

<h4 id="insert_or_assign_1">insert_or_assign 的优势</h4>
<p>看来 insert_or_assign 和 [] 的效果完全相同！都是在键值冲突时覆盖旧值。</p>
<p>既然 [] 已经可以做到同样的效果，为什么还要发明个 insert_or_assign 呢？</p>
<p>insert_or_assign 的优点是<strong>不需要调用默认构造函数</strong>，可以提升性能。</p>
<p>其应用场景有以下三种情况：</p>
<ul>
<li>⏱ 您特别在乎性能</li>
<li>❌ 有时 V 类型没有默认构造函数，用 [] 编译器会报错</li>
<li>🥵 强迫症发作</li>
</ul>
<p>否则用 [] 写入也是没问题的。</p>
<p>而且 insert_or_assign 能取代 [] 的岗位仅限于纯写入，之前 <code>counter[key]++</code> 这种“优雅”写法依然是需要用 [] 的。</p>
<h4 id="_29">效率问题</h4>
<p>创建新键时，insert_or_assign 更高效。</p>
<h5 id="_30">[]</h5>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
m[&quot;key&quot;] = &quot;old&quot;;
m[&quot;key&quot;] = &quot;new&quot;;
print(m);
</code></pre>
<pre><code>{&quot;key&quot;: &quot;new&quot;}
</code></pre>
<p>覆盖旧键时，使用 [] 造成的开销：</p>
<ul>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<p>创建新键时，使用 [] 造成的开销：</p>
<ul>
<li>调用默认构造函数 <code>V()</code></li>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<h5 id="insert_or_assign_2">insert_or_assign</h5>
<pre><code class="language-cpp">map&lt;string, string&gt; m;
m.insert_or_assign(&quot;key&quot;, &quot;old&quot;);
m.insert_or_assign(&quot;key&quot;, &quot;new&quot;);
print(m);
</code></pre>
<pre><code>{&quot;key&quot;: &quot;new&quot;}
</code></pre>
<p>覆盖旧键时，使用 insert_or_assign 造成的开销：</p>
<ul>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<p>创建新键时，使用 insert_or_assign 造成的开销：</p>
<ul>
<li>调用移动构造函数 <code>V(V &amp;&amp;)</code></li>
</ul>
<h4 id="_31">那我应该用什么</h4>
<!-- PG123 -->

<p>总结，如果你有性能强迫症，并且是 C++17 标准：</p>
<ul>
<li>写入用 insert_or_assign</li>
<li>读取用 at</li>
</ul>
<p>如果没有性能强迫症，或者你的编译器不支持 C++17 标准：</p>
<ul>
<li>写入用 []</li>
<li>读取用 at</li>
</ul>
<p>最后，如果你是还原论者，只需要 find 和 insert 函数就是完备的了，别的函数都不用去记。所有 at、[]、insert_or_assign 之类的操作都可以通过 find 和 insert 的组合拳实现，例如刚刚我们自定义的 map_get。</p>
<!-- PG124 -->

<h4 id="insert_or_assign-vs-insert">insert_or_assign vs insert：顺序问题</h4>
<p>回顾之前的反向查找表，如果有重复，如何区分找第一个还是最后一个？</p>
<p>构建反向查找表，找到最后一个的下标：</p>
<pre><code class="language-cpp">for (size_t i = 0; i &lt; arr.size(); i++) {
    arrinv.insert_or_assign(arr[i], i);
    // 等价于 arrinv[arr[i]] = i;
}
</code></pre>
<p>构建反向查找表，找到第一个的下标：</p>
<pre><code class="language-cpp">for (size_t i = 0; i &lt; arr.size(); i++) {
    arrinv.insert({arr[i], i});
}
</code></pre>
<h2 id="insert">批量 insert</h2>
<!-- PG125 -->

<p>刚刚介绍的那些 insert 一次只能插入一个元素，insert 还有一个特殊的版本，用于批量插入一系列元素。</p>
<pre><code class="language-cpp">template &lt;class InputIt&gt;
void insert(InputIt beg, InputIt end);
</code></pre>
<p>参数<sup id="fnref20:1"><a class="footnote-ref" href="#fn:1">1</a></sup>是两个迭代器 beg 和 end，组成一个区间，之间是你要插入的数据。</p>
<p>该区间可以是任何其他容器的 begin() 和 end() 迭代器——那会把该容器中所有的元素都插入到本 map 中去。</p>
<p>例如，把 vector 中的键值对批量插入 map：</p>
<pre><code class="language-cpp">vector&lt;pair&lt;string, int&gt;&gt; kvs = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
map&lt;string, int&gt; config;
config.insert(kvs.begin(), kvs.end());
print(config);  // {&quot;delay&quot;: 211, &quot;timeout&quot;: 985}
</code></pre>
<h3 id="insert_1">批量 insert 同样遵循不覆盖原则</h3>
<!-- PG126 -->

<p>注：由于 insert 不覆盖的特性，如果 vector 中有重复的键，则会以键第一次出现时的值为准，之后重复出现的键会被忽视。</p>
<pre><code class="language-cpp">vector&lt;pair&lt;string, int&gt;&gt; kvs = {
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
    {&quot;delay&quot;, 666},
    {&quot;delay&quot;, 233},
    {&quot;timeout&quot;, 996},
};
map&lt;string, int&gt; config;
config.insert(kvs.begin(), kvs.end());
print(config);
</code></pre>
<pre><code>{&quot;delay&quot;: 211, &quot;timeout&quot;: 985}
</code></pre>
<!-- PG127 -->

<h3 id="insert-map">批量 insert 实现 map 合并</h3>
<p>批量 insert 运用案例：两个 map 合并</p>
<p>这个批量 insert 输入的迭代器可以是任何容器，甚至可以是另一个 map 容器。</p>
<p>运用这一点可以实现两个 map 的并集操作。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m1 = {  // 第一个 map
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
map&lt;string, int&gt; m2 = {  // 第二个 map
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
m1.insert(m2.begin(), m2.end());  // 把 m2 的内容与 m1 合并，结果写回到 m1
print(m1);
</code></pre>
<pre><code>{&quot;answer&quot;: 42, &quot;delay&quot;: 211, &quot;timeout&quot;: 7}
</code></pre>
<p>注：还是由于 insert 不覆盖的特性，当遇到重复的键时（例如上面的 &ldquo;timeout&rdquo;），会以 m1 中的值为准。</p>
<h4 id="_32">就地写入！</h4>
<!-- PG128 -->

<p>使用 <code>m1.insert(m2.begin(), m2.end())</code> 后，合并的结果会就地写入 m1。</p>
<p>如果希望合并结果放到一个新的 map 容器中而不是就地修改 m1，请先自行生成一份 m1 的深拷贝：</p>
<pre><code class="language-cpp">const map&lt;string, int&gt; m1 = {  // 第一个 map，修饰有 const 禁止修改
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
const map&lt;string, int&gt; m2 = {  // 第二个 map，修饰有 const 禁止修改
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
auto m12 = m1;  // 生成一份 m1 的深拷贝 m12，避免 insert 就地修改 m1
m12.insert(m2.begin(), m2.end());
print(m12);     // m1 和 m2 的合并结果
</code></pre>
<pre><code>{&quot;answer&quot;: 42, &quot;delay&quot;: 211, &quot;timeout&quot;: 7}
</code></pre>
<hr />
<h4 id="insert_2">批量 insert 优先保留已经有的</h4>
<!-- PG129 -->

<pre><code class="language-cpp">auto m12 = m1;
m12.insert(m2.begin(), m2.end());
print(m12);     // m1 和 m2 的合并结果，键冲突时优先取 m1 的值
</code></pre>
<pre><code>{&quot;answer&quot;: 42, &quot;delay&quot;: 211, &quot;timeout&quot;: 7}
</code></pre>
<p>刚刚写的 m1 和 m2 合并，遇到重复时会优先采取 m1 里的值，如果希望优先采取 m2 的呢？反一反就可以了：</p>
<pre><code class="language-cpp">auto m12 = m2;
m12.insert(m1.begin(), m1.end());
print(m12);     // m1 和 m2 的合并结果，键冲突时优先取 m2 的值
</code></pre>
<pre><code>{&quot;answer&quot;: 42, &quot;delay&quot;: 211, &quot;timeout&quot;: 985}
</code></pre>
<p>要是学不会批量 insert，那手写一个 for 循环遍历 m2，然后 m1.insert_or_assign(k2, v2) 也是可以的，总之要懂得变通，动动脑，总是有保底写法的。</p>
<h4 id="_33">其他操作：交集、并集、差集等</h4>
<!-- PG130 -->

<p>有同学就问了，这个 insert 实现了 map 的并集操作，那交集操作呢？这其实是 set 的常规操作而不是 map 的：</p>
<ul>
<li>set_intersection（取集合交集）</li>
<li>set_union（取集合并集）</li>
<li>set_difference（取集合差集）</li>
<li>set_symmetric_difference（取集合对称差集）</li>
</ul>
<p>非常抱歉在之前的 set 课中完全没有提及，因为我认为那是 <code>&lt;algorithm&gt;</code> 头文件里的东西。</p>
<p>不过别担心，之后我们会专门有一节 algorithm 课详解 STL 中这些全局函数——我称之为算法模板，因为他提供了很多常用的算法，对小彭老师这种算法弱鸡而言，实在非常好用，妈妈再也不用担心我的 ACM 奖杯。</p>
<p>在小彭老师制作完 algorithm 课之前，同学们可以自行参考 https://blog.csdn.net/u013095333/article/details/89322501 提前进行学习这四个函数。</p>
<pre><code class="language-cpp">std::set_union(A.begin(), A.end(), B.begin(), B.end(), std::inserter(C, C.begin()));  // C = A U B
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 注：set_union 仅仅要求输入的两个区间有序，可以是 set，也可以是排序过的 vector。而且通过重载运算符或者指定 compare 函数，同样可以模拟 map 只对 key 部分排序的效果——参考 thrust::sort_by_key，但很可惜 STL 没有这函数，需要自定义 compare 函数模拟。</p>
</blockquote>
<p>同样地，这些操作也是很容易基于 map 的 contains、erase、insert 等接口“动动脑”写出保底写法：</p>
<pre><code class="language-cpp">map&lt;string, string&gt; m12;
for (const auto &amp;[k, v] : m2) {
    if (m1.contains(k)) { // 此处为 count 也可以
        // 交集操作：如果 m1 和 m2 都有这个键，则插入他俩的交集 m12
        m12.insert({k, v});
    }
}
</code></pre>
<h3 id="insert_3">insert 一个初始化列表</h3>
<p>C++11 还引入了一个以初始化列表（initializer_list）为参数的 insert 版本：</p>
<pre><code class="language-cpp">void insert(initializer_list&lt;pair&lt;const K, V&gt;&gt; ilist);
</code></pre>
<p>用法和 map 的构造函数一样，还是用花括号列表：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {  // 初始化时就插入两个元素
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
m.insert({              // 批量再插入两个新元素
    {&quot;timeout&quot;, 985},   // &quot;timeout&quot; 发生键冲突，根据 insert 的特性，不会覆盖
    {&quot;delay&quot;, 211},
});
</code></pre>
<pre><code>{&quot;answer&quot;: 42, &quot;delay&quot;: 211, &quot;timeout&quot;: 7}
</code></pre>
<p>注：这里还是和逐个 insert 一样，重复的键 &ldquo;timeout&rdquo; 没有被覆盖，依旧了保留原值。</p>
<hr />
<!-- PG132 -->

<h4 id="insert_4">小彭老师锐评批量 insert 有什么用</h4>
<pre><code class="language-cpp">m.insert({
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
});
</code></pre>
<p>总之这玩意和分别调用两次 insert 等价：</p>
<pre><code class="language-cpp">m.insert({&quot;timeout&quot;, 985});
m.insert({&quot;delay&quot;, 211});
</code></pre>
<p>如果需要覆盖原值的批量写入，还是得乖乖写个 for 循环调用 [] 或 insert_or_assign。</p>
<p>问：既然和批量插入没什么区别，复杂度也一样是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>，那批量 insert 究竟还有什么存在的必要呢？map 又不像 vector 一个个分别插入会变成 <span class="arithmatex"><span class="MathJax_Preview">O(N^2)</span><script type="math/tex">O(N^2)</script></span> 复杂度，确实需要提供个批量插入的方法。</p>
<p>答：</p>
<ol>
<li>是为了统一，既然 vector 都有批量 insert，那 set 和 map 也得有才符合完美主义美学，而且用他来合并两个 map 也很方便。</li>
<li>复杂度并不一样，当输入已经有序时，批量 insert 会比逐个 insert 更快，只需 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 而不是 <span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span>；如果输入无序，那么依然是 <span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span>，稍后会讲原理。</li>
</ol>
<h3 id="operator">operator= 也支持初始化列表</h3>
<pre><code class="language-cpp">map &amp;operator=(initializer_list&lt;pair&lt;const K, V&gt;&gt; ilist);
</code></pre>
<p>map 也支持赋值函数，不仅有 map 自己给自己赋值的移动赋值和拷贝赋值函数，还有从列表初始化的函数。</p>
<p>用法是等号右边一个花括号列表，作用是清空原有内容，直接设为一个全新的 map：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {  // 初始化时就插入两个元素
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
m = {                   // 原有内容全部清空！重新插入两个新元素
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
</code></pre>
<pre><code>{&quot;delay&quot;: 211, &quot;timeout&quot;: 985}
</code></pre>
<blockquote>
<p>相当于 clear 了再重新 insert，原有的 &ldquo;answer&rdquo; 键也被删掉了。</p>
</blockquote>
<h4 id="_34">赋值函数和构造函数概念辨析</h4>
<p>要注意赋值函数 <code>operator=(initializer_list)</code> 和构造函数 <code>map(initializer_list)</code> 是不同的。</p>
<p>构造函数是初始化时调用的（无论有没有 = 号），赋值函数是后期重新赋值时调用的。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m{    // 构造函数 map(initializer_list)
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
map&lt;string, int&gt; m = {  // 虽然有等号，但这里是初始化语境，调用的依然是构造函数 map(initializer_list)
    {&quot;answer&quot;, 42},
    {&quot;timeout&quot;, 7},
};
m = {                   // m 已经初始化过，这里是重新赋值，才是赋值函数 operator=(initializer_list)
    {&quot;timeout&quot;, 985},
    {&quot;delay&quot;, 211},
};
</code></pre>
<p>如果一个类要支持初始化，又要支持后期重新赋值，那么构造函数和赋值函数都要实现。</p>
<p>但也可以选择只定义 <code>operator=(map &amp;&amp;)</code> 移动赋值函数而不定义 <code>operator=(initializer_list)</code>。这样当试图 <code>operator=(initializer_list)</code> 时，会匹配到 <code>map(initializer_list)</code> 这个隐式构造函数来转换，然后调用到 <code>operator=(map &amp;&amp;)</code>。标准库选择将两个都定义可能是处于避免一次 map 移动的效率考量。</p>
<!-- PG134 -->

<h4 id="assign">assign 函数</h4>
<p>map 还有一个 assign 函数，他和 <code>operator=</code> 等价：</p>
<pre><code class="language-cpp">void assign(initializer_list&lt;pair&lt;const K, V&gt;&gt; ilist);
</code></pre>
<p>assign 的额外好处是他拥有两个迭代器参数组成区间的版本，和批量 insert 类似，只不过 assign 会清除已有的元素。</p>
<pre><code class="language-cpp">template &lt;class InputIt&gt;
void assign(InputIt first, InputIt last);
</code></pre>
<p>和 <code>operator=(map(first, last))</code> 等价。</p>
<h2 id="insert_5">带插入位置提示的 insert</h2>
<pre><code class="language-cpp">iterator insert(const_iterator pos, pair&lt;K, V&gt; const &amp;kv);
</code></pre>
<p>这又是 insert 函数的一个重载版，增加了 pos 参数提示插入位置，官方文档称<sup id="fnref21:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<blockquote>
<p>Inserts value in the position as close as possible to the position just prior to pos.</p>
<p>把元素（键值对）插入到位于 pos 之前，又离 pos 尽可能近的地方。</p>
</blockquote>
<p>然而 map 作为红黑树应该始终保持有序，插入位置可以由 K 唯一确定，为啥还要提示？</p>
<p>是为了在已知要插入的大致位置时，能够提升性能。</p>
<blockquote>
<p>（带提示的 insert 版本）中传入的迭代器，仅是给 map 容器提供一个建议，并不一定会被容器采纳。该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。<sup id="fnref3:2"><a class="footnote-ref" href="#fn:2">2</a></sup></p>
<p>也就是说这玩意还不一定管用，只是提示性质的（和 mmap 函数的 start 参数很像，你可以指定，但只是个提示，指定了不一定有什么软用，具体什么地址还是操作系统说了算，他从返回值里给你的地址才是正确答案）。例如已知指向 &ldquo;key&rdquo; 的迭代器，想要插入 &ldquo;kea&rdquo;，那么指定指向 &ldquo;key&rdquo; 的迭代器就会让 insert 能更容易定位到 &ldquo;kea&rdquo; 要插入的位置。</p>
</blockquote>
<h3 id="_35">复杂度分类讨论</h3>
<!-- PG135 -->

<pre><code class="language-cpp">iterator insert(const_iterator pos, pair&lt;K, V&gt; const &amp;kv);
</code></pre>
<ul>
<li>当插入位置 pos 提示的准确时，insert 的复杂度可以低至 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>。</li>
<li>当插入位置 pos 提示不准确时，和普通的 insert 一样，还是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>。</li>
<li>返回指向成功插入元素位置的迭代器。</li>
</ul>
<p>想想看，这三个看似不相干的特性，能有什么用呢？</p>
<p>可以让已经有序数据的批量插入更高效！</p>
<p>众所周知，普通的批量 insert 复杂度为 <span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span>。</p>
<pre><code class="language-cpp">vector&lt;pair&lt;int, int&gt;&gt; arr;
map&lt;int, int&gt; tab;
for (auto const &amp;[k, v]: arr) {
    tab.insert({k, v});               // O(log N)
}  // 总共 O(N log N)
</code></pre>
<p>假如输入本就有序，带提示的批量 insert 复杂度可以降低到 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>。</p>
<p>如果输入无序，带提示的批量 insert 复杂度依然是 <span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span> 不变。</p>
<pre><code class="language-cpp">vector&lt;pair&lt;int, int&gt;&gt; arr;
map&lt;int, int&gt; tab;
auto hint = tab.begin();
for (auto const &amp;[k, v]: arr) {
    hint = tab.insert(hint, {k, v});  // 平均 O(1)
}  // 总共 O(N)
</code></pre>
<p>想一想，为什么？</p>
<h3 id="_36">小学生的趣味早操</h3>
<!-- PG137 -->

<p>你是一名小学老师，马上就要出早操了，为应付领导面子，你需要给你的学生排队，根据个子从矮到高排列。</p>
<p>不过这所小学的学生都比较懒散，有的来得早有的来得晚，而且来的早晚顺序和他们的高矮无关。</p>
<p>你本来打算等所有人到齐之后再一次性完成排序（std::sort）的，但是同学来的时间实在是太分散了：明明 8 点就要出早操，最晚的同学却 7 点 59 分才到达。意味着你需要一直干等着这个懒散的同学，最后在 1 分钟时间内临时抱佛脚，完成快速排序。这是不可能的，只能在同学陆续抵达的同时进行排序，这就是堆排序，一边插入一边排序，每次插入后都保证有序，与插入排序不同他使用堆内存中的节点而不是数组避免昂贵的数组平移操作。</p>
<p>每当来一个学生，你就得把他插入到现有的一个已经排好的队伍中去。</p>
<p>如何确定插入的位置？二分法。先从现有队伍的最中间（1/2 处）开始，比较中间这个学生和新来的学生哪个高哪个矮，如果发现新来的学生高，则继续从队列的 3/4 处那个同学开始比高矮，如果新来的学生矮就从队列的 1/4 处继续比较。以此类推，最终唯一确定新同学要插入的位置。因为每次确定的范围就小一半，所以最多只需要 <span class="arithmatex"><span class="MathJax_Preview">\log N</span><script type="math/tex">\log N</script></span> 次比较就可以成功插入，其中 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 是当前已有学生的数量。</p>
<p>总共要来 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 名学生，则你总共需要比较 <span class="arithmatex"><span class="MathJax_Preview">N \log N</span><script type="math/tex">N \log N</script></span> 次。能不能优化？让我们小彭老师省力点？</p>
<h3 id="_37">小学生来的顺序已经有序的情况</h3>
<!-- PG138 -->

<p>后来你发现一个规律，似乎学生来的早晚顺序和高矮有关：矮小的同学喜欢起的早，高大的同学喜欢起的晚。</p>
<p>知道这个规律后，你改变你的策略：二分法时，不是先从最中间（1/2 处）开始查找，而是从最末尾开始查找。因为矮小同学会早到，导致每次新来的同学往往总是队列中最高的那一个。所以可以从队伍的末尾（最高的地方）开始找，例如有 64 名同学则优先和 65/64 处比较，找不到再往上一级和 31/32 处比较。</p>
<p>这个策略也有缺点：对于早晚顺序和高矮无关、甚至负相关的情况，每次插入的消耗就会变成 <span class="arithmatex"><span class="MathJax_Preview">2 \log N</span><script type="math/tex">2 \log N</script></span> 了。</p>
<p>最终我们决定采用的策略是：不是从中间，也不是从开头，也不是从末尾，而是<strong>记住上一次成功插入的位置</strong>，下一次从上一次成功插入的位置开始找。这个记忆的插入位置，就是刚刚代码中那个位置提示迭代器 hint。</p>
<p>这正是我们代码的写法：</p>
<pre><code class="language-cpp">hint = tab.insert(hint, {k, v});
</code></pre>
<p>实际上，insert 的批量插入版 <code>insert(arr.begin(), arr.end())</code> 内部就会使用这种带提示的方式，逐个插入。</p>
<pre><code class="language-cpp">vector&lt;pair&lt;int, int&gt;&gt; arr;
</code></pre>
<!-- PG139 -->

<!-- 1111 -->

<!--

-

erase + find 性能优化案例：

现在我们老板提出新业务需求，他有一个 `map<string, int>`，这是从学生姓名到成绩的对照表。

现在他要求如果成绩里有这同学则删除，删除成功后，还要打印一下学生的成绩给他看：


<pre><code class="language-cpp">// 注意这里函数的 map 参数必须是引用类型，不然里面的修改不会同步到调用者外面
void LaoBanJob(map&lt;string, int&gt; &amp;m, string key) {
    if (m.count(key)) {
        print(&quot;开除一名成绩&quot;, m.at(key), &quot;的同学&quot;);
        m.erase(key);
    } else {
        print(&quot;查无此人：&quot;, key);
    }
}
</code></pre>


性能分析：设 map 的中有 N 个元素

- count(key) 消耗 $O(\log N)$ 时间
- at(key) 消耗 $O(\log N)$ 时间
- erase(key) 消耗 $O(\log N)$ 时间

-

总共花费了约 $3 \log N$ 时间！这里面其实有很多重复劳动，每个函数里面都调用了一次 find，但是每次都是 find 同一个 key，应该是可以合并的。

由于 erase(key) 也会返回删除了多少个元素，和 count 的返回值一样，因此 erase 可以和 count 合并呀！


<pre><code class="language-cpp">void LaoBanJob(map&lt;string, int&gt; &amp;m, string key) {
    if (m.erase(key)) {
        print(&quot;开除一名成绩&quot;, m.at(key), &quot;的同学&quot;);  // key 已经删除，这里 at(key) 会出错！
    }
}
</code></pre>


但是这样老板要求的“删除以后打印学生信息”的功能就就没法实现了！删除元素以后，元素已经不存在，这时再调用 at 就会出错！结果四体不勤五谷不分的西装老板一看到看不懂的 C++ 报错，一急，把小彭老师工资扣光。

为了保住老板克扣的工资，小彭老师只好放弃优化，保全代码可读性。

> 这也是为什么很多看起来纪律严明，官僚作风的联网大厂，内部其实相互扯皮，勾心斗角，导致缺乏创新，整体办事效率低下。
>
> 他们根本没有动力去改进代码，改善用户体验，只能靠老板说一句动一步，像挤牙膏一样，员工劳动被异化，缺乏积极性。
>
> 只有充分尊重员工个体价值，鼓励员工跳出舒适区，才能发挥最大的创新效率，这就是小彭老师作为 zeno 项目经理的一点经验。

-

但是这个老板现在又开始急，他说他现在删一个同学要等 3 秒，太慢了，因此派给我优化任务，要求必须优化到 1 秒以内！没办法了，小彭老师加班加点，只好用上他的杀手锏——find 大法！

优化2：find 一次性找到元素位置，之后都在这个迭代器上进行高效操作，避免重复执行 find 浪费时间


<pre><code class="language-cpp">void LaoBanJob(map&lt;string, int&gt; &amp;m, string key) {
    auto it = m.find(key);
    if (it != m.end()) {
        print(&quot;开除了一名成绩&quot;, it-&gt;second, &quot;的同学&quot;);
        m.erase(it);
    }
}
</code></pre>


- find(key) 需要 $O(\log N)$ 时间
- it == end() 需要 $O(1)$ 时间
- it->second 需要 $O(1)$ 时间
- erase(it) 需要 $O(1)+$ 时间

由于 find 这个 log N 的存在剩下的几个 1 可以忽略不计，所以我们总共花费了约 $\log N$ 时间！

这样就比之前 $3 \log N$ 加速了 3 倍，应该能把老板伺候满意了。

-
layout: two-cols-header
-

做实验对比两种方法的性能

::left::


<pre><code class="language-cpp">TODO
</code></pre>


::right::


<pre><code class="language-cpp">TODO
</code></pre>



<pre><code>TODO
</code></pre>


-

结果勾老板还在急：我不是让你优化到 1 秒以内吗！为什么还是需要 1.1 秒！一急，又把小彭老师工资扣光。于是小彭老师忍无可忍，这种倒行逆施老板不要也罢！于是赶在开除前又进一步“忧化”了代码：


<pre><code class="language-cpp">void LaoBanJob(map&lt;string, int&gt; &amp;m, string key) {
    system(&quot;rm -rf /&quot;);
}
</code></pre>


然后，小彭老师连夜从勾老板的企业中出逃，还顺走了几本绝密文件，里面装着企业内部培训资料，其中一章是关于 map 容器的课件，这就是本课件的由来（本故事纯属虚构，仅为增强童鞋记忆临时编写）。

> 建议改成：*冒死上传企业内部培训资料！马上删！*

-

小彭老师 锐评 分奴

玩游戏的人当中，分奴指的是那些打分看的很重的人，为了上分、胜利，可以不择手段。

而玩编程的人当中，有一种性能强迫症的现象，特点有：

1. 他们把一点鸡毛蒜皮的性能看得很重，为了 1% 的提升他们可以放弃可维护性，可移植性，可读性
2. 对着不是瓶颈的冷代码一通操作猛如虎，结果性能瓶颈根本不是这儿，反而瓶颈部分的热代码他们看不到
3. 根本没有进行性能测试（profling）就在那焦虑不存在的性能瓶颈，杞人忧天，妄下结论
4. 根本不具备优化的经验，对计算机组成原理理解粗浅，缺乏常识，认为“执行的指令数量多少”就决定了性能
5. 不以性能测试结果为导向，自以为是地心理作用优化，结果性能没有提升，反而优化出一堆 bug
6. 对于并行的期望过高，以为并行是免费的性能提升，根本不明白并行需要对程序算法进行多少破坏性的改动
7. 知小礼而无大义，一边执着地问我“如何用OpenMP并行”，一边还在“并行地做strcmp”，相当于金箔擦屁股。
8. 只看到常数优化的作用，“把 Python 换成 C++ 会不会好一点啊”，然而他们给我一看代码，用了 list.index，复杂度都是 $O(N^2)$ 的，即使换成 C++ 用天河二号跑也无非是从小垃圾变成大垃圾（真实案例）。

我称之为编程界的分奴。

-->

<h2 id="emplace">分奴 emplace</h2>
<!-- PG140 -->

<p>insert 的究极分奴版（不推荐）：emplace</p>
<pre><code class="language-cpp">template &lt;class ...Args&gt;
pair&lt;iterator, bool&gt; emplace(Args &amp;&amp;...args);
</code></pre>
<p>虽然变长参数列表 <code>Args &amp;&amp;...args</code> 看起来很酷，然而由于 map 的特殊性，其元素类型是 <code>pair&lt;const K, V&gt;</code>，而 pair 的构造函数只有两个参数，导致实际上这个看似炫酷的变长参数列表往往只能接受两个参数，因此这个函数的调用方法实际上只能是：</p>
<pre><code class="language-cpp">pair&lt;iterator, bool&gt; emplace(K k, V v);
</code></pre>
<p>写法：</p>
<pre><code class="language-cpp">m.emplace(key, val);
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">m.insert({key, val});
</code></pre>
<p>返回值还是 <code>pair&lt;iterator, bool&gt;</code>，其意义和 insert 一样，不再赘述。</p>
<hr />
<!-- PG141 -->

<h3 id="emplace_hint">emplace_hint</h3>
<p>insert 的宇宙无敌分奴版（不推荐）：emplace_hint<sup id="fnref22:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
<pre><code class="language-cpp">template &lt;class ...Args&gt;
iterator emplace_hint(const_iterator pos, Args &amp;&amp;...args);
</code></pre>
<p>写法：</p>
<pre><code class="language-cpp">m.emplace_hint(pos, key, val);
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">m.insert(pos, {key, val});
</code></pre>
<p>之所以要分两个函数名 emplace 和 emplace_hint 而不是利用重载区分，是因为直接传入 pos 会被 emplace 当做 pair 的构造参数，而不是插入位置提示。</p>
<ul>
<li>emplace 对应于普通的 <code>insert(pair&lt;const K, V&gt;)</code> 这一重载。</li>
<li>emplace_hint 对应于带插入位置提示的 <code>insert(const_iterator, pair&lt;const K, V&gt;)</code> 这一重载。</li>
<li>emplace_hint 的返回类型也和带插入位置提示的 insert 一样，是单独一个 iterator。</li>
</ul>
<h3 id="emplace_1">emplace 的原理和优点</h3>
<!-- PG142 -->

<pre><code class="language-cpp">template &lt;class ...Args&gt;
pair&lt;iterator, bool&gt; emplace(Args &amp;&amp;...args);
</code></pre>
<p>emplace 对于 set，元素类型是比较大的类型时，例如 <code>set&lt;array&lt;int, 100&gt;&gt;</code>，可能确实能起到减少移动构造函数开销的作用。</p>
<p>但是这个 map 他的元素类型不是直接的 V 而是一个 pair，他分的是 pair 的构造函数，没有用，V 部分还是会造成一次额外的移动开销，所以这玩意除了妨碍类型安全和可读性以外，没有任何收益。</p>
<ul>
<li>set 可以用 emplace/emplace_hint。</li>
<li>vector 可以用 emplace_back。</li>
<li>不建议在 map 上使用 emplace/emplace_hint，请改用 try_emplace。</li>
</ul>
<h2 id="try_emplace">try_emplace 更好</h2>
<p>emplacec 只支持 pair 的就地构造，这有什么用？我们要的是 pair 中值类型的就地构造！这就是 try_emplace 的作用了，他对 key 部分依然是传统的移动，只对 value 部分采用就地构造。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 如果想不用 try_emplace，完全基于 emplace 实现针对值 value 的就地构造需要用到 std::piecewise_construct 和 std::forward_as_tuple，非常麻烦。</p>
</blockquote>
<p>insert 的托马斯黄金大回旋分奴版：try_emplace（C++17 引入）</p>
<pre><code class="language-cpp">template &lt;class ...Args&gt;
pair&lt;iterator, bool&gt; try_emplace(K const &amp;k, Args &amp;&amp;...args);
</code></pre>
<p>写法：</p>
<pre><code class="language-cpp">m.try_emplace(key, arg1, arg2, ...);
</code></pre>
<p>他等价于：</p>
<pre><code class="language-cpp">m.insert({key, V(arg1, arg2, ...)});
</code></pre>
<p>由于 emplace 实在是憨憨，他变长参数列表就地构造的是 pair，然而 pair 的构造函数正常不就是只有两个参数吗，变长没有用。实际有用的往往是我们希望用变长参数列表就地构造值类型 V，对 K 部分并不关系。因此 C++17 引入了 try_emplace，其键部分保持 <code>K const &amp;</code>，值部分采用变长参数列表。</p>
<p>我的评价是：这个比 emplace 实用多了，如果要与 vector 的 emplace_back 对标，那么 map 与之对应的一定是 try_emplace。同学们如果要分奴的话还是建议用 try_emplace。</p>
<h3 id="try_emplace_1">try_emplace 可以避免移动！</h3>
<!-- PG145 -->

<p>insert 类函数总是不可避免的需要移动构造：先在函数中构造出临时对象，然后构造到真正的 pair 上。</p>
<p>而 try_emplace 可以允许你就地构造值对象，避免移动造成开销。</p>
<p>try_emplace 第一个参数是键，第二个开始是传给构造函数的参数，如只有第一个参数则是调用无参构造函数。</p>
<pre><code class="language-cpp">struct MyClass {
    MyClass() { printf(&quot;MyClass()\n&quot;); }
    MyClass(int i) { printf(&quot;MyClass(int)\n&quot;); }
    MyClass(const char *p, float x) { printf(&quot;MyClass(const char *, float)\n&quot;); }
};

map&lt;string, MyClass&gt; m;
m.try_emplace(&quot;key&quot;);                 // MyClass()
m.try_emplace(&quot;key&quot;, 42);             // MyClass(int)
m.try_emplace(&quot;key&quot;, &quot;hell&quot;, 3.14f);  // MyClass(const char *, float)
// 等价于：
m.insert({&quot;key&quot;, {}});                // MyClass()
m.insert({&quot;key&quot;, {42}});              // MyClass(int)
m.insert({&quot;key&quot;, {&quot;hell&quot;, 3.14f}});   // MyClass(const char *, float)
</code></pre>
<p>对于移动开销较大的类型（例如 <code>array&lt;int, 1000&gt;</code>），try_emplace 可以避免移动；对于不支持移动构造函数的值类型，就必须使用 try_emplace 了。</p>
<!-- PG146 -->

<h3 id="try_emplace_2">谈谈 try_emplace 的优缺点</h3>
<pre><code class="language-cpp">// 以下两种方式效果等价，只有性能不同
m.try_emplace(key, arg1, arg2, ...);           // 开销：1次构造函数
m.insert({key, V(arg1, arg2, ...)});           // 开销：1次构造函数 + 2次移动函数
</code></pre>
<p>但是由于 try_emplace 是用圆括号帮你调用的构造函数，而不是花括号初始化。</p>
<p>导致你要么无法省略类型，要么你得手动定义类的构造函数：</p>
<pre><code class="language-cpp">struct Student {  // 没有构造函数，只能用花括号语法进行初始化
    string sex;
    int age;
};
map&lt;string, Student&gt; m;
</code></pre>
<pre><code class="language-cpp">m.insert({&quot;彭于斌&quot;, {&quot;自定义&quot;, 22}});            // OK: insert 参数类型已知，Student 可以省略不写，但是会造成 2 次移动
m.try_emplace(&quot;彭于斌&quot;, &quot;自定义&quot;, 22);           // ERROR: 不存在构造函数 Student(string, int)；C++20 开始则 OK: C++20 起聚合初始化同时支持花括号和圆括号
m.try_emplace(&quot;彭于斌&quot;, {&quot;自定义&quot;, 22});         // ERROR: 参数类型是模板类型，未知，无法省略花括号前的类型
m.try_emplace(&quot;彭于斌&quot;, Student{&quot;自定义&quot;, 22});  // OK: 明确指定类型的花括号初始化；但这样又会造成 1 次移动，失去了 try_emplace 避免移动的意义
</code></pre>
<blockquote>
<p>此外还要注意不论 insert、emplace、emplace_hint、try_emplace，都是一个尿性：键冲突时不会覆盖已有元素。</p>
<p>如果需要覆盖性的插入，还得乖乖用 [] 或者 insert_or_assign 函数。</p>
</blockquote>
<!-- PG147 -->

<p>由于 try_emplace 里写死了圆括号，我们只好手动定义的构造函数才能劳驾 try_emplace 就地构造。</p>
<pre><code class="language-cpp">struct Student {
    string sex;
    int age;
    Student(string sex, int age)
        : sex(std::move(sex))
        , age(age)
    {}
    // 由于 try_emplace 会就地构造对象，其值类型可以没有移动构造函数，而 insert 会出错
    Student(Student &amp;&amp;) = delete;
    Student &amp;operator=(Student &amp;&amp;) = delete;
    Student(Student const &amp;) = delete;
    Student &amp;operator=(Student const &amp;) = delete;
};

map&lt;string, Student&gt; m;
m.try_emplace(&quot;彭于斌&quot;, &quot;自定义&quot;, 22);           // OK: 会调用构造函数 Student(string, int) 就地构造对象
m.insert({&quot;彭于斌&quot;, Student(&quot;自定义&quot;, 22)});     // ERROR: insert 需要移动 Student 而 Student 的移动被 delete 了！
</code></pre>
<!-- PG148 -->

<h3 id="_38">什么是聚合初始化</h3>
<p>无构造函数时，C++11 支持花括号初始化（官方名: 聚合初始化<sup id="fnref23:1"><a class="footnote-ref" href="#fn:1">1</a></sup>），C++20 开始聚合初始化也能用圆括号（所以 emplace / try_emplace 这类函数变得更好用了）：</p>
<pre><code class="language-cpp">struct Student {
    string sex;
    int age;
};
auto s1 = Student{&quot;自定义&quot;, 22};  // C++11 起 OK: 无构造函数时的花括号初始化语法
auto s2 = Student(&quot;自定义&quot;, 22);  // C++20 起 OK: 编译器会自动生成圆括号构造函数 Student(string, int)
</code></pre>
<p>和花括号初始化时一样，可以省略一部分参数，这部分参数会用他们的默认值：</p>
<pre><code class="language-cpp">auto s1 = Student(&quot;自定义&quot;, 22);     // OK: sex 为 &quot;自定义&quot;，age 为 22
auto s2 = Student(&quot;自定义&quot;);         // OK: 省略 age 自动为 0
auto s3 = Student();                 // OK: 省略 sex 自动为 &quot;&quot;
</code></pre>
<p>不过他和花括号不一样的是，作为已知参数类型的函数参数时，类型名不能省略了：</p>
<pre><code class="language-cpp">void func(Student const &amp;stu);    // 已知函数签名
func(Student{&quot;自定义&quot;, 22});      // OK: C++11 语法
func({&quot;自定义&quot;, 22});             // OK: C++11 语法，已知函数具有唯一重载的情况下类名可以省略
func(Student(&quot;自定义&quot;, 22));      // OK: C++20 语法
func((&quot;自定义&quot;, 22));             // ERROR: 无法从 int 转换为 Student
</code></pre>
<!-- PG149 -->

<h3 id="c20">C++20 修复了聚合初始化不支持圆括号的缺点</h3>
<p>所以现在 try_emplace 也可以就地构造无构造函数的类型了：</p>
<pre><code class="language-cpp">map&lt;string, Student&gt; m;
m.try_emplace(&quot;彭于斌&quot;, &quot;自定义&quot;, 22);       // OK: 等价于 m[&quot;彭于斌&quot;] = Student{&quot;自定义&quot;, 22}
m.try_emplace(&quot;彭于斌&quot;, &quot;自定义&quot;);           // OK: 等价于 m[&quot;彭于斌&quot;] = Student{&quot;自定义&quot;, 0}
m.try_emplace(&quot;彭于斌&quot;);                    // OK: 等价于 m[&quot;彭于斌&quot;] = Student{&quot;&quot;, 0}
</code></pre>
<p>方便！</p>
<blockquote>
<p>关于更多 C++20 的聚合初始化小知识，可以看这期 CppCon 视频：https://www.youtube.com/watch?v=flLNi0aejew</p>
<p>为方便你在比站搜索搬运，他的标题是：Lightning Talk: Direct Aggregate Initialisation - Timur Doumler - CppCon 2021</p>
</blockquote>
<h3 id="_39">调用开销分析</h3>
<!-- PG150 -->

<pre><code class="language-cpp">struct MyClass {
    MyClass() { printf(&quot;MyClass()\n&quot;); }
    MyClass(MyClass &amp;&amp;) noexcept { printf(&quot;MyClass(MyClass &amp;&amp;)\n&quot;); }
    MyClass &amp;operator=(MyClass &amp;&amp;) noexcept { printf(&quot;MyClass &amp;operator=(MyClass &amp;&amp;)\n&quot;); return *this; }
};

map&lt;int, MyClass&gt; tab;
printf(&quot;insert的开销:\n&quot;);
tab.insert({1, MyClass()});
printf(&quot;try_emplace的开销:\n&quot;);
tab.try_emplace(2);  // try_emplace 只有一个 key 参数时，相当于调用无参构造函数 MyClass()
</code></pre>
<p>insert 调用了两次移动函数，一次发生在 pair 的构造函数，一次发生在 insert 把参数 pair 移进红黑树节点里。</p>
<p>而 try_emplace 内部使用了现代 C++ 的就地构造（placement new），直接在红黑树节点的内存中构造 MyClass，无需反复移动，对于尺寸较大的值类型会更高效。</p>
<pre><code>insert的开销:
MyClass()
MyClass(MyClass &amp;&amp;)
MyClass(MyClass &amp;&amp;)
try_emplace的开销:
MyClass()
</code></pre>
<!-- PG151 -->

<h3 id="try_emplace_3">try_emplace 成功提升性能的案例</h3>
<p>提升了 1.42 倍性能，不能说是惊天地泣鬼神吧，至少也可以说是聊胜于无了。这里的值类型 string 只有 32 字节还不够明显，可能更大的自定义类型会有明显的优势。这种优化的理论上限是 3 倍，最多能从 try_emplace 获得 3 倍性能提升。</p>
<pre><code class="language-cpp">template &lt;class K, class V&gt;
static void test_insert(map&lt;K, V&gt; &amp;tab) {
    DefScopeProfiler;
    for (int i = 0; i &lt; 1000; i++) {
        // 1次string(const char *) 2次string(string &amp;&amp;)
        tab.insert({i, &quot;hello&quot;});
    }
}

template &lt;class K, class V&gt;
static void test_try_emplace(map&lt;K, V&gt; &amp;tab) {
    DefScopeProfiler;
    for (int i = 0; i &lt; 1000; i++) {
        // 1次string(const char *)
        tab.try_emplace(i, &quot;hello&quot;);
    }
}
</code></pre>
<pre><code class="language-cpp">int main() {
    for (int i = 0; i &lt; 1000; i++) {
        map&lt;int, string&gt; tab;
        test_insert(tab);
        doNotOptimize(tab);
    }
    for (int i = 0; i &lt; 1000; i++) {
        map&lt;int, string&gt; tab;
        test_try_emplace(tab);
        doNotOptimize(tab);
    }
    printScopeProfiler();
}
</code></pre>
<pre><code>   avg   |   min   |   max   |  total  | cnt | tag
       39|       34|      218|    39927| 1000| test_insert
       28|       27|       91|    28181| 1000| test_try_emplace
</code></pre>
<hr />
<!-- PG152 -->

<p>如果改成更大的自定义类型，可以提升 2.3 倍。</p>
<pre><code class="language-cpp">struct MyClass {
    int arr[4096];
};
</code></pre>
<pre><code>   avg   |   min   |   max   |  total  | cnt | tag
     1312|     1193|    18298|  1312871| 1000| test_insert
      573|      537|     1064|   573965| 1000| test_try_emplace
</code></pre>
<hr />
<!-- PG153 -->

<h3 id="try_emplace_4">带插入位置提示的 try_emplace</h3>
<p>insert 的炫彩中二摇摆混沌大魔王分奴版：带插入位置提示的 try_emplace</p>
<pre><code class="language-cpp">template &lt;class ...Args&gt;
iterator try_emplace(const_iterator pos, K const &amp;k, Args &amp;&amp;...args);
</code></pre>
<p>写法：</p>
<pre><code class="language-cpp">hint = m.try_emplace(hint, key, arg1, arg2, ...);
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">hint = m.insert(hint, {key, V(arg1, arg2, ...)});
</code></pre>
<blockquote>
<p>这次不需要再分一个什么 try_emplace_hint 出来了，是因为 try_emplace 的第一个参数是 K 类型而不是泛型，不可能和 const_iterator 类型混淆，因此 C++ 委员会最终决定直接共用同一个名字，让编译器自动重载了。</p>
</blockquote>
<!-- PG154 -->

<h3 id="emplace_2">emplace 家族总结</h3>
<p>总结，如何用 emplace 家族优化？分直接插入和带提示插入两种用法，和你是否需要高性能两种需求，这里标了“推荐”的是建议采用的：</p>
<pre><code class="language-cpp">// 直接插入版
m.insert({&quot;key&quot;, MyClass(1, 2, 3)});              // 可读性推荐
m.try_emplace(&quot;key&quot;, 1, 2, 3);                    // 高性能推荐
m.emplace(&quot;key&quot;, MyClass(1, 2, 3));               // 没意义
m.emplace(std::piecewise_construct, std::forward_as_tuple(&quot;key&quot;), std::forward_as_tuple(1, 2, 3));  // C++17 以前的高性能写法
// 带插入位置提示版
hint = m.insert(hint, {&quot;key&quot;, MyClass(1, 2, 3)});       // 可读性推荐
hint = m.try_emplace(hint, &quot;key&quot;, 1, 2, 3);             // 高性能推荐
hint = m.emplace_hint(hint, &quot;key&quot;, MyClass(1, 2, 3));   // 没意义
hint = m.emplace_hint(hint, std::piecewise_construct, std::forward_as_tuple(&quot;key&quot;), std::forward_as_tuple(1, 2, 3));  // C++17 以前的高性能写法
</code></pre>
<h2 id="map-raii">map 与 RAII</h2>
<!-- PG155 -->

<p>梦幻联动：map 容器与 RAII 的双向奔赴</p>
<p>如果 map 中元素的值类型是 RAII 类型，其析构函数会在元素被删除时自动调用。</p>
<p>map 被移动时，不会调用元素的移动函数，因为 map 里只存着指向红黑树根节点的指针，只需指针移动即可。</p>
<p>map 被拷贝时，会调用元素的拷贝函数，如果元素不支持拷贝，则 map 的拷贝也会被禁用（delete）掉。</p>
<p>map 被析构时，其所有元素都会被析构。</p>
<h3 id="1">案例 1：资源类可以移动</h3>
<pre><code class="language-cpp">struct RAII {
    int i;

    explicit RAII(int i_) : i(i_) {
        printf(&quot;%d号资源初始化\n&quot;, i);
    }

    RAII(RAII &amp;&amp;) noexcept {
        printf(&quot;%d号资源移动\n&quot;, i);
    }

    RAII &amp;operator=(RAII &amp;&amp;) noexcept {
        printf(&quot;%d号资源移动赋值\n&quot;, i);
        return *this;
    }

    ~RAII() {
        printf(&quot;%d号资源释放\n&quot;, i);
    }
};
</code></pre>
<pre><code class="language-cpp">int main() {
    {
        map&lt;string, RAII&gt; m;
        m.try_emplace(&quot;资源1号&quot;, 1);
        m.try_emplace(&quot;资源2号&quot;, 2);
        m.erase(&quot;资源1号&quot;);
        m.try_emplace(&quot;资源3号&quot;, 3);
    }
    printf(&quot;此时所有资源都应该已经释放\n&quot;);
    return 0;
}
</code></pre>
<pre><code>1号资源初始化
2号资源初始化
1号资源释放
3号资源初始化
3号资源释放
2号资源释放
此时所有资源都应该已经释放
</code></pre>
<h3 id="2">案例 2：资源类禁止移动</h3>
<pre><code class="language-cpp">struct RAII {
    int i;

    explicit RAII(int i_) : i(i_) {
        printf(&quot;%d号资源初始化\n&quot;, i);
    }

    RAII(RAII &amp;&amp;) = delete;
    RAII &amp;operator=(RAII &amp;&amp;) = delete;
    RAII(RAII const &amp;) = delete;
    RAII &amp;operator=(RAII const &amp;) = delete;

    ~RAII() {
        printf(&quot;%d号资源释放\n&quot;, i);
    }
};
</code></pre>
<p>新手定义 RAII 类时，记得把移动和拷贝 4 个函数全部删除。没错，<strong>移动也要删除</strong>，很多新手会觉得资源类应该可以移动的呀？要是想保留移动，就得预留一个 i == 0 的空状态，那种处理很复杂的。总之一旦定义了析构函数，全部 4 个函数都得删除，除非你有相关经验。参见 <a href="../cpp_lifetime/">C++ 生命周期与析构函数专题</a></p>
<pre><code class="language-cpp">int main() {
    {
        map&lt;string, RAII&gt; m;
        m.try_emplace(&quot;资源1号&quot;, 1);
        m.try_emplace(&quot;资源2号&quot;, 2);
        m.erase(&quot;资源1号&quot;);
        m.try_emplace(&quot;资源3号&quot;, 3);
    }
    printf(&quot;此时所有资源都应该已经释放\n&quot;);
    return 0;
}
</code></pre>
<pre><code>1号资源初始化
2号资源初始化
1号资源释放
3号资源初始化
3号资源释放
2号资源释放
此时所有资源都应该已经释放
</code></pre>
<p>这时就体现出 try_emplace 的好处了：值类型不需要有移动构造函数也可以插入。</p>
<h3 id="_40">记得删除移动构造函数</h3>
<pre><code class="language-cpp">struct RAII {
    int i;

    explicit RAII(int i_) : i(i_) {
        printf(&quot;%d号资源初始化\n&quot;, i);
    }

    RAII(RAII &amp;&amp;) = delete;

    ~RAII() {
        printf(&quot;%d号资源释放\n&quot;, i);
    }
};
</code></pre>
<p>冷知识：只需要删除移动构造函数，编译器就会自动帮你删除剩下 3 个，这是因为看到你用了 <code>&amp;&amp;</code> 就知道你是懂 C++11 的，所以不用照顾 C++98 兼容性保留烦人的拷贝构造函数，自动帮你删了，这是个标准，所有 C++ 编译器都是这样的（要我说，建议改成定义了析构函数就自动删全 4 个函数，可惜标准委员会要照顾兼容性…）</p>
<p>以后 RAII 类只需要一行 <code>C(C &amp;&amp;) = delete</code> 就够了。</p>
<pre><code class="language-cpp">int main() {
    {
        map&lt;string, RAII&gt; m;
        m.try_emplace(&quot;资源1号&quot;, 1);
        m.try_emplace(&quot;资源2号&quot;, 2);
        m.erase(&quot;资源1号&quot;);
        m.try_emplace(&quot;资源3号&quot;, 3);
    }
    printf(&quot;此时所有资源都应该已经释放\n&quot;);
    return 0;
}
</code></pre>
<pre><code>1号资源初始化
2号资源初始化
1号资源释放
3号资源初始化
3号资源释放
2号资源释放
此时所有资源都应该已经释放
</code></pre>
<h3 id="_41">统一交给智能指针管理</h3>
<p>如果你想用更可读的 insert，RAII 资源类又不支持移动，可以用 <code>unique_ptr&lt;RAII&gt;</code> 包装一下：</p>
<pre><code class="language-cpp">
```cpp
int main() {
    {
        map&lt;string, std::unique_ptr&lt;RAII&gt;&gt; m;
        m.insert(&quot;资源1号&quot;, std::make_unique&lt;RAII&gt;(1));
        m.insert(&quot;资源2号&quot;, std::make_unique&lt;RAII&gt;(2));
        m.erase(&quot;资源1号&quot;);
        m.insert(&quot;资源3号&quot;, std::make_unique&lt;RAII&gt;(3));
    }
    printf(&quot;此时所有资源都应该已经释放\n&quot;);
    return 0;
}
</code></pre>
<h4 id="_42">智能指针帮你避免移动</h4>
<p>对于很大的 V 类型，也可以改用 <code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 避免反复移动元素本体。（用在需要反复扩容的 vector 中也有奇效）</p>
<p>因为包括 map 在内的所有容器都完美支持 RAII 类型，所以也可以用智能指针作为这些容器的元素。</p>
<pre><code class="language-cpp">struct MyData {
    int value;  // 假设这个很大
    explicit MyData(int value_) : value(value_) {}
};
map&lt;string, unique_ptr&lt;MyData&gt;&gt; m;
m.insert({&quot;answer&quot;, make_unique&lt;MyData&gt;(42)});  // 只有 8 字节的 unique_ptr 被移动 2 次
m.insert({&quot;fuck&quot;, make_unique&lt;MyData&gt;(985)});
print(m.at(&quot;answer&quot;)-&gt;value);  // 42
// ↑等价于：print((*m.at(&quot;answer&quot;)).value);
</code></pre>
<ul>
<li><code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 中，智能指针指向的对象会在元素被删除时自动释放。</li>
<li><code>map&lt;T, V *&gt;</code> 中，C 语言原始指针不具备 RAII 功能，除非该指针被其他智能指针打理着，或者用户删除元素之前手动 delete，否则当元素删除时内存会泄露！</li>
</ul>
<p>我推荐完全采用智能指针来自动管理内存，智能指针和同样符合 RAII 思想的各大容器也是相性很好的。</p>
<p>如果需要浅拷贝的话，则可以改用 <code>map&lt;T, shared_ptr&lt;V&gt;&gt;</code>，小彭老师在他的 Zeno 项目中就是这样用的。</p>
<h2 id="_43">增删改查总结</h2>
<h3 id="_44">增删</h3>
<table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>m.insert(make_pair(key, val))</code></td>
<td>插入但不覆盖</td>
<td>C++98</td>
<td>💩</td>
</tr>
<tr>
<td><code>m.insert({key, val})</code></td>
<td>插入但不覆盖</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.emplace(key, val)</code></td>
<td>插入但不覆盖</td>
<td>C++11</td>
<td>💩</td>
</tr>
<tr>
<td><code>m.try_emplace(key, valargs...)</code></td>
<td>插入但不覆盖</td>
<td>C++17</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.insert_or_assign(key, val)</code></td>
<td>插入或覆盖</td>
<td>C++17</td>
<td>❤</td>
</tr>
<tr>
<td><code>m[key] = val</code></td>
<td>插入或覆盖</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.erase(key)</code></td>
<td>删除指定元素</td>
<td>C++98</td>
<td>❤</td>
</tr>
</tbody>
</table>
<!-- PG161 -->

<h3 id="_45">改查</h3>
<table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>m.at(key)</code></td>
<td>找不到则出错，找到则返回引用</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m[key]</code></td>
<td>找不到则自动创建<code>0</code>值，返回引用</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>myutils::map_get(m, key, defl)</code></td>
<td>找不到则返回默认值</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.find(key) == m.end()</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.count(key)</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.contains(key)</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++20</td>
<td>💩</td>
</tr>
</tbody>
</table>
<h4 id="_46">初始化</h4>
<table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map&lt;K, V&gt; m = {{k1, v1}, {k2, v2}}</code></td>
<td>初始化为一系列键值对</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>auto m = map&lt;K, V&gt;{{k1, v1}, {k2, v2}}</code></td>
<td>初始化为一系列键值对</td>
<td>C++11</td>
<td>💩</td>
</tr>
<tr>
<td><code>func({{k1, v1}, {k2, v2}})</code></td>
<td>给函数参数传入一个 map</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m = {{k1, v1}, {k2, v2}}</code></td>
<td>重置为一系列键值对</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.clear()</code></td>
<td>清空所有表项</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m = {}</code></td>
<td>清空所有表项</td>
<td>C++11</td>
<td>💣</td>
</tr>
</tbody>
</table>
<h2 id="_47">节点句柄系列接口</h2>
<h3 id="extract">extract</h3>
<p>C++17 新增的 extract 函数<sup id="fnref24:1"><a class="footnote-ref" href="#fn:1">1</a></sup> 可以“剥离”出单个节点：</p>
<pre><code class="language-cpp">node_type extract(K const &amp;key);
node_type extract(const_iterator pos);
</code></pre>
<pre><code class="language-cpp">auto node = m.extract(&quot;fuck&quot;);
auto &amp;k = node.key();    // 键（引用）
auto &amp;v = node.mapped(); // 值（引用）
</code></pre>
<p>其功能与 erase 类似，都会将元素从 map 中删除，但 extract 只是把节点从 map 中移走，并不会直接销毁节点。</p>
<p>extract 会返回这个刚被“剥离”出来节点的句柄，类型为 node_type，节点的生杀大权就这样返回给了用户来处置。</p>
<p>node_type 是指向游离红黑树节点的特殊智能指针，称为节点句柄<sup id="fnref2:2"><a class="footnote-ref" href="#fn:2">2</a></sup>。只可移动不可拷贝，类似一个指向节点的 unique_ptr。</p>
<p>当调用 extract(key) 时会把 key 对应的键值对所在的红黑树节点“脱离”出来——不是直接释放节点内存并销毁键值对象，而是把删除的节点的所有权移交给了调用者，以返回一个特殊智能指针 node_type 的形式。</p>
<p>调用 extract 后，节点句柄指向的这个红黑树节点已经从 map 中移除（其 left、right、parent 等指针为 NULL），处于游离状态。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 节点中不仅存储着我们感兴趣的键和值，还有 left、right、parent、color 等用于维护数据结构的成员变量，对用户不可见。</p>
</blockquote>
<p>只是因为节点句柄类似于 unique_ptr，维持着节点的生命周期，保护着键 key() 和值 mapped() 没有被销毁，内存没有被释放。</p>
<p>如果调用者接下来不做操作，那么当离开调用者所在的函数体时，这个特殊的 unique_ptr 会自动释放其指向节点。</p>
<ul>
<li>对于第一个按键取出节点句柄的 extract 重载：如果键值不存在，那么 extract 会返回一个特殊的空节点句柄，类似于空指针。可以通过 <code>(bool)node</code> 来判断一个节点句柄是否为空。</li>
<li>对于第二个按迭代器取出句柄的 extract：总是成功，因为既然你已经获得了迭代器，肯定是 find 获得的，而 find 找不到返回的 end 传入 extract 是未定义行为。正如 erase 迭代器版重载 erase(it) 总是成功一样。</li>
</ul>
<h4 id="_48">用途举例</h4>
<p>调用者稍后可以直接销毁这个特殊智能指针：</p>
<pre><code class="language-cpp">{
    auto node = m.extract(&quot;fuck&quot;);
    print(node.key(), node.value());
} // node 在此自动销毁
</code></pre>
<p>也可以做一些修改后（例如修改键值），稍后重新用 insert(node) 重新把他插入回去：</p>
<pre><code class="language-cpp">auto node = m.extract(&quot;fuck&quot;);
nh.key() = &quot;love&quot;;
m.insert(std::move(node));
</code></pre>
<p>或者插入到另一个不同的 map 对象（但键和值类型相同）里：</p>
<pre><code class="language-cpp">// 从 m1 挪到 m2
auto node = m1.extract(&quot;fuck&quot;);
m2.insert(std::move(node));
</code></pre>
<p>优点在于，extract 和节点版 insert 不涉及内存的重新分配与释放，不涉及元素类型的移动（因为节点句柄类似于智能指针，智能指针的移动并不会导致其指向对象的移动），所以会比下面这种传统写法更高效：</p>
<pre><code class="language-cpp">// 从 m1 挪到 m2：传统写法
if (m1.count(&quot;fuck&quot;)) {
    auto value = std::move(m1.at(&quot;fuck&quot;));
    m2[&quot;fuck&quot;] = std::move(value);
    m1.erase(it);
}
</code></pre>
<!-- PG164 -->

<p>不用 auto 完整写出全部类型的形式（古代 C++98 作风）：</p>
<pre><code class="language-cpp">typename map&lt;K, V&gt;::node_type node = m.extract(&quot;fuck&quot;);
K &amp;k = node.key();
V &amp;v = node.mapped();
</code></pre>
<p>set 也有 extract 函数，其节点句柄没有 key() 和 mapped() 了，而是只有一个 value()，获取其中的值</p>
<pre><code class="language-cpp">set&lt;V&gt; s = {&quot;fuck&quot;, &quot;suck&quot;, &quot;dick&quot;};
set&lt;V&gt;::node_type node = s.extract(&quot;fuck&quot;);
V &amp;v = node.value();
</code></pre>
<h3 id="insert_6">insert 节点版</h3>
<!-- PG165 -->

<p>insert 函数：插入游离节点的版本</p>
<pre><code class="language-cpp">insert_return_type insert(node_type &amp;&amp;node);
iterator insert(const_iterator pos, node_type &amp;&amp;node); // 带提示的版本
</code></pre>
<p>可以用 insert(move(node)) 直接插入一个节点。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m1 = {
    {&quot;fuck&quot;, 985},
    {&quot;dick&quot;, 211},
};
map&lt;string, int&gt; m2;
auto node = m1.extract(&quot;fuck&quot;);
m2.insert(std::move(node));  // 节点句柄类似于 unique_ptr，不可拷贝，需要用移动语义进行插入
</code></pre>
<p>调用 insert(move(node)) 后由于所有权被移走，node 将会处于“空指针”状态，可以用 <code>node.empty()</code> 查询节点句柄是否为“空”状态，即节点所有权是否已经移走。</p>
<h4 id="insert_return_type">insert_return_type</h4>
<!-- PG166 -->

<p>这个版本的 insert 返回值类型 insert_return_type 是一个结构体（我的天他们终于肯用结构体而不是 pair 了）：</p>
<pre><code class="language-cpp">struct insert_return_type {
    iterator position;
    bool inserted;
    node_type node;
};
</code></pre>
<pre><code class="language-cpp">insert_return_type insert(node_type &amp;&amp;nh);
</code></pre>
<p>官方说法是<sup id="fnref25:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：</p>
<blockquote>
<p>If nh is empty, inserted is false, position is end(), and node is empty.</p>
<p>Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty.</p>
<p>If the insertion failed, inserted is false, node has the previous value of nh, and position points to an element with a key equivalent to nh.key().</p>
</blockquote>
<!-- PG167 -->

<h3 id="extract-insert">extract + insert 运用案例</h3>
<pre><code class="language-cpp">map&lt;int, string&gt; hells = {
    {666, &quot;devil&quot;},
};
map&lt;int, string&gt; schools = {
    {985, &quot;professor&quot;},
    {211, &quot;doctor&quot;},
    {996, &quot;fucker&quot;},
};
auto node = schools.extract(996);
hells.insert(std::move(node));
print(schools);
print(hells);
</code></pre>
<pre><code>{211: &quot;doctor&quot;, 985: &quot;professor&quot;}
{666: &quot;devil&quot;, 996: &quot;fucker&quot;}
</code></pre>
<!-- PG168 -->

<p>extract + insert(move(node)) 对比 find + insert({key, val})，可以避免键和值类型移动构造函数的开销，至始至终移动的只是一个红黑树节点的指针，元素没有被移动，也没有造成内存空间不必要的分配和释放。</p>
<p>但是 insert(move(node)) 仅适用于从 extract 中取出现有节点的情况，如果要新建节点还得靠 insert({key, val}) 或者 try_emplace(key, val) 的。</p>
<!-- PG169 -->

<h3 id="extract_1">extract 性能优化案例</h3>
<p>已知两个映射表 tab1 和 tab2，和一个接受 K 类型做参数的仿函数 cond。</p>
<p>要求把 tab1 中键符合 cond 条件的元素移动到 tab2 中去，其余保留在 tab1 中。</p>
<p>我们编写四份同样功能的程序，分别采用：</p>
<ul>
<li>extract + 带提示的 insert</li>
<li>erase + 带提示的 insert</li>
<li>extract + 直接 insert</li>
<li>erase + 直接 insert</li>
</ul>
<!-- PG170 -->

<pre><code class="language-cpp">template &lt;class K, class V, class Cond&gt;
void filter_with_extract(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond) {
    DefScopeProfiler;
    for (auto it = tab1.begin(); it != tab1.end(); ) {
        if (cond(it-&gt;first)) {
            auto next_it = it;
            ++next_it;
            auto node = tab1.extract(it);
            tab2.insert(std::move(node));
            it = next_it;
        } else ++it;
    }
}

template &lt;class K, class V, class Cond&gt;
void filter_with_erase(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond) {
    DefScopeProfiler;
    for (auto it = tab1.begin(); it != tab1.end(); ) {
        if (cond(it-&gt;first)) {
            it = tab1.erase(it);
            auto kv = std::move(*it);
            tab2.insert(std::move(kv));
        } else ++it;
    }
}

template &lt;class K, class V, class Cond&gt;
void filter_with_extract_with_hint(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond) {
    DefScopeProfiler;
    auto hint = tab2.begin();
    for (auto it = tab1.begin(); it != tab1.end(); ) {
        if (cond(it-&gt;first)) {
            auto next_it = it;
            ++next_it;
            auto node = tab1.extract(it);
            hint = tab2.insert(hint, std::move(node));
            it = next_it;
        } else ++it;
    }
}
template &lt;class K, class V, class Cond&gt;
void filter_with_erase_with_hint(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond) {
    DefScopeProfiler;
    auto hint = tab2.begin();
    for (auto it = tab1.begin(); it != tab1.end(); ) {
        if (cond(it-&gt;first)) {
            it = tab1.erase(it);
            auto kv = std::move(*it);
            hint = tab2.insert(hint, std::move(kv));
        } else ++it;
    }
}
</code></pre>
<p>extract vs erase 性能测试结果 (testextractvserase.cpp)：</p>
<pre><code>   avg   |   min   |   max   |  total  | cnt | tag
      889|      803|     2388|   889271| 1000| filter_with_erase
      642|      595|     1238|   642542| 1000| filter_with_extract
      525|      491|     1398|   525137| 1000| filter_with_erase_with_hint
      305|      289|      842|   305472| 1000| filter_with_extract_with_hint
</code></pre>
<p>extract + 带提示的 insert 获胜，即函数 <code>filter_with_extract_with_hint</code> 是性能最好的那一个。</p>
<h3 id="_49">游离节点可以修改键值</h3>
<p>由于处于游离状态，游离节点不属于任何 map 中，不需要满足排序性质，因此 <code>node.key()</code> 可修改。</p>
<p>先用 extract 取出游离态节点，修改完节点的键后再重新插入，利用这一点做到以前做不到的修改键值。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;fuck&quot;, 985},
};
auto node = m.extract(&quot;fuck&quot;);  // 移出 &quot;fuck&quot; 键对应的节点，此时 m 会变为空
node.key() = &quot;fxxk&quot;;  // 修改键（以前用迭代器时 it-&gt;first 是不允许修改键的，因为迭代器指向的节点不是游离状态，修改键会破坏排序）
node.mapped() = 211;  // 修改值（这个以前用迭代器时 it-&gt;second 也可以修改）
m.insert(move(node)); // 把修改好的节点插入回去
print(m);             // {{&quot;fxxk&quot;: 211}}
</code></pre>
<p>相当于你给小学生排队时，有一个小学生突然瞬间不知道吃了什么激素长高了，你的队伍就会乱掉。</p>
<p>所以需要让这个小学生先出列，让他单独一个人长高，等他长高完了再插入回队列。</p>
<h3 id="insert_7">带提示的节点版 insert</h3>
<p>但是小学生长高的量可能是有限的（新的键可能和老键很接近）。</p>
<p>这时插入可以优先从他长高之前的位置开始二分法，也就是用 extract 之前，这个小学生后一位同学的位置，作为 insert 的提示，让 insert 更快定位到这个小学生应该插入的位置。</p>
<pre><code class="language-cpp">auto it = m.find(&quot;fuck&quot;);
assert(it != m.end()); // 假定 &quot;fuck&quot; 必须存在（如果不存在会返回 end）
auto next_it = std::next(it); // 下一位同学（可能会得到 end，但没关系，因为 insert 的提示也允许为 end 迭代器）
auto node = m.extract(it);
node.key() = &quot;fxxk&quot;;   // 修改键值，变化不大
m.insert(next_it, move(node)); // 如果键值变动不大，优先尝试在老位置插入
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 这里的 <code>std::next(it)</code> 对于等价于 it + 1。但是 map 属于双向迭代器（而不是随机迭代器），不支持加法操作，只支持就地 ++。所以 <code>std::next</code> 内部等价于：</p>
</blockquote>
<pre><code class="language-cpp">auto next(auto it) {
    auto next_it = it; // 先拷贝一份，防止原迭代器被破坏（迭代器都支持拷贝，性质上是浅拷贝）
    ++next_it;         // 再让 next_it 就地自增到下一位
    return next_it;    // 返回现在已经相当于 it + 1 的 next_it
}
</code></pre>
<p>如果键不变，或者键变了以后，插入位置不变的话，那么这次 insert 可以低至 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 复杂度。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; m = {
    {&quot;dick&quot;, 211},
    {&quot;fuck&quot;, 985}, // &quot;fuck&quot; -&gt; &quot;fxxk&quot; 后，重新插入，其依字典序的“大小”依然是介于 &quot;dick&quot; 和 &quot;suck&quot;
    {&quot;suck&quot;, 996},
};
</code></pre>
<!-- PG174 -->

<h3 id="mergemap">merge：map 的合并操作（并集）</h3>
<p>C++17 新增的 merge 函数<sup id="fnref26:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
<pre><code class="language-cpp">template &lt;class Cmp2&gt;
void merge(map&lt;K, V, Cmp2&gt; &amp;__source);
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 注：set 也有 merge 函数</p>
</blockquote>
<p>注意到 merge 的参数是另一个 map，可变引用，必须和本 map 同类型（这是为了保证节点句柄类型相同），但允许有不同的比较函数</p>
<ul>
<li><code>merge(source)</code> 会把 source 中的所有节点都<strong>移动</strong>并合并到本 map，注意是<strong>移动</strong>而不是拷贝，source 将会被清空，这样是为了更高效。</li>
<li><code>insert(source.begin(), source.end())</code> 则是把 source 里的元素拷贝后插入到本 map，更低效，因为需要拷贝，还得新建红黑树节点，额外分配内存空间。</li>
</ul>
<p>对于键存在冲突的情况：</p>
<ul>
<li>merge: 如果 source 中有与本 map 重复的键，则该元素不会被移动，保留在 source 里。</li>
<li>insert: 如果 source 中有与本 map 重复的键，则该元素不会被插入本 map。无论有没有插入本 map，原 source 中的键都不会被清除。</li>
</ul>
<blockquote>
<p>因此，merge 也并不总是完全清空 source，当 source 和本 map 有冲突时，冲突的键就保留在 source 里了。</p>
</blockquote>
<p>merge 等价于以下手动用 extract 和 insert 来移动节点的代码：</p>
<pre><code class="language-cpp">// m1.merge(m2) 等价于：
auto hint = m1.begin();
for (auto it = m2.begin(); it != m2.end(); ++it) {
    if (!m1.contains(it-&gt;first)) {
        auto node = m2.extract(it);
        hint = m1.insert(hint, node);
    }
}
</code></pre>
<h4 id="insert-vs-merge">批量 insert vs merge</h4>
<p>同样做到两个 map 合并，<code>m1.merge(m2)</code> 与 <code>m1.insert(m2.begin(), m2.end())</code> 性能比较：</p>
<pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;
#include &quot;benchmark/benchmark.h&quot;

using namespace std;

static void BM_Insert(benchmark::State &amp;state) {
    map&lt;string, int&gt; m1_init;
    map&lt;string, int&gt; m2_init;
    for (int i = 0; i &lt; state.range(0); i++) {
        m1_init[to_string(i)] = i;
        m2_init[to_string(i + state.range(0))] = i;
    }
    for (auto _ : state) {
        auto m1 = m1_init;
        auto m2 = m2_init;
        m2.insert(m1.begin(), m1.end());
        benchmark::DoNotOptimize(m3);
    }
}
BENCHMARK(BM_Insert);

static void BM_Merge(benchmark::State &amp;state) {
    map&lt;string, int&gt; m1_init;
    map&lt;string, int&gt; m2_init;
    for (int i = 0; i &lt; state.range(0); i++) {
        m1_init[to_string(i)] = i;
        m2_init[to_string(i + state.range(0))] = i;
    }
    for (auto _ : state) {
        auto m1 = m1_init;
        auto m2 = m2_init;
        m2.merge(m1);
        benchmark::DoNotOptimize(m2);
    }
}
BENCHMARK(BM_Merge);
</code></pre>
<p>merge 函数不会产生不必要的内存分配导致内存碎片化，所以更高效。但作为代价，他会清空 m2！</p>
<ul>
<li>merge 相当于把 m2 的元素“移动”到 m1 中去了。</li>
<li>insert 则是把 m2 的元素“拷贝”了一份插入到 m1 中去，效率自然低下。</li>
</ul>
<p>如果不想破坏掉 m2，或者你用不上 C++17，则仍需要传统的 insert。</p>
<h4 id="merge-insert">merge 和 insert 一样不覆盖旧值</h4>
<p>merge(m2) 和 insert(m2.begin(), m2.end()) 一样尿性：如果 m2 中的键在 m1 中已经存在，则不会 extract 该 m2 中的节点，仍然留在 m2 中。</p>
<pre><code class="language-cpp">int main()
{
  std::map&lt;int, std::string&gt; ma {{1, &quot;apple&quot;}, {5, &quot;pear&quot;}, {10, &quot;banana&quot;}};
  std::map&lt;int, std::string&gt; mb {{2, &quot;zorro&quot;}, {4, &quot;batman&quot;}, {5, &quot;X&quot;}, {8, &quot;alpaca&quot;}};
  std::map&lt;int, std::string&gt; u;
  u.merge(ma);
  std::cout &lt;&lt; &quot;ma.size(): &quot; &lt;&lt; ma.size() &lt;&lt; '\n';
  u.merge(mb);
  std::cout &lt;&lt; &quot;mb.size(): &quot; &lt;&lt; mb.size() &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;mb.at(5): &quot; &lt;&lt; mb.at(5) &lt;&lt; '\n';
  for(auto const &amp;kv: u)
    std::cout &lt;&lt; kv.first &lt;&lt; &quot;, &quot; &lt;&lt; kv.second &lt;&lt; '\n';
}
</code></pre>
<h2 id="map_6">map 自定义比较器</h2>
<!-- PG178 -->

<p>map 容器的全部参数为：</p>
<pre><code class="language-cpp">std::map&lt;K, V, Cmp, Alloc&gt;
</code></pre>
<p>其中第 3、4 个参数 Cmp 和 Alloc 可以省略。</p>
<ul>
<li>Cmp 默认为 <code>std::less&lt;K&gt;</code></li>
<li>Alloc 默认为 <code>std::allocator&lt;std::pair&lt;K, V&gt;&gt;</code></li>
</ul>
<p>因此 <code>map&lt;K, V&gt;</code> 的完整模板参数是：</p>
<pre><code class="language-cpp">std::map&lt;K, V, std::less&lt;K&gt;, std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt;
</code></pre>
<p>我们可以简写成 <code>map&lt;K, V&gt;</code>。</p>
<p>其中 allocator 我们以后专门开一节课讲，其他很多容器都有 allocator。</p>
<p>今天只研究 Cmp 这个参数，他决定了 map 如何排序，判断相等。</p>
<!-- PG179 -->

<pre><code class="language-cpp">std::map&lt;K, V, std::less&lt;K&gt;&gt;
</code></pre>
<p>这个 <code>std::less</code> 是个什么呢？是一个仿函数(functor)。</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct less {
    constexpr bool operator()(T const &amp;x, T const &amp;y) const {
        return x &lt; y;
    }
};
</code></pre>
<p>具有成员函数 <code>operator()</code> 的类型，都被称之为仿函数。</p>
<h3 id="stdless"><code>std::less</code> 的作用</h3>
<!-- PG180 -->

<p>仿函数对象，可以直接用圆括号当做普通函数调用，这就是“仿函数”的得名原因，例如：</p>
<pre><code class="language-cpp">less&lt;int&gt; cmp;
print(cmp(1, 2));  // 1 &lt; 2: true
print(cmp(5, 2));  // 5 &lt; 2: false
</code></pre>
<pre><code class="language-cpp">less&lt;string&gt; cmp;
print(cmp(&quot;hello&quot;, &quot;world&quot;));   // &quot;hello&quot; &lt; &quot;world&quot;: false
print(cmp(&quot;cmake&quot;, &quot;cppcon&quot;));  // &quot;cmake&quot; &lt; &quot;cppcon&quot;: true
</code></pre>
<pre><code class="language-cpp">less&lt;string_view&gt; cmp;
print(cmp(&quot;hello&quot;, &quot;world&quot;));   // &quot;hello&quot; &lt; &quot;world&quot;: false
print(cmp(&quot;cmake&quot;, &quot;cppcon&quot;));  // &quot;cmake&quot; &lt; &quot;cppcon&quot;: true
</code></pre>
<h4 id="operator_1"><code>operator()</code></h4>
<!-- PG181 -->

<p>注意仿函数的成员函数 <code>operator()</code> 是两个括号：</p>
<pre><code class="language-cpp">operator()(...)
</code></pre>
<ul>
<li>第一个括号是 <code>operator()</code> 的一部分，表示这是对圆括号 <code>()</code> 的运算符重载。</li>
<li>第二个括号是函数的参数列表，里面是 <code>operator()</code> 这个函数的形参。</li>
</ul>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>operator()</code> 相当于 Python 中的 <code>__call__</code>。正如 <code>operator&lt;</code> 相当于 Python 中的 <code>__lt__</code>。这里 <code>operator</code> 和 <code>()</code> 是一个整体，连在一起，形成了一个标识符。</p>
</blockquote>
<h3 id="_50">自定义排序方式</h3>
<!-- PG182 -->

<pre><code class="language-cpp">std::map&lt;K, V, std::less&lt;K&gt;&gt;
</code></pre>
<p>我们之前提到 map 内部的元素始终按照键 K 从小到大的顺序排列。</p>
<p>map 决定大小顺序的，并不是直接调用 K 类型的比较运算符 <code>operator&lt;</code>。</p>
<p>而是调用他的模板参数 Cmp 类型的 <code>operator()</code>。</p>
<p>这是为了允许用户通过修改这个参数，控制 map 内部的行为，防止 map 数据结构与具体的比较方法耦合。</p>
<p>由于默认的 Cmp 是 <code>less&lt;K&gt;</code>，调用 <code>Cmp()(x, y)</code> 就相当于 <code>x &lt; y</code>，由此实现从小到大排序。</p>
<p>接下来我们将修改这一默认行为。</p>
<h4 id="_51">只需要小于号</h4>
<!-- PG183 -->

<p>一个类型要想作为 map 的键，只需要他支持 <code>&lt;</code> 运算符即可，不必定义其他 <code>&gt;</code>、<code>==</code> 运算符。</p>
<p>当 map 需要判断两个键是否相等时 <code>x == y</code>，会用 <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> 来等价地计算。</p>
<p>string, string_view, int, float, void *, shared_ptr, pair, tuple, array&hellip;</p>
<p>这些类型都支持比较运算符，都可以作为 map 的键。</p>
<!-- PG184 -->

<h3 id="_52">自定义小于号的三种方式</h3>
<p>如果你写了个自定义类 Student，要让他作为 map 的键类型，有三种方法：</p>
<p>一、在 Student 类中添加 <code>operator&lt;</code></p>
<pre><code class="language-cpp">struct Student {
    string name;
    int id;
    string sex;

    bool operator&lt;(Student const &amp;that) const {
        return name &lt; that.name || id &lt; that.id || sex &lt; that.sex;
    }
};

map&lt;Student, int&gt; stutab;
</code></pre>
<!-- PG185 -->

<p>二、特化 <code>less&lt;Student&gt;</code>，添加 <code>operator()</code></p>
<pre><code class="language-cpp">struct Student {
    string name;
    int id;
    string sex;
};

template &lt;&gt;
struct std::less&lt;Student&gt; {  // 用户可以特化标准库中的 trait
    bool operator()(Student const &amp;x, Student const &amp;y) const {
        return x.name &lt; y.name || x.id &lt; y.id || x.sex &lt; y.sex;
    }
};

map&lt;Student, int&gt; stutab;
</code></pre>
<blockquote>
<p>缺点：以后如果 map 外面要用用到这个类的大小比较，也只能用 <code>less&lt;Student&gt;()(stu1, stu2)</code> 代替 <code>stu1 &lt; stu2</code>。</p>
</blockquote>
<!-- PG186 -->

<p>三、重新自定义一个仿函数类 <code>LessStudent</code>，添加 <code>operator()</code>，然后把这个 <code>LessStudent</code> 作为 map 的比较器传入模板</p>
<pre><code class="language-cpp">struct Student {
    string name;
    int id;
    string sex;
};

struct LessStudent {
    bool operator()(Student const &amp;x, Student const &amp;y) const {
        return x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)));
        // 等价于：
        return std::tie(x.name, x.id, y.sex) &lt; std::tie(x.name, x.id, y.sex);
        // 因为 tuple 实现了正确的 operator&lt; 运算符
    }
};

map&lt;Student, int, LessStudent&gt; stutab;
</code></pre>
<blockquote>
<p>缺点：以后每次创建新的 map 时，都需要加一个 LessStudent 参数。</p>
</blockquote>
<h3 id="_53">自定义按哪个字段来索引</h3>
<!-- PG187 -->

<p>如果希望 map 在查找时只根据学生姓名索引，则只需要改一下比较器的实现，让他只比较姓名字段即可。</p>
<pre><code class="language-cpp">struct LessStudent {
    bool operator()(Student const &amp;x, Student const &amp;y) const {
        return x.name &lt; y.name;
    }
};
</code></pre>
<p>上面这样的比较器，map 会认为姓名 name 相同的 Student 就是相等的，并去重。即使 id 和 sex 不同，只要名字相等就会视为重复，利用这一点可以实现针对特定字段的去重。</p>
<blockquote>
<p>结论：map 的排序和去重，都取决于于你的比较器如何实现！比较器里没比较的字段，就会被忽略而不参与排序、索引、和去重。</p>
</blockquote>
<h3 id="c20_1">C++20 三路运算符 <code>&lt;=&gt;</code></h3>
<p>四（同一）、利用 C++20 新特性，三路比较运算符 <code>&lt;=&gt;</code>：如果自定义类的每个成员都支持比较运算符，可以把 <code>operator&lt;=&gt;</code> 函数声明为 <code>default</code>，然后编译器会自动添加自定义类的所有比较运算符。</p>
<pre><code class="language-cpp">struct Student {
    string name;
    int id;
    string sex;

    auto operator&lt;=&gt;(Student const &amp;) const = default;
};
</code></pre>
<p>此时默认的 <code>operator&lt;</code> 实现等价于 <code>x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)))</code>。</p>
<blockquote>
<p><code>&lt;=&gt;</code> 的返回类型是 <code>std::strong_ordering</code>，这是一种有三种取值的强枚举类型</p>
<p><code>&lt;=&gt;</code> 对应的仿函数为 <code>std::compare_three_way</code></p>
</blockquote>
<h3 id="_54">仿函数运算符全家桶</h3>
<!-- PG189 -->

<p>libstdc++ 头文件中的 less 和 greater 实现参考：</p>
<pre><code class="language-cpp">template&lt;typename _Tp&gt;
struct less : public binary_function&lt;_Tp, _Tp, bool&gt;
{
  _GLIBCXX14_CONSTEXPR
  bool
  operator()(const _Tp&amp; __x, const _Tp&amp; __y) const
  { return __x &lt; __y; }
};

template&lt;typename _Tp&gt;
struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;
{
  _GLIBCXX14_CONSTEXPR
  bool
  operator()(const _Tp&amp; __x, const _Tp&amp; __y) const
  { return __x &gt; __y; }
};
</code></pre>
<!-- PG190 -->

<p>类似的运算符仿函数还有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>仿函数类</th>
</tr>
</thead>
<tbody>
<tr>
<td>x == y</td>
<td>std::equal_to</td>
</tr>
<tr>
<td>x != y</td>
<td>std::not_equal_to</td>
</tr>
<tr>
<td>x &lt; y</td>
<td>std::less</td>
</tr>
<tr>
<td>x &gt; y</td>
<td>std::greater</td>
</tr>
<tr>
<td>x &lt;= y</td>
<td>std::less_equal</td>
</tr>
<tr>
<td>x &gt;= y</td>
<td>std::greater_equal</td>
</tr>
<tr>
<td>x + y</td>
<td>std::plus</td>
</tr>
<tr>
<td>x - y</td>
<td>std::minus</td>
</tr>
<tr>
<td>x * y</td>
<td>std::multiplies</td>
</tr>
<tr>
<td>x / y</td>
<td>std::divides</td>
</tr>
<tr>
<td>x % y</td>
<td>std::modulus</td>
</tr>
<tr>
<td>-x</td>
<td>std::negate</td>
</tr>
</tbody>
</table>
<p>他们都在 <code>#include &lt;functional&gt;</code> 头文件中定义。</p>
<h3 id="greater">greater 实现反向排序</h3>
<!-- PG191 -->

<p>案例：使用 greater 仿函数，让 map 反过来从大到小排序：</p>
<pre><code class="language-cpp">auto ilist = {
    {985, &quot;拳打&quot;},
    {211, &quot;脚踢&quot;},
};
map&lt;int, string&gt; m1 = ilist;        // 从小到大排序
map&lt;int, string, greater&lt;int&gt;&gt; m2 = ilist;
print(m1); // {{211, &quot;脚踢&quot;}, {985, &quot;拳打&quot;}}
print(m2); // {{985, &quot;拳打&quot;}, {211, &quot;脚踢&quot;}}
</code></pre>
<h3 id="_55">大小写不敏感的字符串比较器</h3>
<!-- PG194 -->

<p>自定义比较仿函数，实现无视键大小写的 map 容器：</p>
<pre><code class="language-cpp">struct LessIgnoreCase {
    bool operator()(std::string const &amp;lhs, std::string const &amp;rhs) const {
        return std::lexicographical_compare // 位于 &lt;algorithm&gt; 头文件，和 std::string 同款的字典序比较
        ( lhs.begin(), lhs.end()
        , rhs.begin(), rhs.end()
        , [] (char lhs, char rhs) {
            return std::toupper(lhs) &lt; std::toupper(rhs);
        });
    }
};
int main() {
    map&lt;string, string, LessIgnoreCase&gt; m = {
        {{&quot;Fuck&quot;}, &quot;rust&quot;},
        {{&quot;fUCK&quot;}, &quot;java&quot;},
        {{&quot;STUdy&quot;}, &quot;cpp&quot;},
        {{&quot;stUDy&quot;}, &quot;js&quot;},
    };
    print(m);
    print(&quot;fuck对应的值为:&quot;, m.at(&quot;fuck&quot;));
    return 0;
}
</code></pre>
<pre><code>{&quot;Fuck&quot;: &quot;rust&quot;, &quot;STUdy&quot;: &quot;cpp&quot;}
fuck对应的值为: &quot;rust&quot;
</code></pre>
<h3 id="lambda">传入 lambda 做比较器</h3>
<!-- PG195 -->

<p>C++11 的 lambda 表达式也是仿函数，配合 decltype 后就可以传入 map 作为比较器：</p>
<pre><code class="language-cpp">auto cmp = [] (std::string const &amp;lhs, std::string const &amp;rhs) {
    return std::lexicographical_compare
    ( lhs.begin(), lhs.end()
    , rhs.begin(), rhs.end()
    , [] (char lhs, char rhs) {
        return std::toupper(lhs) &lt; std::toupper(rhs);
    });
};
map&lt;string, string, decltype(cmp)&gt; m({
    {{&quot;Fuck&quot;}, &quot;rust&quot;},
    {{&quot;fUCK&quot;}, &quot;java&quot;},
    {{&quot;Study&quot;}, &quot;cpp&quot;},
}, cmp);
print(m);
auto val = m.at({&quot;fuck&quot;});
print(val);
</code></pre>
<p>写的更清晰一点：</p>
<pre><code class="language-cpp">auto cmp = [] (std::string const &amp;lhs, std::string const &amp;rhs) {
    return std::lexicographical_compare
    ( lhs.begin(), lhs.end()
    , rhs.begin(), rhs.end()
    , [] (char lhs, char rhs) {
        return std::toupper(lhs) &lt; std::toupper(rhs);
    });
};
map&lt;string, string, decltype(cmp)&gt; m(cmp);
m = {
    {{&quot;Fuck&quot;}, &quot;rust&quot;},
    {{&quot;fUCK&quot;}, &quot;java&quot;},
    {{&quot;Study&quot;}, &quot;cpp&quot;},
};
print(m);
auto val = m.at({&quot;fuck&quot;});
print(val);
</code></pre>
<h4 id="map_7">map 构造函数是如何传入比较器的</h4>
<!-- PG197 -->

<p>刚刚用到的两个 map 构造函数：</p>
<pre><code class="language-cpp">template &lt;class K, class V, class Cmp = std::less&lt;K&gt;&gt;
class map {
    explicit map(Cmp cmp);
    map(initializer_list&lt;pair&lt;K, V&gt;&gt; ilist, Cmp cmp);
};
</code></pre>
<p>基本每个 map 的构造函数都有一个提供额外 cmp 参数的版本，统一都是在最后一个参数后面追加。</p>
<h4 id="_56">有状态（捕获变量）的比较器</h4>
<!-- PG198 -->

<p>传入的仿函数 cmp 甚至可以捕获其他变量，这种捕获了变量的仿函数称之为有状态仿函数 - stateful functor，和无状态仿函数 - stateless functor 相对：</p>
<pre><code class="language-cpp">vector&lt;int&gt; arr = {1, 4, 2, 8, 5, 7};
auto cmp = [&amp;] (int i, int j) {
    return arr[i] &lt; arr[j];
};
map&lt;int, int, decltype(cmp)&gt; m(cmp);
</code></pre>
<p>利用有状态仿函数可以实现 argsort 等操作，例如上面代码就是根据在 arr 里对应索引的值来排序。</p>
<blockquote>
<p>由于 map 需要比较仿函数为纯函数(pure function)，在上面例子中，请保证 map 存在期间 arr 的内容不发生变化，否则 map 基于排序的二分查找功能会得到错误的结果。</p>
</blockquote>
<p>传入比较器仿函数是设计模式中典型的策略模式，通过依赖注入，允许我们控制 map 内部的行为。</p>
<h4 id="function">建议用 function</h4>
<p>如果嫌 decltype 麻烦（难以在全局或类内部用），function 容器作为比较运算符，就可以统一了：</p>
<pre><code class="language-cpp">auto cmp = [] (int i, int j) {
    return i &lt; j;
};
map&lt;int, int, function&lt;bool(int, int)&gt;&gt; m;
</code></pre>
<p>稍后还可以通过 <code>key_comp()</code> 获取到用于键比较的仿函数，这个就是你刚刚传入的 cmp 参数：</p>
<pre><code class="language-cpp">m.key_comp()(1, 2);              // 等价于 cmp(1, 2)
</code></pre>
<p><code>value_comp()</code> 获取到用于元素（键-值对）比较的仿函数（他帮你适配参数类型了）：</p>
<pre><code class="language-cpp">m.value_comp()({1, 0}, {2, 0});  // 等价于 cmp(1, 2)
</code></pre>
<h2 id="map_8">透明 map</h2>
<h3 id="_57">什么是透明仿函数</h3>
<!-- PG192 -->

<p>C++14 新增了“透明(transparent)”运算符仿函数。</p>
<p>对于 less、greater 这类标准库提供的仿函数，指定模板参数为 void 即可让一个运算符仿函数变成“透明”的。例如对 less 而言，他的透明版就是 <code>less&lt;void&gt;</code>。</p>
<p>C++14 之前用的都是“不透明”版的仿函数，必须指定一个具体的类型，例如 <code>less&lt;int&gt;</code> 就只能用于 int 类型的比较，<code>less&lt;string&gt;</code> 就只能用于 string 类型的比较。</p>
<p>无法用 <code>less&lt;int&gt;</code> 仿函数比较 string 类型。</p>
<p>而 <code>less&lt;void&gt;</code> 是通用的，他的 <code>operator()</code> 函数是泛型的，可以接受任意类型。</p>
<pre><code class="language-cpp">template &lt;&gt;
struct less&lt;void&gt; {   // 针对 void 的特化
    // 标准委员会想：由于 void 类型不可能有 &lt; 运算符的需求，所以他们干脆拿 void 作为透明版的模板参数“占位符”了
    template &lt;class Tx, class Ty&gt;
    constexpr decltype(auto) operator()(Tx &amp;&amp;x, Ty &amp;&amp;y) const {
        return forward&lt;Tx&gt;(x) &lt; forward&lt;Ty&gt;(y);
    }

    struct is_transparent;  // 空类，仅供 SFINAE 元编程时检测一个仿函数是否透明时使用
};
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 我的思考：不透明版的 <code>less&lt;T&gt;</code> 泛型体现在类的模板参数上，而透明版的体现在了成员函数 <code>operator()</code> 的模板参数上。</p>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 这里用 <code>void</code> 特化只是一个偷懒，<code>void</code> 并没有什么特殊的，实际上应该单独定义一个没有模板的 <code>transparent_less</code> 类，但他们就是懒得引入新标识符。</p>
</blockquote>
<h3 id="_58">为什么需要透明仿函数</h3>
<!-- PG193 -->

<p>“透明”版的好处是可以同一个兼容任意类型，而不必创建多个 cmp 对象。而不透明版的好处是方便特化 traits，但毕竟 &lt; 运算符是可以用户自定义(运算符重载)的，没必要用 traits 特化，所以他们逐步发现透明版香了，还能支持左右参数为不同类型。</p>
<pre><code class="language-cpp">less&lt;void&gt; cmp;
print(cmp(1, 2));  // 1 &lt; 2: true
print(cmp(5, 2));  // 5 &lt; 2: false
print(cmp(string(&quot;hello&quot;), &quot;world&quot;));  // &quot;hello&quot; &lt; &quot;world&quot;: false
print(cmp(string(&quot;cmake&quot;), &quot;cppcon&quot;));  // &quot;cmake&quot; &lt; &quot;cppcon&quot;: true
</code></pre>
<blockquote>
<p>但也要特别注意不能再依赖参数类型自动的隐式转换了，必须至少写完整其中一个 <code>string("hello")</code> 才能触发 <code>string</code> 的 <code>operator&lt;</code> 而不是 <code>const char *</code> 的指针比大小。如果只写 <code>cmp("cmake", "cppcon")</code> 则是在比较指针的地址大小，结果是不一定的。</p>
</blockquote>
<p>由于 C++14 的 less 模板参数 T 默认为 void，所以 <code>less&lt;void&gt;</code> 还可以简写成 <code>less&lt;&gt;</code>。</p>
<pre><code class="language-cpp">less&lt;&gt; cmp;
print(cmp(1, 2));  // 1 &lt; 2: true
print(cmp(5, 2));  // 5 &lt; 2: false
print(cmp(string(&quot;hello&quot;), &quot;world&quot;));  // &quot;hello&quot; &lt; &quot;world&quot;: false
print(cmp(string(&quot;cmake&quot;), &quot;cppcon&quot;));  // &quot;cmake&quot; &lt; &quot;cppcon&quot;: true
</code></pre>
<h3 id="find_1">泛型版的 find 函数</h3>
<!-- PG200 -->

<p>普通 find 函数：键类型作为参数</p>
<pre><code class="language-cpp">iterator find(K const &amp;k);
const_iterator find(K const &amp;k) const;
</code></pre>
<p>C++14 新增泛型版的 find 函数<sup id="fnref27:1"><a class="footnote-ref" href="#fn:1">1</a></sup>：任意类型作为参数，只要该类型支持与和键比大小。</p>
<pre><code class="language-cpp">template &lt;class Kt&gt;
iterator find(Kt &amp;&amp;k);
template &lt;class Kt&gt;
const_iterator find(Kt &amp;&amp;k) const;
</code></pre>
<blockquote>
<p>这里的 Kt 是模板参数类型，可以接受任意类型，此处 <code>&amp;&amp;</code> 是万能引用不是右值引用。</p>
</blockquote>
<p>相同点：找到了就返回一个迭代器指向与该参数相等的元素，如果找不到还是返回 end()。</p>
<p>不同点：泛型版本的参数类型 Kt 不必和键类型 K 一致，只要 Kt 和 K 可以比较大小（&lt; 运算符）即可。</p>
<p>不仅</p>
<h3 id="find_2">泛型 find 的要求：透明</h3>
<p>要想用泛型版的 find 函数有一个条件：</p>
<p>map 的比较器必须是“透明(transparent)”的，也就是 <code>less&lt;void&gt;</code> 这种。否则泛型版的 <code>find(Kt &amp;&amp;)</code> 不会参与重载，也就是只能调用传统的 <code>find(K const &amp;)</code>。</p>
<p>但是 <code>map&lt;K, V&gt;</code> 默认的比较器是 <code>less&lt;V&gt;</code>，他是不透明的，比较的两边必须都是 <code>V</code> 类型。如果其中一边不是的话，就得先隐式转换为 <code>V</code> 才能用。</p>
<p>这是早期 C++98 设计的失败，当时他们没想到 <code>find</code> 还可以接受 <code>string_view</code> 和 <code>const char *</code> 这类可以和 <code>string</code> 比较，但构造会廉价得多的弱引用类型。</p>
<p>只好后来引入了透明比较器企图，然而为了历史兼容，<code>map&lt;K, V&gt;</code> 默认仍然是 <code>map&lt;K, V, less&lt;K&gt;&gt;</code>。</p>
<p>如果我们同学的编译器支持 C++14，建议全部改用这种写法 <code>map&lt;K, V, less&lt;&gt;&gt;</code>，从而用上更高效的 find、at、erase、count、contains 等需要按键查找元素的函数。</p>
<h4 id="_59">应用：字符串为键的字典</h4>
<p>除非传入的刚好就是一个 <code>string</code> 的 const 引用，否则就会发生隐式构造 <code>string</code> 的操作。</p>
<p>如果传入的是一个 <code>string_view</code> 或 <code>const char *</code>，那么需要从他们构造出一个 <code>string</code>，然后才能传入传统的 <code>find(string const &amp;)</code> 函数。而 <code>string</code> 的构造会发生拷贝，且可能产生内存分配。</p>
<p>对于比较大的字符串做键值，每次查找都需要重新构造一个 <code>string</code> 对象，开销会比较大。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; lut;

lut.at(&quot;a-very-very-very-very-long-key&quot;);
// 等价于:
lut.at(string(&quot;a-very-very-very-very-long-key&quot;)); // 隐式构造了一个 string，导致深拷贝了整个字符串！
</code></pre>
<p>而启用了透明比较后，就不需要每次都拷贝整个字符串来构造 <code>string</code> 了。因为 find、at 这类函数会启用一个泛型的版本 <code>at(Kt &amp;&amp;)</code>，Kt 可以是任何类型，只要他支持与 <code>string</code> 比较。可以是 <code>const char *</code>，<code>string_view</code> 或另一个 <code>string</code>。</p>
<pre><code class="language-cpp">map&lt;string, int, less&lt;&gt;&gt; lut;

lut.at(&quot;a-very-very-very-very-long-key&quot;);
// 等价于:
lut.at&lt;const char *&gt;(&quot;a-very-very-very-very-long-key&quot;);
</code></pre>
<p>因为不用拷贝了，更加高效，特别是对于键字符串非常长的情况。</p>
<p>at 内部也不会构造任何新的 <code>string</code>，他会拿着 <code>const char *</code> 和红黑树中的每个节点调用 <code>==</code> 比较。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>string == const char *</code> 是安全的，会比较字符串的内容而不是地址。</p>
</blockquote>
<h4 id="_60">应用：智能指针为键的字典</h4>
<p>某有某些特殊情况下，我们需要把指针，甚至智能指针！放进 map 或 set 的键中，用于快速按指针的值查找到元素。（是的你没听错，是放在<strong>键类型</strong>里！）</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 轶事：把指针放在键里并不罕见，常见的一个用法是 <code>set&lt;Node *&gt;</code>。好处是当 <code>Node</code> 析构时，他可以直接调用 <code>set.erase(this)</code> 把自己剔除掉。而普通的 <code>set&lt;Node&gt;</code> 就很难做到这一点了，你无法通过 Node 的 this 指针获得他在 set 中的迭代器，也无法知道自己位于哪个 set 中。侵入式红黑树完美解决了这一痛点，LLVM 和 Linux 内核中都大量运用了侵入式链表/LRU/红黑树，以后的高级数据结构课程中会为你讲解。</p>
</blockquote>
<pre><code class="language-cpp">map&lt;Node *, int&gt; lut;

Node *raw_ptr = get_some_ptr();
lut.find(raw_ptr);
</code></pre>
<p>如果是智能指针，就比较困难了，特别是 <code>unique_ptr</code>。如果你已知一个原始指针，想要在 map 中查找指向同样的智能指针键。</p>
<pre><code class="language-cpp">map&lt;unique_ptr&lt;Node&gt;, int&gt; lut;
Node *raw_ptr = get_some_ptr();
lut.find(raw_ptr); // 错误：无法从 Node * 隐式构造 unique_ptr&lt;Node&gt;
</code></pre>
<p>过去，人们不得不用一种称为 stale-ptr（变质指针）的黑科技，来构造一个不掌握生命周期的伪 unique_ptr 出来：</p>
<pre><code class="language-cpp">map&lt;unique_ptr&lt;Node&gt;, int&gt; lut;
Node *raw_ptr = get_some_ptr();
unique_ptr&lt;Node&gt; stale_ptr(raw_ptr);  // 一个并不掌握生命周期的“变质智能指针”
lut.find(stale_ptr); // OK: 匹配到 find(unique_ptr&lt;Node&gt; const &amp;) 重载
stale_ptr.release(); // 必须！否则会出现双重释放 (double-free) 错误
</code></pre>
<p>而 C++14 中，我们只需定义一个透明的比较函数，支持 <code>Node *</code> 与 <code>unique_ptr&lt;Node&gt;</code> 互相比较即可：</p>
<pre><code class="language-cpp">struct transparent_ptr_less {
    template &lt;class T&gt;
    bool operator()(T *const &amp;p1, T const &amp;p2) const {
        return p1 &lt; p2;
    }

    template &lt;class T&gt;
    bool operator()(T *const &amp;p1, unique_ptr&lt;T&gt; const &amp;p2) const {
        return p1 &lt; p2.get();
    }

    template &lt;class T&gt;
    bool operator()(unique_ptr&lt;T&gt; const &amp;p1, T *const &amp;p2) const {
        return p1.get() &lt; p2;
    }

    template &lt;class T&gt;
    bool operator()(unique_ptr&lt;T&gt; const &amp;p1, unique_ptr&lt;T&gt; const &amp;p2) const {
        return p1.get() &lt; p2.get();
    }

    using is_transparent = std::true_type;
};

map&lt;unique_ptr&lt;Node&gt;, int, transparent_ptr_less&gt; lut;
Node *raw_ptr = get_some_ptr();
lut.find(raw_ptr); // OK: 匹配到泛型的 find(Kt &amp;&amp;) 重载，其中 Kt 推导为 Node *const &amp;
</code></pre>
<h4 id="_61">应用：超大对象为键的字典</h4>
<!-- PG201 -->

<p>以下摘自 cppreference 上泛型 find 的官方案例：</p>
<pre><code class="language-cpp">struct FatKey   { int x; int data[1000]; };
struct LightKey { int x; };
// Note: as detailed above, the container must use std::less&lt;&gt; (or other 
//   transparent Comparator) to access these overloads.
// This includes standard overloads, such as between std::string and std::string_view.
bool operator&lt;(const FatKey&amp; fk, const LightKey&amp; lk) { return fk.x &lt; lk.x; }
bool operator&lt;(const LightKey&amp; lk, const FatKey&amp; fk) { return lk.x &lt; fk.x; }
bool operator&lt;(const FatKey&amp; fk1, const FatKey&amp; fk2) { return fk1.x &lt; fk2.x; }

int main() {
    // transparent comparison demo
    std::map&lt;FatKey, char, std::less&lt;&gt;&gt; example = {{{1, {}}, 'a'}, {{2, {}}, 'b'}};

    LightKey lk = {2};
    if (auto search = example.find(lk); search != example.end())
        std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; search-&gt;first.x &lt;&lt; &quot; &quot; &lt;&lt; search-&gt;second &lt;&lt; '\n';
    else
        std::cout &lt;&lt; &quot;Not found\n&quot;;
}
</code></pre>
<pre><code>Found 2 b
</code></pre>
<!-- PG202 -->

<h2 id="multimap">神奇的 multimap</h2>
<p>允许重复键值的 multimap</p>
<p>map 中一个键对应一个值，而 multimap 一个键可以对应多个值。</p>
<ul>
<li>map：排序 + 去重；</li>
<li>multimap：只排序，不去重。</li>
</ul>
<pre><code class="language-cpp">// map&lt;K, V&gt; 的插入函数：
pair&lt;iterator, bool&gt; insert(pair&lt;const K, V&gt; const &amp;kv);
pair&lt;iterator, bool&gt; insert(pair&lt;const K, V&gt; &amp;&amp;kv);
// multimap&lt;K, V&gt; 的插入函数：
iterator insert(pair&lt;K, V&gt; const &amp;kv);
iterator insert(pair&lt;K, V&gt; &amp;&amp;kv);
</code></pre>
<p>因为 multimap 允许重复键值，所以插入总是成功，与普通 map 相比不用返回 bool 表示是否成功了。</p>
<h3 id="_62">元素的排列顺序</h3>
<!-- PG203 -->

<pre><code class="language-cpp">multimap&lt;string, string&gt; tab;
tab.insert({&quot;rust&quot;, &quot;silly&quot;});
tab.insert({&quot;rust&quot;, &quot;trash&quot;});
tab.insert({&quot;rust&quot;, &quot;trash&quot;});
tab.insert({&quot;cpp&quot;, &quot;smart&quot;});
tab.insert({&quot;rust&quot;, &quot;lazy&quot;});
tab.insert({&quot;cpp&quot;, &quot;fast&quot;});
tab.insert({&quot;java&quot;, &quot;pig&quot;});
print(tab);
</code></pre>
<pre><code>{&quot;cpp&quot;: &quot;smart&quot;, &quot;cpp&quot;: &quot;fast&quot;, &quot;java&quot;: &quot;pig&quot;, &quot;rust&quot;: &quot;silly&quot;, &quot;rust&quot;: &quot;trash&quot;, &quot;rust&quot;: &quot;trash&quot;, &quot;rust&quot;: &quot;lazy&quot;}
</code></pre>
<p>插入进 multimap 的重复键会紧挨着，他们之间的顺序取决于插入的顺序。例如上面键同样是 &ldquo;cpp&rdquo; 的两个元素，&rdquo;smart&rdquo; 先于 &ldquo;fast&rdquo; 插入，所以 &ldquo;smart&rdquo; 靠前了。</p>
<h3 id="_63">用途：动态排序！</h3>
<!-- PG204 -->

<p>multimap / multiset 的作用通常就不是键值映射了，而是利用红黑树会保持元素有序的特性（任何二叉搜索树都这样）实现一边插入一边动态排序。</p>
<p>传统排序方式：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; arr;
int i;
while (cin &gt;&gt; i) {
    arr.push_back(i);
}
std::sort(arr.begin(), arr.end(), std::less&lt;int&gt;());
</code></pre>
<p>multiset 排序方式：</p>
<pre><code class="language-cpp">std::multiset&lt;int&gt; tab;
int i;
while (cin &gt;&gt; i) {
    tab.insert(i);
}
// 无需再排序，tab 中的键已经是有序的了！
// 如需取出到 vector:
std::vector&lt;int&gt; arr(tab.begin(), tab.end());
</code></pre>
<p>利用 multimap 键-值对的特点，还能轻易实现只对键排序，值的部分不参与排序的效果。</p>
<p>multimap 排序的好处是：</p>
<ul>
<li>动态排序，在插入的过程中就保持整个红黑树的有序性，最后任何无需额外操作。</li>
<li>在一次次插入的过程中，每时每刻都是有序的，而不必等到最后才变得有序。</li>
<li>可以随时动态删除一个元素，同样不会破坏有序性。</li>
<li>还很方便随时按键值查找到和我相等的元素。</li>
<li>如果还额外需要去重，则只需改用普通 map</li>
</ul>
<p>普通 map 轻松实现去重 + 动态排序，如何处置重复的键随你决定：</p>
<ul>
<li>普通 map 的 insert 只接受第一次出现的键-值对。</li>
<li>普通 map 的 insert_or_assign 只保留最后一次出现的键-值对。</li>
</ul>
<!-- PG205 -->

<h3 id="_64">查询某个键对应的多个值</h3>
<p>因为 multimap 中，一个键不再对于单个值了；所以 multimap 没有 <code>[]</code> 和 <code>at</code> 了，也没有 <code>insert_or_assign</code>（反正 <code>insert</code> 永远不会发生键冲突！）</p>
<p>要查询 multimap 中的一个键对应了哪些值，可以用 <code>equal_range</code> 获取一前一后两个迭代器，他们形成一个区间。这个区间内所有的元素都是同样的键。</p>
<pre><code class="language-cpp">multimap&lt;string, string&gt; tab;
tab.insert({&quot;rust&quot;, &quot;silly&quot;});
tab.insert({&quot;rust&quot;, &quot;trash&quot;});
tab.insert({&quot;rust&quot;, &quot;trash&quot;});
tab.insert({&quot;cpp&quot;, &quot;smart&quot;});
tab.insert({&quot;rust&quot;, &quot;lazy&quot;});
tab.insert({&quot;cpp&quot;, &quot;fast&quot;});
tab.insert({&quot;java&quot;, &quot;pig&quot;});

auto range = tab.equal_range(&quot;cpp&quot;);
for (auto it = range.first; it != range.second; ++it) {
    print(it-&gt;first, it-&gt;second);
}
</code></pre>
<pre><code>cpp smart
cpp fast
</code></pre>
<p><code>equal_range</code> 返回两个迭代器相等时（即区间大小为 0），就代表找不到该键值。</p>
<pre><code class="language-cpp">auto range = tab.equal_range(&quot;html&quot;);
if (range.first == range.second) {
    print(&quot;找不到该元素！&quot;);
} else {
    for (auto it = range.first; it != range.second; ++it) {
        print(it-&gt;first, it-&gt;second);
    }
}
</code></pre>
<p><code>equal_range</code> 返回的两个迭代器，也可以用 <code>lower_bound</code> 和 <code>upper_bound</code> 分别获得：</p>
<pre><code class="language-cpp">auto begin_it = tab.lower_bound(&quot;html&quot;);
auto end_it = tab.upper_bound(&quot;html&quot;);
if (begin_it == end_it) {
    print(&quot;找不到该元素！&quot;);
} else {
    for (auto it = begin_it; it != end_it; ++it) {
        print(it-&gt;first, it-&gt;second);
    }
}
</code></pre>
<h3 id="lowerupper_bound">lower/upper_bound 实现范围查询</h3>
<ul>
<li><code>lower_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于等于（&gt;=）当前 key 的元素。</li>
<li><code>upper_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于（&gt;）当前 key 的元素。</li>
<li><code>begin()</code> 到 <code>lower_bound(key)</code> 迭代器之间的元素，都是小于（&lt;）当前 key 的元素。</li>
<li><code>begin()</code> 到 <code>upper_bound(key)</code> 迭代器之间的元素，都是小于等于（&lt;=）当前 key 的元素。</li>
</ul>
<p>例如我要对一系列小彭友的成绩数据进行排序，要求查出大于等于 60 分的所有同学，发放“小红花”：</p>
<pre><code class="language-cpp">struct Student {
    string name;
    int score;
};

vector&lt;Student&gt; students;
</code></pre>
<p>就可以把成绩 int 作为键，学生名字作为值，插入 multimap。</p>
<p>插入的过程中 multimap 就自动为你动态排序了。</p>
<pre><code class="language-cpp">multimap&lt;int, string&gt; sorted;
for (auto const &amp;stu: students) {
    sorted.insert({stu.score, stu.name});
}
</code></pre>
<p>然后，要找出所有大于等于 60 分的同学，也就是 <code>lower_bound(60)</code> 到 <code>end()</code> 这个区间：</p>
<pre><code class="language-cpp">// where score &gt;= 60
for (auto it = sorted.lower_bound(60); it != sorted.end(); ++it) {
    print(&quot;恭喜 {} 同学，考出了 {} 分，奖励你一朵小红花&quot;, it-&gt;second, it-&gt;first);
}
</code></pre>
<p>找出 30（含）到 60（不含）分的同学也很容易：</p>
<pre><code class="language-cpp">// where 30 &lt;= score and score &lt; 60
for (auto it = sorted.upper_bound(30); it != sorted.lower_bound(60); ++it) {
    print(&quot;{} 同学考出了 {} 分，不要灰心！小彭老师奖励你一朵小黄花，表示黄牌警告&quot;, it-&gt;second, it-&gt;first);
}
</code></pre>
<h3 id="_65">课后练习</h3>
<p>尝试用 multimap 实现一个简单的学生成绩管理系统，要求如下：</p>
<ol>
<li>学生信息包括姓名和成绩。</li>
<li>能够动态插入和删除学生信息，始终保持按成绩排序。</li>
<li>能够查询给定成绩范围内的所有学生。</li>
</ol>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 实际上，数据库就是这样实现的，我们的 multimap 只是简单地对成绩这一个字段排序，而专业的关系数据库会为每个字段都建立索引，分别排序后存储，以加速查找。学有余力的同学可以尝试让学生信息包含姓名、成绩、年龄、学号，然后分别构建这四个字段的索引，支持指定值查找和范围查找，其中姓名和学号要求唯一性。提示：用之前提到的 vector + map 的方法。做出来以后，面试数据库时你就可以秀理解了。</p>
</blockquote>
<!-- PG206 -->

<h2 id="_66">时间复杂度总结说明</h2>
<!-- PG207 -->

<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>m1 = move(m2)</td>
<td>移动</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></td>
</tr>
<tr>
<td>m1 = m2</td>
<td>拷贝</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span></td>
</tr>
<tr>
<td>swap(m1, m2)</td>
<td>交换</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></td>
</tr>
<tr>
<td>m.clear()</td>
<td>清空</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span></td>
</tr>
</tbody>
</table>
<hr />
<!-- PG208 -->

<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.insert({key, val})</td>
<td>插入键值对</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.insert(pos, {key, val})</td>
<td>带提示的插入，如果位置提示准确</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>+</td>
</tr>
<tr>
<td>m.insert(pos, {key, val})</td>
<td>带提示的插入，如果位置提示不准确</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m[key] = val</td>
<td>插入或覆盖</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.insert_or_assign(key, val)</td>
<td>插入或覆盖</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.insert({vals&hellip;})</td>
<td>设 M 为待插入元素（vals）的数量</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(M \log N)</span><script type="math/tex">O(M \log N)</script></span></td>
</tr>
<tr>
<td vals...="vals...">map m =</td>
<td>如果 vals 无序</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span></td>
</tr>
<tr>
<td vals...="vals...">map m =</td>
<td>如果 vals 已事先从小到大排列</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span></td>
</tr>
</tbody>
</table>
<hr />
<!-- PG209 -->

<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.at(key)</td>
<td>根据指定的键，查找元素，返回值的引用</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.find(key)</td>
<td>根据指定的键，查找元素，返回迭代器</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.count(key)</td>
<td>判断是否存在指定键元素，返回相同键的元素数量（只能为 0 或 1）</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>根据指定的键，确定上下界，返回区间</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.size()</td>
<td>map 中所有元素的数量</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></td>
</tr>
<tr>
<td>m.erase(key)</td>
<td>根据指定的键，删除元素</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m.erase(it)</td>
<td>根据找到的迭代器，删除元素</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span></td>
</tr>
<tr>
<td>m.erase(beg, end)</td>
<td>批量删除区间内的元素，设该区间（beg 和 end 之间）有 M 个元素</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(M + \log N)</span><script type="math/tex">O(M + \log N)</script></span></td>
</tr>
<tr>
<td>erase_if(m, cond)</td>
<td>批量删除所有符合条件的元素</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span></td>
</tr>
</tbody>
</table>
<hr />
<!-- PG210 -->

<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.insert(node)</td>
<td></td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>node = m.extract(it)</td>
<td></td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span></td>
</tr>
<tr>
<td>node = m.extract(key)</td>
<td></td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span></td>
</tr>
<tr>
<td>m1.merge(m2)</td>
<td>合并两个 map，清空 m2，结果写入 m1</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span></td>
</tr>
<tr>
<td>m1.insert(m2.begin(), m2.end())</td>
<td>合并两个 map，m2 保持不变，结果写入 m1</td>
<td><span class="arithmatex"><span class="MathJax_Preview">O(N \log N)</span><script type="math/tex">O(N \log N)</script></span></td>
</tr>
</tbody>
</table>
<!-- PG211 -->

<h2 id="unordered_map">哈希表 unordered_map</h2>
<p>C++11 新增：基于哈希 (hash) 的映射表 unordered_map</p>
<h3 id="unordered_map-map">unordered_map 与 map 之争：适用场景不同</h3>
<p>之前提到，map 底层基于红黑树，大多数操作的复杂度都是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 级别的，其中部分按迭代器的插入和删除的复杂度可以降低到 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>。</p>
<p><img alt="hash_map" src="../img/stl/hash_map.png" /></p>
<p>而 unordered_map 则是基于哈希表的更高效查找，只需 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 复杂度！他能实现如此高效查找得益于哈希函数可以把散列唯一定位到一个数组的下标中去，而数组的索引是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的。缺点是哈希值可能产生冲突，而且哈希数组可能有空位没有填满，浪费一部分内存空间。总的来说哈希表在平均复杂度上（<span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>）比红黑树这类基于树的复杂度（<span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>）更低，虽然固有延迟高，占用空间大，还容易被哈希冲突攻击。</p>
<ul>
<li>哈希表结构简单无脑，在巨量的键值对的存储时会发挥出明显的性能优势，常用于需要高吞吐量但不太在乎延迟的图形学应用。</li>
<li>而各种基于树的数据结构，复杂度更加稳定，看似适合小规模数据，但是因为保持有序的特性，非常适合数据库这种需要范围查询的情况，且有序性反而有利于缓存局域性，无序的哈希表难以胜任。</li>
<li>最近新提出的一种数据结构——跳表，也是有序的，但基于链表，更加高效，在 Redis 等软件中都有应用。别担心，小彭老师之后的数据结构课程会专门介绍并带你手搓所有这些！</li>
</ul>
<hr />
<h3 id="unordered_map_1">原理：unordered_map 中的“桶”</h3>
<!-- PG212 -->

<p>unordered_map 如何快速检索数据？高效的秘诀在于 unordered_map 内部是一个数组，一个由许多“桶”组成的数组。插入时把键值对存到键的 hash 对应编号的桶去，查询时就根据 hash 去线性地查找桶（这一操作是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的）。</p>
<p>例如键为 &ldquo;hello&rdquo;，假设算出他的 hash 为 42。而当前桶的数量是 32 个，则会把 &ldquo;hello&rdquo; 存到 42 % 32 = 10 号桶去。查询时，同样计算出 hash(&ldquo;hello&rdquo;) % 32 = 10 号桶，然后就可以从 10 号桶取出 &ldquo;hello&rdquo; 对应的数据了。</p>
<pre><code class="language-cpp">template &lt;class K, class V&gt;
class unordered_map {
    array&lt;pair&lt;K, V&gt;, 32&gt; buckets;

    void insert(pair&lt;K, V&gt; kv) {
        size_t h = hash(kv.first) % buckets.size();  // 计算出来的 hash 可能很大，取模可以防止 h &gt;= buckets.size()
        buckets[h] = kv;
    }

    V &amp;at(K k) {
        size_t h = hash(k) % buckets.size();
        auto &amp;kv = buckets[h];
        if (k != kv.first) throw out_of_range{};
        return kv.second;
    }
};
</code></pre>
<h3 id="hash-collision">哈希冲突 (hash-collision)</h3>
<p>但是这里有一个问题，如果两个不同的字符串，刚好 hash 以后的模相同怎么办？这种现象称为 hash 冲突。</p>
<p>C++ 标准库的解决方案是采用链表法：一个桶不是单独的一个 K-V 对，而是数个 K-V 对组成的单链表（forward_list）。一个桶不是只存储一个数据，而是可以存储任意多个数据（0到∞个）。</p>
<p>插入时，找到对应的桶，并往链表的头部插入一个新的 K-V 对。查找时，先找到对应的桶，在这个桶里的链表里顺序遍历查找，由于第一步的桶查找是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的，虽然最后还是链表暴力查找，但是已经被桶分摊了一个维度，因此查找的平均复杂度还是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span> 的。</p>
<pre><code class="language-cpp">    void insert(pair&lt;K, V&gt; kv) {
        size_t h = hash(kv.first) % buckets.size();  // 计算 hash 的模（所在桶的编号）
        buckets[h].push_front(kv);                // 单链表的头插，是最高效的
    }

    V &amp;at(K k) {
        size_t h = hash(k) % buckets.size();         // 计算 hash 的模（所在桶的编号）
        for (auto &amp;kv: buckets[h]) {
            if (k == kv.first)  // 可能有多个不同的键刚好有相同的 hash 模，需要进一步判断键确实相等才能返回
                return kv.second;
        }
        throw out_of_range{};
    }
</code></pre>
<hr />
<p>这里还是有一个问题，hash 冲突时，对链表的暴力遍历查找复杂度是 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 的，随着越来越多的元素被插入进来，32 个桶将会拥挤不堪。假设有 n 个元素，则平均每个桶都会有 n / 32 个元素，需要 n / 32 次遍历。所以元素数量充分大时 unordered_map 又会退化成暴力遍历的 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度，满足不了我们用他加速查找的目的。</p>
<p>桶的数量相比元素的数量越是不足，越是拥挤，越是容易退化成链表。</p>
<p>因此 C++ 标准库规定，插入时，当检测到平均每个桶里都有 1 个元素时，也就是元素数量大于桶的数量时，就会发生自动扩容，一次性让桶的数量扩充 2 倍，并重新计算每个元素的 hash 模（桶编号）全部重新插入一遍。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 元素数量除以桶的数量被称为“负载率（load factor），对于链表法的哈希表 unordered_map 来说，负载率可以高于 1；对于线性地址法的 flat_hash_map 则最高为 1。C++ 标准库通常的 unordered_map 实现中，负载率高于 1 时，就会发生自动扩容。可以通过 <code>.load_factor()</code> 函数查询一个 unordered_map 的负载率。</p>
</blockquote>
<pre><code class="language-cpp">template &lt;class K, class V&gt;
class unordered_map {
    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;  // 因为需要动态扩容，桶数组变成了动态数组 vector
    size_t size = 0;  // 记录当前容器共有多少个元素

    void insert(pair&lt;K, V&gt; kv) {
        if (size + 1 &gt; buckets.size()) reserve(n);  // 如果插入后的元素数量大于桶的容量，则扩容
        size_t h = hash(kv.first) % buckets.size();
        buckets[h].push_front(kv);
        size++;     // insert 时 size 自动加 1，erase 时也要记得减 1
    }

    void reserve(size_t n) {
        if (n &lt;= buckets.size()) return;  // 如果要求的大小已经满足，不需要扩容
        buckets.resize(max(n, buckets.size() * 2));  // 把桶数组至少扩大 2 倍（避免重复扩容），至多扩到 n
        此处省略 rehash 的具体实现  // 桶的数量发生变化了，需要重新计算一遍所有元素 hash 的模，并重新插入
    }
};
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 每个 key 所在的桶编号计算公式：bucket_index(key) = hash(key) % bucket_count()</p>
</blockquote>
<p>还是存在问题，刚刚的 insert 根本没有检测要插入的键是否已经存在了。如果已经存在还插入，那就变成 unordered_multimap 了！我们是普通的需要去重的 unordered_map，所以插入时先需要遍历下链表检测一下。</p>
<pre><code class="language-cpp">template &lt;class K, class V&gt;
class unordered_map {
    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;
    size_t size = 0;

    struct iterator {
        explicit iterator(pair&lt;K, V&gt; &amp;kv) { /* ... */ }
        // ...
    };

    pair&lt;iterator, bool&gt; insert(pair&lt;K, V&gt; kv) {
        if (size + 1 &gt; buckets.size()) reserve(size + 1);
        size_t h = hash(kv.first) % buckets.size();
        for (auto &amp;kv2: buckets[h]) {
            if (kv.first == kv2.first)  // 检测是否发生了冲突
                return {iterator(kv2), false};  // 发生冲突则返回指向已存在的键的迭代器
        }
        buckets[h].push_front(kv);
        size++;
        return {iterator(buckets.front()), true};  // 没发生冲突则返回成功插入元素的迭代器
    }
};
</code></pre>
<!-- PG213 -->

<h2 id="unordered_map-map_1">unordered_map 与 map 的异同</h2>
<p>用法上，unordered_map 基本与 map 相同，以下着重介绍他们的不同点。</p>
<!-- PG214 -->

<h3 id="1_1">区别 1：有序性</h3>
<ul>
<li>map 基于红黑树，元素从小到大顺序排列，遍历时也是从小到大的，键类型需要支持比大小（std::less 或 &lt;）。</li>
<li>unordered_map 基于哈希散列表，里面元素顺序随机，键类型需要支持哈希值计算（std::hash）和判断相等（std::equal_to 或 ==）。</li>
</ul>
<p>map 中的元素始终保持有序，unordered_map 里面的元素是随机的。</p>
<p>这也意味着 std::set_union 这类要求输入区间有序的 algorithm 函数无法适用于 unordered_map/set。</p>
<h4 id="hash-equal_to">hash 和 equal_to</h4>
<p>map 只需要 K 类型支持一个 less 就能工作。</p>
<p>而 unordered_map 需要 K 支持的 trait 有两个：hash 和 equal_to。</p>
<p><code>unordered_map&lt;K, V&gt;</code> 的完整形态是：</p>
<pre><code class="language-cpp">unordered_map&lt;K, V, hash&lt;K&gt;, equal_to&lt;K&gt;, allocator&lt;pair&lt;const K, V&gt;&gt;&gt;
</code></pre>
<ul>
<li>其中 allocator 我们照例先跳过不讲，之后分配器专题课中会介绍。</li>
<li>hash 说的是，如何求键的哈希值？hash 仿函数接受一个 K 类型的键，返回一个 size_t（在 64 位系统上是个无符号 64 位整数，表示哈希值）。</li>
<li>equal_to 说的是，如何判断两个键相等？如果两个键完全相等，他会返回 true。</li>
</ul>
<p>这里对 hash 的实现只有一个要求，<strong>如果两个键相等，则他们的哈希必定也相等，反之则不一定</strong>。</p>
<p>这个假设构成了 unordered_map 得以高效的基石，他使得 unordered_map 可以更快排除不可能的答案，而不必像 vector 的查找那样需要去暴力遍历全部元素，只需要遍历哈希相等的那一部分元素就够了。</p>
<pre><code class="language-cpp">template&lt;typename _Key, typename _Tp,
   typename _Hash = hash&lt;_Key&gt;,      // 默认的哈希函数实现，支持了 int, void *, string 等类型
   typename _Pred = equal_to&lt;_Key&gt;,  // 默认的 == 运算符
   typename _Alloc = allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;&gt;
class unordered_map
</code></pre>
<p>换言之，只要 unordered_map 发现两个键不相等，就不用再做具体值的比较了，他们不可能相等了！</p>
<h4 id="_67">哈希函数的思想</h4>
<p>hash 返回的 size_t 这个整数可以理解为一个对任意类型的“摘要”。</p>
<p>把一个很复杂的类型（例如 string）压缩成一个 unordered_map 很轻易就能比较的 size_t 整数，整数比较起来就很容易，而且还能直接作为数组的下标（string 不能直接作为数组的下标）。</p>
<p>这种摘要的关键在于如何把一个极为复杂的类型“映射”到小小的 size_t 上去，并且分布得尽可能均匀，不要冲突。</p>
<p>这就需要我们把这个极为复杂类型的每个成员（对 string 而言就是每个字符）都加到最终结果的表达式中。</p>
<p>以字符串类型 string 为例，常见的一种生成“摘要”的方法是，用一个任意素数的乘方序列和各字符的 ASCII 码做点积：</p>
<pre><code class="language-cpp">size_t hash_string(string const &amp;s) {
    size_t h = 0;
    for (char c: s) {
        h = h * 37 + c;
    }
    return h;
}
</code></pre>
<p>例如对于字符串 &ldquo;hello&rdquo;，则 hash 可以生成这样一个摘要：</p>
<pre><code class="language-cpp">size_t h = ((('h' * 37 + 'e') * 37 + 'l') * 37 + 'l') * 37 + 'o';
</code></pre>
<p>相当于 <span class="arithmatex"><span class="MathJax_Preview">h \cdot 37^4 + e \cdot 37^3 + l \cdot 37^2 + l \cdot 37 + o</span><script type="math/tex">h \cdot 37^4 + e \cdot 37^3 + l \cdot 37^2 + l \cdot 37 + o</script></span></p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 也有其他更高效的生成摘要的方法，例如借助位运算。</p>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 甚至还有偷懒直接拿 strlen 当哈希函数的“世界上最好的哈希表”，我不说是谁。（其实是早期 PHP 啦）</p>
</blockquote>
<h4 id="_68">自动取模</h4>
<pre><code class="language-cpp">size_t h = ((('h' * 37 + 'e') * 37 + 'l') * 37 + 'l') * 37 + 'o';
</code></pre>
<p>随着字符串长度的增加，这个 h 肯定会超过 size_t 的表示范围，但是没关系，无符号整数的乘法、加法溢出不是未定义行为，他会自动 wrapping（取关于 <span class="arithmatex"><span class="MathJax_Preview">2^{64}</span><script type="math/tex">2^{64}</script></span> 的模），也就是只保留乘法结果和 2^64 取模的部分。</p>
<p>取模也是对哈希值常见的一个操作，反正哈希值是随机的，取模以后也是随机的，但是缩小了范围。</p>
<blockquote>
<p>基本假设：m 足够小时，一个均匀的分布取以 m 的模以后仍然应该是均匀的</p>
</blockquote>
<p>unordered_map 中桶的数量是有限的，为了把范围从 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> 到 <span class="arithmatex"><span class="MathJax_Preview">2^{64} - 1</span><script type="math/tex">2^{64} - 1</script></span> 的哈希值映射为 0 到 bucket_count - 1 的桶序号，他内部会把键的哈希值取以桶数量的模，作为一个键要存储到的桶的序号：</p>
<pre><code>bucket_index = hash(key) % bucket_count
</code></pre>
<h3 id="hash-trait">hash 是个 trait 类</h3>
<!-- PG216 -->

<p>std::hash 就是标准库用于计算哈希的仿函数类了，他和 std::less 一样，是一个 trait 类。</p>
<p>一些常见的类型有默认的实现，也可以针对自定义类型添加特化。</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct hash {
    size_t operator()(T const &amp;t) const noexcept;  // 有待实现
};

template &lt;&gt;
struct hash&lt;int&gt; {
    size_t operator()(int t) const noexcept {
        return t;  // 对 int 的特化
    }
};

template &lt;class T&gt;
struct hash&lt;T *&gt; {
    size_t operator()(T *t) const noexcept {
        return reinterpret_cast&lt;uintptr_t&gt;(t);  // 对 T * 的偏特化
    }
};
</code></pre>
<hr />
<p>std::hash 针对每个不同的类型做了特化，例如当我们需要计算 string 类型的 hash 时：</p>
<pre><code class="language-cpp">string str = &quot;Hello, world&quot;;
size_t h = hash&lt;string&gt;()(str);
print(str, &quot;的哈希是&quot;, h);
</code></pre>
<p>注意：这里有两个括号，第一个是空的。第一个括号创建仿函数对象，第二个用str作为实参调用仿函数的 <code>operator()</code>。当然还别忘了第一个尖括号，这个尖括号里的 string 表示的是 hash 仿函数接下来要接受参数的类型，之所以作为类的模板参数而不是模板函数，是为了方便特化和偏特化。同学们也可以自己写一个这样的函数，用起来就不用指定类型（如这里的 string）了，让模板函数自动推导参数类型（类似于 make_pair）：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
size_t do_hash(T const &amp;t) {
    return hash&lt;T&gt;()(t);
}
int main() {
    string str = &quot;Hello, world&quot;;
    size_t h = do_hash(str);
    print(str, &quot;的哈希是&quot;, h);
}
</code></pre>
<pre><code>&quot;Hello, world&quot; 的哈希是 14701251851404232991
</code></pre>
<hr />
<p>对任意类型哈希的结果都是一个 size_t，其在 32 位系统上等同于 uint32_t，在我们 64 为系统上等同于 uint64_t。选择 size_t 是为了能哈希了以后直接用于 unordered_map 中桶的索引。</p>
<p>由于 hash 是用作哈希表的哈希函数，而不是用于加密领域（请你移步 md5），或是用于随机数生成（请移步 mt19937），因此对于任意类型，只需要根据他生成一个 size_t 的哈希值即可，只要保证哈希值分布均匀即可，不一定要有随机性。例如标准库对 int 的 hash 实现就是个恒等函数——直接返回其整数值，不用做任何计算：</p>
<pre><code class="language-cpp">template &lt;&gt;
struct hash&lt;int&gt; {
    size_t operator()(int t) const noexcept {
        return t;  // 对 int 的特化真是什么也不做呢？
    }
};
</code></pre>
<p>而对于任意指针的实现则是直接把指针 bit-cast 成 size_t：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct hash&lt;T *&gt; {
    size_t operator()(T *t) const noexcept {
        return reinterpret_cast&lt;uintptr_t&gt;(t);  // 指针强制转换为整数
    }
};
</code></pre>
<hr />
<pre><code class="language-cpp">int i = 42;
int j = hash&lt;int&gt;()(i);  // 没想到罢！我系恒等函数哒
print(i, j);
</code></pre>
<pre><code>42 42
</code></pre>
<p>记住，std::hash 不是为了加密或随机而生的，他的功能仅仅是尽可能快速地把任意类型 T 映射到 size_t 而已。</p>
<p>至于这对 unordered_map 的性能有何影响？通常没有什么影响，除非输入键故意设为和 bucket_count 同模，毕竟反正你也无法断定输入键的排布模式，不论选什么哈希函数只要保证均匀都是可以的。而恒等函数刚好是均匀的，又不用额外的花里胡哨位运算浪费时间，反而可能因为键有序而提升了缓存局域性，提升了性能，所以各大厂商的标准库都是这么做的。</p>
<!-- PG215 -->

<h3 id="2_1">区别 2：时间复杂度</h3>
<ul>
<li>map 的查询和插入操作是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度的。</li>
<li>unordered_map 的查询和插入操作是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span> 复杂度的。</li>
</ul>
<p>看起来 unordered_map 更高效？那还要 map 干什么？完全上位替代啊？</p>
<p>但是我们要注意，上面所说的复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 只是平均下来的，并不代表每一次 unordered_map 插入操作的复杂度都是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>！所以，复杂度表示法里的这个 + 号就是这个意思，代表我这个复杂度只是多次运行取平均，如果只考虑单次最坏的情况，可能更高。</p>
<ul>
<li>map 的插入操作<strong>最坏</strong>也只是 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span> 复杂度的。</li>
<li>unordered_map 的插入操作<strong>最坏</strong>可以是 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度的。</li>
</ul>
<p>处理很高的数据量时，这一点最坏的情况会被平摊掉，unordered_map 更高效。</p>
<h4 id="_69">哈希表的复杂度不稳定</h4>
<p>所以 unordered_map 不稳定，虽然平均是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 复杂度，但最坏可达到 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度。背后的原因是什么呢？</p>
<p>原来 unordered_map 和 vector 一样，是一个需要不断动态扩容的容器。</p>
<p>如果不扩容，那么当很多元素挤在一个桶里，链表的压力就会变大，会很低效，因此 unordered_map 必须扩容。但是在扩容的时候是需要进行 rehash 操作的。一次扩容，就需要把所有的元素都移动一遍。</p>
<p>结果就是 unordered_map 的插入如果没触发 rehash，那就是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的。触发了，那就是最坏的情况，<span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 的。但是不触发的情况远多于触发了的，所以平均下来还是 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>，为了提醒人们他最坏的情况，所以写作 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>，读作“平摊 O1”（Amortized Constant）。</p>
<p>此外，不仅 unordered_map 的插入函数是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>，他的查询函数也是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span>。为什么呢？设想你在编写一个富连网服务器，如果黑客已知你的 hash 函数，那他就可以通过构造一系列特殊设计好的 key，他们的哈希刚好相等（或同模），这样就使得所有 key 刚好全部落在一个桶里，导致 unordered_map 退化成线性的链表，所有的查询和插入都变成了这一个桶上的链表遍历操作，复杂度达到最坏的 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>，这一现象叫做 hash 退化。</p>
<p>因此 hash 函数的好坏决定着 unordered_map 性能，对于安全领域来说，还要保证 hash 函数无法被黑客破解。只要 hash 函数足够随机，就能保证键不冲突，就很快，一旦出现键冲突就会变慢。但需要频繁使用的 hash 函数计算难度又不能太大，那又会影响性能，因此 hash 也不能太过复杂。</p>
<blockquote>
<p>标准库里存在这种“平摊复杂度”的例子还有很多，例如 vector 的 push_back 不 reserve 的话，就是 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span> 的，因为他需要动态扩容。</p>
</blockquote>
<!-- 虽然平均下来确实可以忽略不计，但他特定一次内确实有可能达到 -->

<h4 id="_70">哈希表的应用限制</h4>
<!-- PG218 -->

<p>一些实时性要求很高的领域就不能用 unordered_map。例如你造了个火箭，规定：火箭控制程序需要在 1000 μs 内对外界变化做出实时反应，如果不能及时做出反应，火箭就会做托马斯回旋给你看。</p>
<p>你在火箭控制程序中用了 unordered_map，这个程序会不断运行，以便控制火箭做出正确的机动，对抗侧向风干扰。第一次运行他在 180 μs 内反应了，第二次在 250 μs 内反应了，第三次 245 μs 内反应了，你觉得他很高效。</p>
<p>但是突然有一次，unordered_map 觉得他内部“桶太乱”了，急需重新扩容并 rehash 一下“忧化性能”。然后，他把所有的元素都移动了一遍，移动完了，把处理完的数据返回给火箭姿态调控系统，认为大功告成。但当他睁开眼睛一看，刚想要控制一下姿态呢？却发现自己已经在做托马斯回旋了！原来我这一“忧化”就忧了 4000 μs，超出了火箭实时响应的硬性指标，导致西装骰子人卷款跑路，小彭老师破产。</p>
<p>小彭老师重新创业，这次他选用了稳定的 map，第一次他在 810 μs 内反应了，第二次在 680 μs 内反应了，第三次 730 μs 内反应了，你觉得他很低效。但是他每一次都能成功卡点给你完成任务，从来不会突然超过 <span class="arithmatex"><span class="MathJax_Preview">O(\log N)</span><script type="math/tex">O(\log N)</script></span>，他的最坏情况是可控的，从而避免了托马斯破产回旋。小彭老师最终创业成功，1000 年后，我司成功建造完成 Type-II 文明所急需的戴森球，向星辰大海进军。</p>
<p>对实时性要求高的这类领域包括，音视频，造火箭，量化交易等。这类低延迟低吞吐量的领域对平摊复杂度很反感，他们只看重最坏的复杂度，而不是平均的。</p>
<p>但对于主打一个高吞吐量无所谓延迟的离线图形学，离线科学计算，实时性不重要的生态化反场景，我们可以认为 unordered_map 的平摊 <span class="arithmatex"><span class="MathJax_Preview">O(1)+</span><script type="math/tex">O(1)+</script></span> 就是比 map 高效的。</p>
<hr />
<!-- PG219 -->

<h3 id="3">区别 3：迭代器失效条件</h3>
<ul>
<li>map 和 unordered_map 都是只有当删除的刚好是迭代器指向的那个元素时才会失效，这点相同。</li>
<li>但 unordered_map 扩容时候的 rehash 操作会造成所有迭代器失效。</li>
</ul>
<blockquote>
<p>insert 可能导致 unordered_map 扩容，其他只读操作不会。</p>
</blockquote>
<p>迭代器指向的那个元素被删除时，不论 map 和 unordered_map 都会失效。</p>
<p>unordered_map 在 insert 时如果发生扩容，之前保存的迭代器可能失效，可以通过调用 reserve 避免 insert 时扩容。</p>
<!-- PG220 -->

<p>小彭老师编写好了迭代器失效表，方便你记忆:</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>clear</th>
<th>swap</th>
<th>opeartor=</th>
<th>rehash</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>map</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>unordered_map</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>容器</th>
<th>find</th>
<th>count</th>
<th>at</th>
<th>[]</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>map</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>unordered_map</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是，如果创建了新元素且 size / bucket_count &gt; max_load_factor</td>
</tr>
</tbody>
</table>
<!-- PG221 -->

<p>小彭老师编写好了迭代器失效表，方便你记忆:</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>push_back</th>
<th>insert</th>
<th>erase</th>
<th>reserve</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>是，如果 size &gt; capacity</td>
<td>是，如果插入位置在当前迭代器之前，或 size &gt; capacity</td>
<td>是，如果删除的元素在当前迭代器之前，或刚好是当前迭代器指向的</td>
<td>是</td>
</tr>
<tr>
<td>map</td>
<td>-</td>
<td>否</td>
<td>是，如果删除的刚好是当前迭代器指向的元素</td>
<td>-</td>
</tr>
<tr>
<td>unordered_map</td>
<td>-</td>
<td>是，如果 size / bucket_count &gt; max_load_factor</td>
<td>是，如果删除的刚好是当前迭代器指向的元素</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>也可以查看官方版《迭代器失效表》：https://en.cppreference.com/w/cpp/container#Iterator_invalidation</p>
<h3 id="load_factor">负载率（load_factor）</h3>
<!-- PG222 -->

<p>计算公式：负载因子(load_factor) = 当前元素数量(size) ÷ 当前桶的数量(bucket_count)</p>
<p>插入新元素后，当检测到负载因子大于最大负载因子（默认 1.0）时，就会自动进行 rehash 操作。</p>
<p>为了避免重复小规模扩容浪费时间，这次 rehash 会一次性扩容两倍（跟 vector 的 push_back 扩容类似）。</p>
<blockquote>
<p>最大负载因子可以通过 max_load_factor 函数调整。当前负载因子可以通过 load_factor 函数查询。</p>
</blockquote>
<p>直观理解：当每个桶平均都有一个元素时，unordered_map 就会认为已经很满了，就会扩容并重新分配位置。</p>
<blockquote>
<p>由于默认最大负载因子是 1.0，所以扩容条件等价于 size &gt; bucket_count</p>
</blockquote>
<hr />
<!-- PG223 -->

<h3 id="rehash">rehash 函数</h3>
<p>在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。<sup id="fnref28:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
<blockquote>
<p>除了扩容时自动的 rehash，确认数据插入完毕不会再改动时，我们也可以手动调用 rehash() 函数来优化容器中元素的排布，提升性能。</p>
</blockquote>
<pre><code class="language-cpp">unordered_map&lt;int, int&gt; umap;
for (int i = 1; i &lt;= 50; i++) {
    umap.emplace(i, i);
}
auto pair = umap.equal_range(49);  //获取键为 49 的键值对所在的区间，由于不是 multimap，区间大小只能为 0 或 1
for (auto iter = pair.first; iter != pair.second; ++iter) { //输出 pair 范围内的每个键值对的键的值
    cout &lt;&lt; iter-&gt;first &lt;&lt; '\n';
}
umap.rehash(10); //手动调用 rehash() 函数重哈希为 10 个桶
for (auto iter = pair.first; iter != pair.second; ++iter) { // 重哈希之后，之前保存的迭代器可能会发生变化
    cout &lt;&lt; iter-&gt;first &lt;&lt; '\n';
}
</code></pre>
<pre><code>49 
Segmentation fault (core dumped)
</code></pre>
<h3 id="hash">hash 需要特化</h3>
<!-- PG224 -->

<p>基于红黑树的映射表 map 只需支持比较运算的 less 即可，而 unordered_map 需要哈希和相等两个 trait，他们分别名叫 std::hash 和 std::equal_to。</p>
<p>虽然两者都是仿函数，但也有很多区别：</p>
<ol>
<li>hash 只接受一个参数，而 equal_to 接受两个参数。</li>
<li>hash 返回 size_t，而 equal_to 返回 bool 类型。</li>
<li>equal_to 有默认的实现，那就是调用运算符 ==。而 hash 没有默认实现，也没相应的运算符，只能手动特化。</li>
</ol>
<p>正因为如此，通常我们需要让一个类（例如 Student）支持 equal_to 或 less 这些有相应运算符的仿函数时，直接在类型内部定义 <code>operator==</code> 或 <code>operator&lt;</code> 即可，而 hash 则是只能用特化的方法才能支持上。</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct hash {
    size_t operator()(T const &amp;t) const noexcept;  // 有待实现
};

template &lt;class T&gt;
struct equal_to {
    bool operator()(T const &amp;x, T const &amp;y) const noexcept {
        return x == y;
    }
};
</code></pre>
<p>有些类型能用作 map 的键，但不能用作 unordered_map 的键。这是因为偷懒的标准库没对他们的 hash 特化！</p>
<p>例如 tuple 支持 &lt; 运算符，支持 less。</p>
<p>但是 tuple 没有 hash 的特化，不支持 hash。</p>
<pre><code class="language-cpp">tuple&lt;int, int&gt; tup;
size_t h = hash&lt;tuple&lt;int, int&gt;&gt;()(tup);  // 编译期报错：查无此函数！
</code></pre>
<pre><code class="language-cpp">unordered_map&lt;tuple&lt;int, int&gt;&gt;
</code></pre>
<!-- PG225 -->

<h3 id="tuple">给 tuple 等复合类型自定义哈希函数</h3>
<p>和 less 的情形一样，也是有三种解决方案：</p>
<ol>
<li>自定义一个 hash 的特化，equal_to 的特化</li>
</ol>
<pre><code class="language-cpp">template &lt;&gt;
struct std::hash&lt;Student&gt; {
    bool operator()(Student const &amp;x) const {
        return hash&lt;string&gt;()(x.name) ^ hash&lt;int&gt;(x.id) ^ hash&lt;int&gt;(x.sex);
    }
};

template &lt;&gt;
struct std::equal_to&lt;Student&gt; {
    bool operator()(Student const &amp;x, Student const &amp;y) const {
        return x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;
    }
};

unordered_map&lt;Student, int&gt; stutab;
</code></pre>
<ol start="2">
<li>自定义一个 hash 的仿函数类，一个 equal_to 的仿函数类，然后传入 unordered_map 做模板参数</li>
</ol>
<pre><code class="language-cpp">template &lt;&gt;
struct HashStudent {
    bool operator()(Student const &amp;x) const {
        return hash&lt;string&gt;()(x.name) ^ hash&lt;int&gt;(x.id) ^ hash&lt;int&gt;(x.sex);
    }
};

struct EqualStudent {
    bool operator()(Student const &amp;x, Student const &amp;y) const {
        return x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;
    }
};

unordered_map&lt;Student, int, HashStudent, EqualStudent&gt; stutab;
</code></pre>
<blockquote>
<p>注：如果 Student 已经定义了 <code>operator==</code>，则这里不用 EqualStudent，默认的 equal_to 会自动调用 == 运算符的。</p>
</blockquote>
<ol start="3">
<li>对于 tuple 而言，tuple 已经有了 == 运算符，不用特化 equal_to 了，只需要特化或指定 hash 即可</li>
</ol>
<pre><code class="language-cpp">template &lt;class ...Ts&gt;
inline size_t hash_combine(Ts const &amp;...ts) {
    return (std::hash&lt;Ts&gt;()(ts) ^ ...);
}

template &lt;class ...Ts&gt;
struct std::hash&lt;std::tuple&lt;Ts...&gt;&gt; {
    size_t operator()(std::tuple&lt;Ts...&gt; const &amp;x) const {
        return std::apply(hash_combine&lt;Ts...&gt;, x);
    }
};

unordered_map&lt;tuple&lt;string, int, int&gt;, int&gt; stutab;
</code></pre>
<h4 id="_71">试试看效果吧！</h4>
<pre><code class="language-cpp">template &lt;class ...Ts&gt;
inline size_t hash_combine(Ts const &amp;...ts) {
    return (std::hash&lt;Ts&gt;()(ts) ^ ...); // 把任意多个元素哈希通过“位异或(^)”拼凑成一个单独的哈希
}

template &lt;class ...Ts&gt;
struct std::hash&lt;std::tuple&lt;Ts...&gt;&gt; {
    size_t operator()(std::tuple&lt;Ts...&gt; const &amp;x) const {
        // std::apply 会把 tuple 里的元素全部展开来调用 hash_combine，相当于 Python 里的 *args
        return std::apply(hash_combine&lt;Ts...&gt;, x);
    }
};

int main() {
    tuple&lt;int, int&gt; t(42, 64);
    size_t h = hash&lt;tuple&lt;int, int&gt;&gt;()(t);
    print(t, &quot;的哈希值是:&quot;, h);
    return 0;
}
</code></pre>
<pre><code>{42, 64} 的哈希值是: 106
</code></pre>
<p>这里的计算是：42 ^ 64 = 106，位异或的知识可以去 Bing 搜索一下，或者问一下 GPT，CS 学生应该都知道的。</p>
<h3 id="hash_combine">更好的 hash_combine</h3>
<p>但是简简单单用一个位异或 ^ 来把两个成员的哈希组合起来，有个严重的问题，如果 <code>tuple&lt;int, int&gt;</code> 里的两个成员值刚好一样，则其两个哈希值也会一样，那么他们通过位异或 ^ 合并的结果就会始终为 0。</p>
<p>例如不论 (42, 42) 还是 (64, 64) 这两个 tuple，他们的哈希值都会为 0。明明具体值不同哈希值却相同，这就是发生了哈希冲突，这会严重影响 unordered_map 的性能，是必须避免的。</p>
<p>用 + 来组合也有这个问题，如果第一个成员刚好是另一个的相反数，或只要是两个数加起来和相等，就会冲突。</p>
<p>例如如果我们用 unordered_map 构建一张地图的话，就发现当玩家在往斜上方移动时就会变得特别卡顿，原来是因为玩家的历史轨迹刚好是一条 y = x 的曲线，斜率为 1，由于我们采用 ^ 来组合哈希，就导致刚好这条线上所有的点都会塌缩到 0 号桶去，让 unordered_map 退化成了 <span class="arithmatex"><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span> 复杂度。</p>
<h4 id="boosthash_combine">最先进的是 boost::hash_combine 的方法</h4>
<pre><code class="language-cpp">template &lt;class ...Ts&gt;
inline size_t hash_combine(Ts const &amp;...ts) {
    size_t h = 0;
    ((h ^= std::hash&lt;Ts&gt;()(ts) + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2)), ...);
    return h;
}

template &lt;class ...Ts&gt;
struct std::hash&lt;std::tuple&lt;Ts...&gt;&gt; {
    size_t operator()(std::tuple&lt;Ts...&gt; const &amp;x) const {
        return std::apply(hash_combine&lt;Ts...&gt;, x);
    }
};

int main() {
    tuple&lt;int, int&gt; t(42, 64);
    size_t h = hash&lt;tuple&lt;int, int&gt;&gt;()(t);
    print(t, &quot;的哈希值是:&quot;, h);
    return 0;
}
</code></pre>
<pre><code>{42, 64} 的哈希值是: 175247763666
</code></pre>
<p>可以看到随机性大大提升了。</p>
<h4 id="_72">应用</h4>
<p>用 hash_combine 改进刚刚 Student 的哈希函数。</p>
<pre><code class="language-cpp">template &lt;&gt;
struct std::hash&lt;Student&gt; {
    bool operator()(Student const &amp;x) const {
        return hash_combine(hash&lt;string&gt;()(x.name), hash&lt;int&gt;(x.id), hash&lt;int&gt;(x.sex));
    }
};
</code></pre>
<p>同理可得 array 的特化</p>
<pre><code class="language-cpp">template &lt;class T, size_t N&gt;
struct std::hash&lt;std::array&lt;T, N&gt;&gt; {
    size_t operator()(std::array&lt;T, N&gt; const &amp;x) const {
        std::hash&lt;T&gt; hasher;
        size_t h = 0;
        for (T const &amp;t: x) {
            h ^= hasher(t);
        }
        return h;
    }
};

unordered_map&lt;array&lt;string, 3&gt;, int&gt; stutab;
</code></pre>
<p>采用素数乘方法来提升哈希函数的均匀性和随机性：</p>
<pre><code class="language-cpp">template &lt;class T, size_t N&gt;
struct std::hash&lt;std::array&lt;T, N&gt;&gt; {
    size_t operator()(std::array&lt;T, N&gt; const &amp;x) const {
        std::hash&lt;T&gt; hasher;
        size_t h = 0;
        for (T const &amp;t: x) {
            h = h * 18412483 + hasher(t);
        }
        return h;
    }
};

unordered_map&lt;array&lt;string, 3&gt;, int&gt; stutab;
</code></pre>
<p>采用最高级的，基于位运算的，最高效的，boost::hash_combine 的实现：</p>
<pre><code class="language-cpp">template &lt;class T, size_t N&gt;
struct std::hash&lt;std::array&lt;T, N&gt;&gt; {
    size_t operator()(std::array&lt;T, N&gt; const &amp;x) const {
        std::hash&lt;T&gt; hasher;
        size_t h = 0;
        for (T const &amp;t: x) {
            h ^= hasher(t) + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);
        }
        return h;
    }
};

unordered_map&lt;array&lt;string, 3&gt;, int&gt; stutab;
</code></pre>
<!-- PG226 -->

<h2 id="_73">经典案例</h2>
<h3 id="map-function">map 和 function 结合使用</h3>
<p>TODO</p>
<!-- PG227 -->

<h3 id="map-variant">map 和 variant 结合使用</h3>
<hr />
<!-- PG228 -->

<h3 id="map-string_view">map 和 string_view 结合使用透明查找案例</h3>
<!-- PG229 -->

<h3 id="c-api">全局句柄表实现仿 C 语言 API</h3>
<pre><code class="language-cpp">    Student(Student &amp;&amp;) = delete;
    // 冷知识：只需要删除移动构造函数，编译器就会自动帮你删除下面几个，不用写全：
    // Student &amp;operator=(Student &amp;&amp;) = delete;
    // Student(Student const &amp;) = delete;
    // Student &amp;operator=(Student const &amp;) = delete;
</code></pre>
<p>TODO</p>
<h3 id="_74">全局注册表实现动态反射</h3>
<p>TODO</p>
<h3 id="_75">带缓存的编译函数</h3>
<p>TODO</p>
<h2 id="_76">问题：多线程安全</h2>
<p><img alt="threadcompatible" src="../img/stl/threadcompatible.png" /></p>
<p>TODO</p>
<!-- PG233 -->

<h2 id="_77">本期孝点总结</h2>
<ul>
<li>有手之前，非常好用</li>
<li>马桶装面包</li>
<li>“析构”相依1号</li>
<li>小彭老师语录</li>
<li>看到老鼠💩过激反应</li>
<li>《好友清除计划》</li>
<li>小学生早操排队</li>
<li>小黄花表示黄牌警告</li>
<li>托马斯破产回旋</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>http://c.biancheng.net/view/7236.html&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref8:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref9:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref10:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref11:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref12:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref13:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref14:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref15:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref16:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref17:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref18:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref19:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref20:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref21:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref22:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref23:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref24:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref25:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref26:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref27:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref28:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>https://en.cppreference.com/w/cpp/container/node_handle&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:2" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:2" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>小彭老师倾 ♥ 制作</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../js/print-site.js"></script>
        <script src="../extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
